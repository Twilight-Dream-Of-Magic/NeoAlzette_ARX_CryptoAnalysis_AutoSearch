#include <cstdint>
#include <iostream>
#include <iomanip>
#include <vector>
#include <string>
#include <limits>
#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <unordered_set>
#include <thread>
#include <mutex>
#include <atomic>
#include <random>
#include <chrono>
#include <fstream>
#include <sstream>
#include <ctime>
#include <limits>

#if defined( _WIN32 )
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <windows.h>
#elif defined( __linux__ )
#include <sys/sysinfo.h>
#endif

#include "auto_search_frame/test_neoalzette_differential_best_search.hpp"

namespace
{
	using namespace TwilightDream::auto_search_differential;
	using ::TwilightDream::NeoAlzetteCore;
	using TwilightDream::runtime_component::bytes_to_gibibytes;
	using TwilightDream::runtime_component::compute_memory_headroom_bytes;
	using TwilightDream::runtime_component::governor_poll_system_memory_once;
	using TwilightDream::runtime_component::IosStateGuard;
	using TwilightDream::runtime_component::MemoryBallast;
	using TwilightDream::runtime_component::query_system_memory_info;
	using TwilightDream::runtime_component::resolve_worker_thread_count_for_command_line_interface;
	using TwilightDream::runtime_component::run_worker_threads_with_monitor;
	using TwilightDream::runtime_component::SystemMemoryInfo;

	using BestSearchResult = MatsuiSearchRunDifferentialResult;

	struct CommandLineOptions
	{
		enum class FrontendMode
		{
			Strategy,
			Detail,
			Auto
		};
		enum class StrategyPreset
		{
			None,
			TimeFirst,
			Balanced,
			SpaceFirst
		};

		FrontendMode   frontend_mode = FrontendMode::Detail;
		StrategyPreset strategy_preset = StrategyPreset::None;
		bool		   strategy_heuristics_enabled = false;
		int			   strategy_resolved_worker_threads = 1;
		std::uint64_t  strategy_total_physical_bytes = 0;
		std::uint64_t  strategy_available_physical_bytes = 0;
		std::uint64_t  strategy_target_headroom_bytes = 0;	// for time-first memory budgeting (keep headroom; default ~2~4 gibibytes)
		std::uint64_t  strategy_derived_budget_bytes = 0;	// derived = max(0, avail - headroom)
		std::uint64_t  strategy_total_work = 0;				// user-provided: "endpoint/total amount"; used to scale batch-job-count and maximum_search_nodes
		bool		   strategy_total_work_was_provided = false;
		bool		   strategy_batch_was_requested = false;  // strategy-only: explicit "I want batch mode" (lets total-work decide batch-job-count)

		// Memory (safety-first "near-limit" mode): keep some headroom, optionally allocate/release ballast to stay near the limit.
		bool		  memory_ballast_enabled = false;
		std::uint64_t memory_headroom_mib = 0;	// 0 = default headroom rule
		bool		  memory_headroom_mib_was_provided = false;

		int			  round_count = 3;
		std::uint32_t initial_branch_a_difference = 0x00000000u;
		std::uint32_t initial_branch_b_difference = 0x00000000u;
		bool		  initial_differences_were_provided = false;   // user provided (delta_a, delta_b) explicitly (positional)
		bool		  initial_differences_were_generated = false;  // generated by a random number generator from --seed

		bool selftest = false;
		bool show_help = false;

		// Auto mode (single-run only)
		std::size_t	  auto_breadth_candidate_count = 256;  // scan this many candidate (delta_a, delta_b) pairs (includes the provided start pair)
		std::size_t	  auto_breadth_top_k = 3;			   // keep/print top-K breadth candidates; deep stage selects the best one
		int			  auto_breadth_thread_count = 0;	   // 0=auto (hardware_concurrency)
		std::uint64_t auto_breadth_seed = 0;			   // random-number-generator seed for generating candidates (if not provided, derived from start differences)
		bool		  auto_breadth_seed_was_provided = false;
		std::size_t	  auto_breadth_maximum_search_nodes = std::numeric_limits<uint32_t>::max() >> 12;  // per candidate
		std::size_t	  auto_breadth_maximum_constant_subtraction_candidates = 128;					   // breadth heuristic cap
		std::size_t	  auto_breadth_heuristic_branch_cap = 512;										   // breadth heuristic cap (branching limiter)
		int			  auto_breadth_max_bit_flips = 4;												   // structured neighborhood: max random bit flips applied (1..this)
		bool		  auto_print_breadth_candidates = false;										   // print ALL breadth (delta_a, delta_b) candidates (can be large)
		std::size_t	  auto_deep_maximum_search_nodes = 0;											   // per candidate deep search (0=unlimited)
		std::uint64_t auto_max_time_seconds = 0;													   // deep-search time budget when auto_deep_maximum_search_nodes==0 (0=unlimited)
		int			  auto_target_best_weight = -1;													   // if >=0: stop early once best_weight <= target (weight = -log2(prob))

		// Batch mode
		std::size_t	  batch_job_count = 0;	   // 0 = disabled
		int			  batch_thread_count = 0;  // 0 = auto (hardware_concurrency)
		std::uint64_t batch_seed = 0;
		bool		  batch_seed_was_provided = false;	// require explicit --seed when a random number generator is used
		std::string	  batch_job_file {};
		bool		  batch_job_file_was_provided = false;
		std::size_t	  progress_every_jobs = 10;				 // print progress every N jobs
		std::uint64_t progress_every_seconds = 1;			 // print progress every N seconds (0=disable)
		std::size_t	  cache_max_entries_per_thread = 65536;	 // 0 = disable cache
		bool		  cache_was_provided = false;
		std::size_t	  shared_cache_total_entries = 0;  // 0 = disabled
		std::size_t	  shared_cache_shards = 256;
		bool		  shared_cache_shards_was_provided = false;
		bool		  shared_cache_was_provided = false;

		DifferentialBestSearchConfiguration search_configuration {};
	};

	static inline const char* to_string( CommandLineOptions::FrontendMode m )
	{
		switch ( m )
		{
		case CommandLineOptions::FrontendMode::Strategy:
			return "strategy";
		case CommandLineOptions::FrontendMode::Detail:
			return "detail";
		case CommandLineOptions::FrontendMode::Auto:
			return "auto";
		}
		return "unknown";
	}

	static inline const char* to_string( CommandLineOptions::StrategyPreset p )
	{
		switch ( p )
		{
		case CommandLineOptions::StrategyPreset::None:
			return "none";
		case CommandLineOptions::StrategyPreset::TimeFirst:
			return "time";
		case CommandLineOptions::StrategyPreset::Balanced:
			return "balanced";
		case CommandLineOptions::StrategyPreset::SpaceFirst:
			return "space";
		}
		return "unknown";
	}

	static inline std::string to_lowercase_ascii( std::string s )
	{
		for ( char& ch : s )
		{
			if ( ch >= 'A' && ch <= 'Z' )
				ch = char( ch - 'A' + 'a' );
		}
		return s;
	}

	static bool parse_strategy_preset( const char* s, CommandLineOptions::StrategyPreset& out )
	{
		if ( !s )
			return false;
		const std::string v = to_lowercase_ascii( std::string( s ) );
		if ( v == "time" || v == "time-first" || v == "time_first" || v == "t" )
		{
			out = CommandLineOptions::StrategyPreset::TimeFirst;
			return true;
		}
		if ( v == "balanced" || v == "balance" || v == "b" )
		{
			out = CommandLineOptions::StrategyPreset::Balanced;
			return true;
		}
		if ( v == "space" || v == "space-first" || v == "space_first" || v == "s" )
		{
			out = CommandLineOptions::StrategyPreset::SpaceFirst;
			return true;
		}
		return false;
	}

	static void print_usage_information( const char* executable_name )
	{
		std::cout << "Usage:\n"
				  << "  " << executable_name << " strategy <time|balanced|space> [strategy_options]\n"
				  << "  " << executable_name << " detail   [detail_options]\n"
				  << "  " << executable_name << " auto     [auto_options]\n"
				  << "\n"
				  << "Strategy mode (recommended, fewer knobs):\n"
				  << "  " << executable_name << " strategy <preset> --round-count R [--delta-a DELTA_A --delta-b DELTA_B | --seed SEED]\n"
				  << "                         [--batch-job-count N --thread-count T --seed S]\n"
				  << "  presets:\n"
				  << "    time      Time-first: no heuristics (heuristic_branch_cap=0).\n"
				  << "              Uses large caches, auto-sized from available physical memory.\n"
				  << "              Keeps headroom by default (~2~4 gibibytes) to maximize memory usage while staying stable.\n"
				  << "    balanced  Balanced: moderate memory. Heuristics enabled; heuristic_branch_cap is auto-chosen from threads/rounds.\n"
				  << "    space     Space-first: lower memory. Memoization off. Heuristics enabled; heuristic_branch_cap is auto-chosen (smaller).\n"
				  << "  strategy options:\n"
				  << "    --round-count R\n"
				  << "    --delta-a DELTA_A   --delta-b DELTA_B\n"
				  << "    --seed SEED\n"
				  << "    --total-work N          Auto-scale budgets (maximum_search_nodes, caches). Alias: --total. In batch: sets job count to N.\n"
				  << "    --batch                Enable batch mode (job count comes from --total-work).\n"
				  << "    --batch-job-count N     Enable batch mode with explicit job count. (batch requires --seed)\n"
				  << "    --progress-every-seconds S  Alias: --progress-sec. Print progress every S seconds (0=disable).\n"
				  << "    --thread-count T\n\n"
				  << "Detail mode (full knobs, long names; short-name aliases kept):\n"
				  << "  " << executable_name << " detail --round-count R [--delta-a DELTA_A --delta-b DELTA_B | --seed SEED] [options]\n\n"
				  << "Auto mode (two-stage: breadth scan -> deep search, requires explicit (delta_a, delta_b)):\n"
				  << "  " << executable_name << " auto --round-count R --delta-a DELTA_A --delta-b DELTA_B [options]\n"
				  << "    (breadth) scans many candidate initial (delta_a, delta_b) pairs to find sweet-spot differentials.\n"
				  << "    (deep)    runs a high-budget search on the best candidate (selected from the top-K pool).\n"
				  << "  auto options:\n"
				  << "    --auto-breadth-jobs N           Alias: --auto-breadth-max-runs. Candidate count (default=256).\n"
				  << "    --auto-breadth-top_candidates K          Keep/print top K breadth candidates (default=3). Deep runs the best one.\n"
				  << "    --auto-breadth-threads T       Breadth threads (0=auto, default=auto).\n"
				  << "    --auto-breadth-seed S          Random-number-generator seed for breadth candidates (default: derived from start differences).\n"
				  << "    --auto-breadth-maxnodes N      Breadth per-candidate maximum_search_nodes (default=1048575).\n"
				  << "    --auto-breadth-maxconst N      Breadth maximum_constant_subtraction_candidates cap (default=128).\n"
				  << "    --auto-breadth-heuristic-branch-cap N  Alias: --auto-breadth-hcap. Breadth branching limiter (default=512).\n"
				  << "    --auto-breadth-max-bitflips F  Structured neighborhood: max random bit flips (default=4).\n"
				  << "    --auto-print-breadth-candidates  Print ALL breadth candidates (warning: verbose).\n"
				  << "    --auto-deep-maxnodes N         Deep per-candidate maximum_search_nodes (default=0=unlimited).\n"
				  << "    --auto-max-time T              Deep time budget when deep maximum_search_nodes==0. Examples: 3600, 30d, 4w.\n"
				  << "    --auto-target-best-weight W    Stop once best_weight <= W (e.g. W=32 => prob >= 2^-32).\n\n"
				  << "Modes:\n"
				  << "  (1) Single-run best-search (default): given (delta_a, delta_b) find best trail for <rounds> rounds.\n"
				  << "  (2) Batch multi-thread search: generate many random (delta_a, delta_b) jobs and search them in parallel.\n\n"
				  << "Common options:\n"
				  << "  --selftest                  Run ARX operator self-tests and exit.\n"
				  << "  --help, -h                  Show this help.\n"
				  << "  --round-count R             (= positional [rounds])\n"
				  << "  --delta-a DELTA_A --delta-b DELTA_B   (= positional [delta_a_hex] [delta_b_hex])\n"
				  << "  --addition-weight-cap N     Alias: --add. Per modular-addition weight cap (0..31).\n"
				  << "  --constant-subtraction-weight-cap N\n"
				  << "                             Alias: --subtract. Per sub-const weight cap (0..32).\n"
				  << "  --maximum-constant-subtraction-candidates N\n"
				  << "                             Alias: --maxconst. Max enumerated output-diffs for each sub-const op (0=exact/all).\n"
				  << "  --heuristic-branch-cap N   Alias: --hcap. Branching limiter for expensive enumeration (0=exact/all).\n"
				  << "  --maximum-search-nodes N    Alias: --maxnodes. Max search nodes per job (safety limit). 0=unlimited.\n"
				  << "  --target-best-weight W      Alias: --target-weight. Stop early once best_weight <= W (weight=-log2(prob)).\n"
				  << "  --disable-state-memoization Alias: --nomemo. Disable round-boundary memoization (less memory, usually slower).\n"
				  << "  --enable-verbose-output     Alias: --verbose. Verbose output (single-run only).\n"
				  << "  --suffix-weight-lb LIST     Matsui-style remaining-round lower bounds (weights). Comma-separated.\n"
				  << "                             Example: \"0,0,12,20\" means W0=0, W1=0, W2=12, W3=20.\n"
				  << "  --suffix-weight-lb-file PATH  Same as above, but one integer per line (index = rounds_left).\n"
				  << "  --memory-headroom-mib M     Keep ~M MiB of free RAM headroom (default: max(2GiB, min(4GiB, avail/10))).\n"
				  << "  --memory-ballast            Adaptive ballast: allocate/release RAM to keep free RAM near headroom (near-limit, but avoids OS thrash).\n\n"
				  << "Batch options:\n"
				  << "  --batch-job-count N         Alias: --batch. Enable batch mode with N random start differences.\n"
				  << "  --batch-file PATH           Batch mode from file. Each non-empty line is either:\n"
				  << "                             - \"delta_a delta_b\" (use global --round-count)\n"
				  << "                             - \"round_count delta_a delta_b\" (per-job round count overrides global)\n"
				  << "                             Numbers accept hex (0x...) or decimal; commas are allowed; lines starting with # are comments.\n"
				  << "  --thread-count THREADS      Alias: --threads. Thread count (0=auto, default auto).\n"
				  << "  --seed SEED                 Random-number-generator seed (hex or decimal). Required when generating (delta_a, delta_b).\n"
				  << "  --progress-every-jobs N     Alias: --progress. Print progress every N jobs (default=10, 0=disable).\n"
				  << "  --progress-every-seconds S  Alias: --progress-sec. Print progress every S seconds (default=1, 0=disable).\n"
				  << "  --cache-max-entries-per-thread N\n"
				  << "                             Alias: --cache. Max per-thread cache entries.\n"
				  << "                             Default: auto (~1048576/threads, clamped 4096..262144). 0=disable.\n\n"
				  << "  --shared-cache-total-entries N\n"
				  << "                             Alias: --cache-shared. Enable shared (cross-thread) cache with total N entries (0=disable).\n"
				  << "  --shared-cache-shards S\n"
				  << "                             Alias: --cache-shards. Shard count for shared cache (default=256, rounded up to power-of-two).\n\n"
				  << "Examples:\n"
				  << "  " << executable_name << " strategy balanced --round-count 4 --delta-a 0x0 --delta-b 0x1\n"
				  << "  " << executable_name << " auto --round-count 4 --delta-a 0x0 --delta-b 0x1 --auto-breadth-jobs 512 --auto-breadth-top_candidates 3 --auto-breadth-threads 0\n"
				  << "  " << executable_name << " detail --round-count 4 --seed 0x1234 --maximum-search-nodes 5000000 --maximum-constant-subtraction-candidates 1024\n";
	}

	// Forward declarations (command-line parsing uses these before their definitions later in this file).
	static bool						 parse_signed_integer_32( const char* text, int& value_out );
	static bool						 parse_unsigned_integer_32( const char* text, std::uint32_t& value_out );
	static bool						 parse_unsigned_integer_64( const char* text, std::uint64_t& value_out );
	static bool						 parse_duration_in_seconds( const char* text, std::uint64_t& seconds_out );
	static bool						 parse_suffix_weight_lower_bounds_list( const char* text, std::vector<int>& out );
	static bool						 load_suffix_weight_lower_bounds_file( const char* path, std::vector<int>& out );
	static inline std::size_t&		 heuristic_branch_cap( DifferentialBestSearchConfiguration& cfg );
	static inline const std::size_t& heuristic_branch_cap( const DifferentialBestSearchConfiguration& cfg );

	static bool parse_command_line_auto_mode( int argument_count, char** argument_values, int start_index, CommandLineOptions& command_line_options )
	{
		// Auto mode: requires explicit (delta_a, delta_b); no random-number-generator seed fallback; single-run only.
		int	 argument_index = start_index;
		auto is_option = []( const char* s ) -> bool {
			return s && s[ 0 ] == '-';
		};
		if ( argument_index < argument_count && !is_option( argument_values[ argument_index ] ) )
		{
			int round_count = 0;
			if ( !parse_signed_integer_32( argument_values[ argument_index ], round_count ) || round_count <= 0 )
				return false;
			command_line_options.round_count = round_count;
			++argument_index;
		}
		if ( argument_index < argument_count && !is_option( argument_values[ argument_index ] ) )
		{
			if ( !parse_unsigned_integer_32( argument_values[ argument_index ], command_line_options.initial_branch_a_difference ) )
				return false;
			command_line_options.initial_differences_were_provided = true;
			++argument_index;
		}
		if ( command_line_options.initial_differences_were_provided )
		{
			if ( argument_index >= argument_count || is_option( argument_values[ argument_index ] ) )
				return false;
			if ( !parse_unsigned_integer_32( argument_values[ argument_index ], command_line_options.initial_branch_b_difference ) )
				return false;
			++argument_index;
		}

		bool		  delta_a_option_was_provided = false;
		bool		  delta_b_option_was_provided = false;
		std::uint32_t delta_a_option_value = 0;
		std::uint32_t delta_b_option_value = 0;

		for ( ; argument_index < argument_count; ++argument_index )
		{
			const std::string argument = argument_values[ argument_index ];
			if ( argument == "--selftest" || argument == "--help" || argument == "-h" )
				continue;
			if ( argument == "--mode" )
			{
				if ( argument_index + 1 < argument_count )
					++argument_index;
				continue;
			}

			if ( ( argument == "--round-count" || argument == "--rounds" ) && argument_index + 1 < argument_count )
			{
				int round_count = 0;
				if ( !parse_signed_integer_32( argument_values[ ++argument_index ], round_count ) || round_count <= 0 )
					return false;
				command_line_options.round_count = round_count;
			}
			else if ( ( argument == "--delta-a" || argument == "--initial-branch-a-difference" ) && argument_index + 1 < argument_count )
			{
				if ( !parse_unsigned_integer_32( argument_values[ ++argument_index ], delta_a_option_value ) )
					return false;
				delta_a_option_was_provided = true;
			}
			else if ( ( argument == "--delta-b" || argument == "--initial-branch-b-difference" ) && argument_index + 1 < argument_count )
			{
				if ( !parse_unsigned_integer_32( argument_values[ ++argument_index ], delta_b_option_value ) )
					return false;
				delta_b_option_was_provided = true;
			}

			else if ( ( argument == "--addition-weight-cap" || argument == "--add" ) && argument_index + 1 < argument_count )
			{
				int value = 0;
				if ( !parse_signed_integer_32( argument_values[ ++argument_index ], value ) )
					return false;
				command_line_options.search_configuration.addition_weight_cap = std::clamp( value, 0, 31 );
			}
			else if ( ( argument == "--constant-subtraction-weight-cap" || argument == "--subtract" ) && argument_index + 1 < argument_count )
			{
				int value = 0;
				if ( !parse_signed_integer_32( argument_values[ ++argument_index ], value ) )
					return false;
				command_line_options.search_configuration.constant_subtraction_weight_cap = std::clamp( value, 0, 32 );
			}
			else if ( ( argument == "--maximum-constant-subtraction-candidates" || argument == "--maxconst" ) && argument_index + 1 < argument_count )
			{
				command_line_options.search_configuration.maximum_constant_subtraction_candidates = std::size_t( std::strtoull( argument_values[ ++argument_index ], nullptr, 10 ) );
			}
			else if ( ( argument == "--heuristic-branch-cap" || argument == "--hcap" ) && argument_index + 1 < argument_count )
			{
				heuristic_branch_cap( command_line_options.search_configuration ) = std::size_t( std::strtoull( argument_values[ ++argument_index ], nullptr, 10 ) );
			}
			else if ( ( argument == "--maximum-search-nodes" || argument == "--maxnodes" ) && argument_index + 1 < argument_count )
			{
				command_line_options.search_configuration.maximum_search_nodes = std::size_t( std::strtoull( argument_values[ ++argument_index ], nullptr, 10 ) );
			}
			else if ( ( argument == "--target-best-weight" || argument == "--target-weight" ) && argument_index + 1 < argument_count )
			{
				int value = 0;
				if ( !parse_signed_integer_32( argument_values[ ++argument_index ], value ) )
					return false;
				command_line_options.search_configuration.target_best_weight = value;
			}

			else if ( ( argument == "--progress-every-seconds" || argument == "--progress-sec" ) && argument_index + 1 < argument_count )
			{
				std::uint64_t seconds = 0;
				if ( !parse_unsigned_integer_64( argument_values[ ++argument_index ], seconds ) )
					return false;
				command_line_options.progress_every_seconds = seconds;
			}
			else if ( argument == "--memory-headroom-mib" && argument_index + 1 < argument_count )
			{
				std::uint64_t mib = 0;
				if ( !parse_unsigned_integer_64( argument_values[ ++argument_index ], mib ) )
					return false;
				command_line_options.memory_headroom_mib = mib;
				command_line_options.memory_headroom_mib_was_provided = true;
			}
			else if ( argument == "--memory-ballast" )
			{
				command_line_options.memory_ballast_enabled = true;
			}

			else if ( ( argument == "--cache-max-entries-per-thread" || argument == "--cache" ) && argument_index + 1 < argument_count )
			{
				std::uint64_t entries = 0;
				if ( !parse_unsigned_integer_64( argument_values[ ++argument_index ], entries ) )
					return false;
				command_line_options.cache_max_entries_per_thread = std::size_t( entries );
				command_line_options.cache_was_provided = true;
			}
			else if ( ( argument == "--shared-cache-total-entries" || argument == "--cache-shared" ) && argument_index + 1 < argument_count )
			{
				std::uint64_t entries = 0;
				if ( !parse_unsigned_integer_64( argument_values[ ++argument_index ], entries ) )
					return false;
				command_line_options.shared_cache_total_entries = std::size_t( entries );
				command_line_options.shared_cache_was_provided = true;
			}
			else if ( ( argument == "--shared-cache-shards" || argument == "--cache-shards" ) && argument_index + 1 < argument_count )
			{
				std::uint64_t shard_count = 0;
				if ( !parse_unsigned_integer_64( argument_values[ ++argument_index ], shard_count ) || shard_count == 0 )
					return false;
				command_line_options.shared_cache_shards = std::size_t( shard_count );
				command_line_options.shared_cache_shards_was_provided = true;
			}

			else if ( argument == "--disable-state-memoization" || argument == "--nomemo" )
			{
				command_line_options.search_configuration.enable_state_memoization = false;
			}
			else if ( argument == "--enable-state-memoization" )
			{
				command_line_options.search_configuration.enable_state_memoization = true;
			}
			else if ( argument == "--enable-verbose-output" || argument == "--verbose" )
			{
				command_line_options.search_configuration.enable_verbose_output = true;
			}
			else if ( argument == "--suffix-weight-lb" && argument_index + 1 < argument_count )
			{
				std::vector<int> suffix_weight_lower_bounds {};
				if ( !parse_suffix_weight_lower_bounds_list( argument_values[ ++argument_index ], suffix_weight_lower_bounds ) )
					return false;
				command_line_options.search_configuration.enable_remaining_round_lower_bound = true;
				command_line_options.search_configuration.remaining_round_min_weight = std::move( suffix_weight_lower_bounds );
			}
			else if ( argument == "--suffix-weight-lb-file" && argument_index + 1 < argument_count )
			{
				std::vector<int> suffix_weight_lower_bounds {};
				if ( !load_suffix_weight_lower_bounds_file( argument_values[ ++argument_index ], suffix_weight_lower_bounds ) )
					return false;
				command_line_options.search_configuration.enable_remaining_round_lower_bound = true;
				command_line_options.search_configuration.remaining_round_min_weight = std::move( suffix_weight_lower_bounds );
			}

			else if ( ( argument == "--auto-breadth-jobs" || argument == "--auto-breadth-max-runs" ) && argument_index + 1 < argument_count )
			{
				std::uint64_t count = 0;
				if ( !parse_unsigned_integer_64( argument_values[ ++argument_index ], count ) || count == 0 )
					return false;
				command_line_options.auto_breadth_candidate_count = std::size_t( std::min<std::uint64_t>( count, std::uint64_t( 1000000 ) ) );
			}
			else if ( argument == "--auto-breadth-top_candidates" && argument_index + 1 < argument_count )
			{
				std::uint64_t top_k = 0;
				if ( !parse_unsigned_integer_64( argument_values[ ++argument_index ], top_k ) || top_k == 0 )
					return false;
				command_line_options.auto_breadth_top_k = std::size_t( std::min<std::uint64_t>( top_k, std::uint64_t( 64 ) ) );
			}
			else if ( ( argument == "--auto-breadth-threads" || argument == "--auto-breadth-thread-count" ) && argument_index + 1 < argument_count )
			{
				int thread_count = 0;
				if ( !parse_signed_integer_32( argument_values[ ++argument_index ], thread_count ) || thread_count < 0 )
					return false;
				command_line_options.auto_breadth_thread_count = thread_count;
			}
			else if ( argument == "--auto-breadth-seed" && argument_index + 1 < argument_count )
			{
				std::uint64_t seed = 0;
				if ( !parse_unsigned_integer_64( argument_values[ ++argument_index ], seed ) )
					return false;
				command_line_options.auto_breadth_seed = seed;
				command_line_options.auto_breadth_seed_was_provided = true;
			}
			else if ( argument == "--auto-breadth-maxnodes" && argument_index + 1 < argument_count )
			{
				std::uint64_t maximum_search_nodes = 0;
				if ( !parse_unsigned_integer_64( argument_values[ ++argument_index ], maximum_search_nodes ) )
					return false;
				command_line_options.auto_breadth_maximum_search_nodes = std::size_t( maximum_search_nodes );
			}
			else if ( argument == "--auto-breadth-maxconst" && argument_index + 1 < argument_count )
			{
				std::uint64_t maximum_constant_subtraction_candidates = 0;
				if ( !parse_unsigned_integer_64( argument_values[ ++argument_index ], maximum_constant_subtraction_candidates ) )
					return false;
				command_line_options.auto_breadth_maximum_constant_subtraction_candidates = std::size_t( maximum_constant_subtraction_candidates );
			}
			// Breadth-only heuristic cap: limits enumeration of injection-step output differences per injection point.
			// (Does NOT change the injection/affine model; deep stage forces exact enumeration.)
			else if ( ( argument == "--auto-breadth-heuristic-branch-cap" || argument == "--auto-breadth-hcap" ) && argument_index + 1 < argument_count )
			{
				std::uint64_t cap = 0;
				if ( !parse_unsigned_integer_64( argument_values[ ++argument_index ], cap ) )
					return false;
				command_line_options.auto_breadth_heuristic_branch_cap = std::size_t( cap );
			}
			else if ( argument == "--auto-breadth-max-bitflips" && argument_index + 1 < argument_count )
			{
				int maximum_bit_flips = 0;
				if ( !parse_signed_integer_32( argument_values[ ++argument_index ], maximum_bit_flips ) || maximum_bit_flips <= 0 )
					return false;
				command_line_options.auto_breadth_max_bit_flips = std::clamp( maximum_bit_flips, 1, 32 );
			}
			else if ( argument == "--auto-print-breadth-candidates" )
			{
				command_line_options.auto_print_breadth_candidates = true;
			}
			else if ( argument == "--auto-deep-maxnodes" && argument_index + 1 < argument_count )
			{
				std::uint64_t maximum_search_nodes = 0;
				if ( !parse_unsigned_integer_64( argument_values[ ++argument_index ], maximum_search_nodes ) )
					return false;
				command_line_options.auto_deep_maximum_search_nodes = std::size_t( maximum_search_nodes );
			}
			else if ( argument == "--auto-max-time" && argument_index + 1 < argument_count )
			{
				std::uint64_t duration_seconds = 0;
				if ( !parse_duration_in_seconds( argument_values[ ++argument_index ], duration_seconds ) )
					return false;
				command_line_options.auto_max_time_seconds = duration_seconds;
			}
			else if ( argument == "--auto-target-best-weight" && argument_index + 1 < argument_count )
			{
				int target_best_weight = 0;
				if ( !parse_signed_integer_32( argument_values[ ++argument_index ], target_best_weight ) )
					return false;
				command_line_options.auto_target_best_weight = target_best_weight;
			}
			else
			{
				// Unknown option (and batch/seed are intentionally not supported here)
				return false;
			}
		}

		// If the user provided --delta-a/--delta-b, require both, and override positional arguments.
		if ( delta_a_option_was_provided || delta_b_option_was_provided )
		{
			if ( !( delta_a_option_was_provided && delta_b_option_was_provided ) )
				return false;
			command_line_options.initial_branch_a_difference = delta_a_option_value;
			command_line_options.initial_branch_b_difference = delta_b_option_value;
			command_line_options.initial_differences_were_provided = true;
		}

		// Selftest/help should be runnable without requiring (delta_a, delta_b).
		if ( command_line_options.selftest || command_line_options.show_help )
			return true;

		if ( !command_line_options.initial_differences_were_provided )
			return false;  // required by contract
		if ( command_line_options.initial_branch_a_difference == 0u && command_line_options.initial_branch_b_difference == 0u )
			return false;

		if ( command_line_options.auto_breadth_candidate_count == 0 )
			command_line_options.auto_breadth_candidate_count = 1;
		if ( command_line_options.auto_breadth_top_k == 0 )
			command_line_options.auto_breadth_top_k = 1;
		if ( command_line_options.auto_breadth_top_k > command_line_options.auto_breadth_candidate_count )
			command_line_options.auto_breadth_top_k = command_line_options.auto_breadth_candidate_count;
		if ( command_line_options.auto_breadth_maximum_search_nodes == 0 )
			command_line_options.auto_breadth_maximum_search_nodes = 1;	 // breadth must terminate
		// auto_deep_maximum_search_nodes: 0 means unlimited (user explicitly requested this behavior)
		if ( command_line_options.auto_target_best_weight >= 0 )
			command_line_options.search_configuration.target_best_weight = command_line_options.auto_target_best_weight;

		command_line_options.search_configuration.addition_weight_cap = std::clamp( command_line_options.search_configuration.addition_weight_cap, 0, 31 );
		command_line_options.search_configuration.constant_subtraction_weight_cap = std::clamp( command_line_options.search_configuration.constant_subtraction_weight_cap, 0, 32 );
		if ( command_line_options.round_count <= 0 )
			command_line_options.round_count = 1;
		return true;
	}

	static bool parse_unsigned_integer_64( const char* text, std::uint64_t& value_out )
	{
		if ( !text )
			return false;
		char*				end = nullptr;
		const std::uint64_t parsed_value = std::strtoull( text, &end, 0 );
		if ( !end || *end != '\0' )
			return false;
		value_out = parsed_value;
		return true;
	}

	static bool parse_duration_in_seconds( const char* text, std::uint64_t& seconds_out )
	{
		// Accept:
		// - plain integer: seconds
		// - suffixed: Ns, Nm, Nh, Nd, Nw  (seconds/minutes/hours/days/weeks)
		// Examples: 3600, 3600s, 60m, 24h, 30d, 4w
		if ( !text )
			return false;
		const std::string input( text );
		if ( input.empty() )
			return false;

		// Find numeric prefix.
		std::size_t numeric_prefix_length = 0;
		while ( numeric_prefix_length < input.size() && ( ( input[ numeric_prefix_length ] >= '0' && input[ numeric_prefix_length ] <= '9' ) || ( numeric_prefix_length == 0 && input[ numeric_prefix_length ] == '+' ) ) )
		{
			++numeric_prefix_length;
		}
		if ( numeric_prefix_length == 0 )
			return false;

		std::uint64_t numeric_value = 0;
		{
			const std::string numeric_part = input.substr( 0, numeric_prefix_length );
			// parse_unsigned_integer_64 requires full string; here numeric part is decimal only.
			char*				end = nullptr;
			const std::uint64_t parsed_value = std::strtoull( numeric_part.c_str(), &end, 10 );
			if ( !end || *end != '\0' )
				return false;
			numeric_value = parsed_value;
		}

		std::uint64_t multiplier = 1;
		if ( numeric_prefix_length < input.size() )
		{
			const std::string suffix = to_lowercase_ascii( input.substr( numeric_prefix_length ) );
			if ( suffix == "s" || suffix == "sec" || suffix == "secs" || suffix == "second" || suffix == "seconds" )
				multiplier = 1;
			else if ( suffix == "m" || suffix == "min" || suffix == "mins" || suffix == "minute" || suffix == "minutes" )
				multiplier = 60ull;
			else if ( suffix == "h" || suffix == "hr" || suffix == "hrs" || suffix == "hour" || suffix == "hours" )
				multiplier = 3600ull;
			else if ( suffix == "d" || suffix == "day" || suffix == "days" )
				multiplier = 86400ull;
			else if ( suffix == "w" || suffix == "wk" || suffix == "wks" || suffix == "week" || suffix == "weeks" )
				multiplier = 7ull * 86400ull;
			else
				return false;
		}

		// Saturating multiply to uint64.
		if ( numeric_value != 0 && multiplier != 0 )
		{
			const std::uint64_t maximum_value = std::numeric_limits<std::uint64_t>::max();
			if ( numeric_value > maximum_value / multiplier )
				seconds_out = maximum_value;
			else
				seconds_out = numeric_value * multiplier;
		}
		else
		{
			seconds_out = 0;
		}
		return true;
	}

	static bool parse_unsigned_integer_32( const char* text, std::uint32_t& value_out )
	{
		std::uint64_t value_64 = 0;
		if ( !parse_unsigned_integer_64( text, value_64 ) )
			return false;
		value_out = static_cast<std::uint32_t>( value_64 );
		return true;
	}

	static bool parse_signed_integer_32( const char* text, int& value_out )
	{
		if ( !text )
			return false;
		char*	   end = nullptr;
		const long parsed_value = std::strtol( text, &end, 0 );
		if ( !end || *end != '\0' )
			return false;
		value_out = static_cast<int>( parsed_value );
		return true;
	}

	static bool parse_suffix_weight_lower_bounds_list( const char* text, std::vector<int>& out )
	{
		out.clear();
		if ( !text )
			return false;
		std::string s( text );
		if ( s.empty() )
			return false;

		// Accept common separators and optional brackets.
		for ( char& ch : s )
		{
			switch ( ch )
			{
			case ',':
			case ';':
			case '|':
				ch = ' ';
				break;
			case '[':
			case ']':
			case '(':
			case ')':
			case '{':
			case '}':
				ch = ' ';
				break;
			default:
				break;
			}
		}

		std::istringstream iss( s );
		std::string		   token;
		while ( iss >> token )
		{
			int v = 0;
			if ( !parse_signed_integer_32( token.c_str(), v ) )
				return false;
			out.push_back( v );
		}
		return !out.empty();
	}

	static bool load_suffix_weight_lower_bounds_file( const char* path, std::vector<int>& out )
	{
		out.clear();
		if ( !path )
			return false;
		std::ifstream in( path );
		if ( !in )
			return false;

		std::vector<int> sequential {};
		std::vector<int> by_index {};
		bool			 saw_indexed = false;
		bool			 saw_sequential = false;

		auto trim_ascii = []( std::string& s ) {
			auto is_ws = []( unsigned char c ) { return c == ' ' || c == '\t' || c == '\r' || c == '\n'; };
			std::size_t begin = 0;
			while ( begin < s.size() && is_ws( static_cast<unsigned char>( s[ begin ] ) ) )
				++begin;
			std::size_t end = s.size();
			while ( end > begin && is_ws( static_cast<unsigned char>( s[ end - 1 ] ) ) )
				--end;
			if ( begin == 0 && end == s.size() )
				return;
			s = s.substr( begin, end - begin );
		};

		std::string line;
		bool		first_line = true;
		while ( std::getline( in, line ) )
		{
			// Strip UTF-8 BOM on the very first line if present.
			if ( first_line )
			{
				first_line = false;
				if ( line.size() >= 3u && static_cast<unsigned char>( line[ 0 ] ) == 0xEFu && static_cast<unsigned char>( line[ 1 ] ) == 0xBBu && static_cast<unsigned char>( line[ 2 ] ) == 0xBFu )
				{
					line.erase( 0, 3 );
				}
			}

			// Strip comments (# or //).
			{
				const std::size_t hash_pos = line.find( '#' );
				const std::size_t sl_pos = line.find( "//" );
				std::size_t		  cut = std::string::npos;
				if ( hash_pos != std::string::npos )
					cut = hash_pos;
				if ( sl_pos != std::string::npos )
					cut = ( cut == std::string::npos ) ? sl_pos : std::min( cut, sl_pos );
				if ( cut != std::string::npos )
					line.erase( cut );
			}

			trim_ascii( line );
			if ( line.empty() )
				continue;

			std::istringstream iss( line );
			std::string		   a, b;
			if ( !( iss >> a ) )
				continue;
			if ( iss >> b )
			{
				// Indexed format: "k weight"
				if ( saw_sequential )
					return false;	// do not allow mixing formats
				saw_indexed = true;
				int idx = 0;
				int w = 0;
				if ( !parse_signed_integer_32( a.c_str(), idx ) )
					return false;
				if ( !parse_signed_integer_32( b.c_str(), w ) )
					return false;
				if ( idx < 0 )
					return false;
				if ( std::size_t( idx ) >= by_index.size() )
					by_index.resize( std::size_t( idx ) + 1u, 0 );
				by_index[ std::size_t( idx ) ] = w;
			}
			else
			{
				// Sequential format: one integer per line
				if ( saw_indexed )
					return false;	// do not allow mixing formats
				saw_sequential = true;
				int w = 0;
				if ( !parse_signed_integer_32( a.c_str(), w ) )
					return false;
				sequential.push_back( w );
			}
		}

		if ( saw_indexed )
		{
			out = std::move( by_index );
			return !out.empty();
		}
		out = std::move( sequential );
		return !out.empty();
	}

	static void print_banner_and_mode( const CommandLineOptions& command_line_options )
	{
		std::cout << "============================================================\n";
		std::cout << "  Best Trail Search (Injection differential probability via affine derivative)\n";
		std::cout << "  - cd_injection_from_* is propagated in the difference path (NOT removed)\n";
		std::cout << "  - Injection affine-differential model (XOR with NOT-AND/NOT-OR): InjectionAffineTransition{basis_vectors, offset, rank_weight}\n";
		std::cout << "  - Uses LM2001 xdp_add operator for modular-addition weights\n";
		std::cout << "  - Cipher cross-mixing rotations: R0=" << NeoAlzetteCore::CROSS_XOR_ROT_R0 << "  R1=" << NeoAlzetteCore::CROSS_XOR_ROT_R1 << "  (R0+R1 mod32=" << NeoAlzetteCore::CROSS_XOR_ROT_SUM << ")\n";
		std::cout << "  - Command-line interface frontend: " << to_string( command_line_options.frontend_mode );
		if ( command_line_options.strategy_preset != CommandLineOptions::StrategyPreset::None )
		{
			std::cout << " (preset=" << to_string( command_line_options.strategy_preset ) << ", heuristics=" << ( command_line_options.strategy_heuristics_enabled ? "on" : "off" ) << ")";
		}
		std::cout << "\n";
		std::cout << "  - Mode: Matsui/Best-search (round-level branch-and-bound + bit recursion + injection branching)\n";
		std::cout << "============================================================\n";
	}

	static std::size_t compute_auto_shared_cache_shards( std::size_t shared_total_entries_per_cache, int resolved_worker_threads )
	{
		// Goal: reduce lock contention in shared caches when many threads are running, without exploding shard overhead
		// on tiny shared caches.
		const std::size_t t = std::size_t( std::max( 1, resolved_worker_threads ) );
		const std::size_t by_threads = t * 32;																						// 24 threads -> 768 -> 1024
		const std::size_t by_entries = ( shared_total_entries_per_cache >= 4096 ) ? ( shared_total_entries_per_cache / 4096 ) : 1;	// large cache -> more shards

		std::size_t desired = std::max<std::size_t>( { 256, by_threads, by_entries } );

		// Avoid creating too many shards for small caches: require at least 256 entries per shard on average.
		const std::size_t max_shards_by_min_per_shard_cap = std::max<std::size_t>( 1, shared_total_entries_per_cache / 256 );
		desired = std::min( desired, max_shards_by_min_per_shard_cap );

		desired = round_up_power_of_two( std::max<std::size_t>( 1, desired ) );
		desired = std::clamp( desired, std::size_t( 1 ), std::size_t( 16384 ) );
		return desired;
	}

	// ----------------------------------------------------------------------------
	// Naming isolation:
	// - The algorithm uses an injection-affine transition model.
	// - These knobs are *framework/heuristic* controls (branching limiter, caches).
	// Keep user-facing naming separate from algorithm terminology.
	// ----------------------------------------------------------------------------
	static inline std::size_t& heuristic_branch_cap( DifferentialBestSearchConfiguration& cfg )
	{
		// 0 = exact/unlimited enumeration.
		return cfg.maximum_transition_output_differences;
	}
	static inline const std::size_t& heuristic_branch_cap( const DifferentialBestSearchConfiguration& cfg )
	{
		return cfg.maximum_transition_output_differences;
	}

	static std::size_t compute_default_heuristic_branch_cap( CommandLineOptions::StrategyPreset preset, int resolved_worker_threads, int round_count )
	{
		// Heuristic branching limiter. Smaller cap -> lower memory/time.
		// Rule-of-thumb:
		// - Balanced: higher cap.
		// - Space: lower cap.
		const std::size_t base = ( preset == CommandLineOptions::StrategyPreset::Balanced ) ? 4096 : 512;

		// Scale down with thread count (keep overall work bounded in batch mode).
		std::size_t n = ( base * 8 ) / std::size_t( std::max( 1, resolved_worker_threads ) );
		if ( n > base )
			n = base;

		// Scale down for higher round counts.
		const int rc = std::max( 1, round_count );
		if ( rc >= 4 )
			n = std::max<std::size_t>( 64, n / 2 );
		if ( rc >= 6 )
			n = std::max<std::size_t>( 64, n / 2 );

		// Clamp to a sane minimum.
		n = std::max<std::size_t>( 64, n );
		return n;
	}

	static int compute_strategy_scale_from_total_work( std::uint64_t total_work )
	{
		// total_work -> multiplier for per-job search budget. Keep growth gentle.
		// scale = 1 + floor(log10(total_work)), clamped.
		// examples: 1 ->1, 10->2, 1e3->4, 1e6->7 (clamped).
		if ( total_work <= 1 )
			return 1;
		int			  s = 1;
		std::uint64_t v = total_work;
		while ( v >= 10 )
		{
			v /= 10;
			++s;
		}
		return std::clamp( s, 1, 8 );
	}

	static std::size_t saturating_mul_size_t( std::size_t a, std::size_t b )
	{
		if ( a == 0 || b == 0 )
			return 0;
		if ( a > std::numeric_limits<std::size_t>::max() / b )
			return std::numeric_limits<std::size_t>::max();
		return a * b;
	}

	static void apply_strategy_defaults( CommandLineOptions& command_line_options, CommandLineOptions::StrategyPreset preset, int resolved_worker_threads )
	{
		// Baselines that should not surprise users (keep the exact operator caps wide-open by default).
		command_line_options.search_configuration.addition_weight_cap = 31;
		command_line_options.search_configuration.constant_subtraction_weight_cap = 32;
		command_line_options.search_configuration.enable_verbose_output = false;

		command_line_options.strategy_resolved_worker_threads = std::max( 1, resolved_worker_threads );
		{
			const SystemMemoryInfo mem = query_system_memory_info();
			command_line_options.strategy_total_physical_bytes = mem.total_physical_bytes;
			command_line_options.strategy_available_physical_bytes = mem.available_physical_bytes;
		}

		// Pick preset defaults.
		bool	  heuristics_enabled = true;
		const int scale = compute_strategy_scale_from_total_work( command_line_options.strategy_total_work_was_provided ? command_line_options.strategy_total_work : 1 );
		switch ( preset )
		{
		case CommandLineOptions::StrategyPreset::TimeFirst:
			heuristics_enabled = false;
			command_line_options.search_configuration.maximum_search_nodes = saturating_mul_size_t( std::size_t( 25'000'000 ), std::size_t( scale ) );
			command_line_options.search_configuration.enable_state_memoization = true;
			// Cache sizing is auto-computed from available physical memory (keeps a small headroom by default).
			// If physical-memory info is unavailable, fall back to conservative constants.
			command_line_options.cache_max_entries_per_thread = 262'144;
			command_line_options.shared_cache_total_entries = 0;
			command_line_options.shared_cache_shards = 256;
			break;
		case CommandLineOptions::StrategyPreset::Balanced:
			heuristics_enabled = true;
			command_line_options.search_configuration.maximum_search_nodes = saturating_mul_size_t( std::size_t( 5'000'000 ), std::size_t( scale ) );
			command_line_options.search_configuration.enable_state_memoization = true;
			command_line_options.cache_max_entries_per_thread = 131'072;
			command_line_options.shared_cache_total_entries = 0;
			command_line_options.shared_cache_shards = 256;
			break;
		case CommandLineOptions::StrategyPreset::SpaceFirst:
			heuristics_enabled = true;
			command_line_options.search_configuration.maximum_search_nodes = saturating_mul_size_t( std::size_t( 1'000'000 ), std::size_t( scale ) );
			command_line_options.search_configuration.enable_state_memoization = false;
			command_line_options.cache_max_entries_per_thread = 16'384;
			command_line_options.shared_cache_total_entries = 0;
			command_line_options.shared_cache_shards = 256;
			break;
		default:
			// Should not happen; treat as balanced.
			heuristics_enabled = true;
			command_line_options.search_configuration.maximum_search_nodes = saturating_mul_size_t( std::size_t( 5'000'000 ), std::size_t( scale ) );
			command_line_options.search_configuration.enable_state_memoization = true;
			command_line_options.cache_max_entries_per_thread = 131'072;
			command_line_options.shared_cache_total_entries = 0;
			command_line_options.shared_cache_shards = 256;
			break;
		}

		// Strategy mode wants predictable cache sizing (do not auto-tune behind the scenes),
		// because the goal is: user picks a preset, everything else is auto-derived & printed.
		command_line_options.cache_was_provided = true;

		if ( !heuristics_enabled )
		{
			// "Exact" / no heuristic caps: 0 means "enumerate all".
			command_line_options.search_configuration.maximum_constant_subtraction_candidates = 0;
			heuristic_branch_cap( command_line_options.search_configuration ) = 0;
		}
		else
		{
			// Heuristic caps (trade-off time/memory for throughput).
			switch ( preset )
			{
			case CommandLineOptions::StrategyPreset::Balanced:
				command_line_options.search_configuration.maximum_constant_subtraction_candidates = 1024;
				heuristic_branch_cap( command_line_options.search_configuration ) = compute_default_heuristic_branch_cap( preset, resolved_worker_threads, command_line_options.round_count );
				break;
			case CommandLineOptions::StrategyPreset::SpaceFirst:
				command_line_options.search_configuration.maximum_constant_subtraction_candidates = 256;
				heuristic_branch_cap( command_line_options.search_configuration ) = compute_default_heuristic_branch_cap( preset, resolved_worker_threads, command_line_options.round_count );
				break;
			case CommandLineOptions::StrategyPreset::TimeFirst:
				// If user explicitly forced heuristics on in time-first, keep them mild.
				command_line_options.search_configuration.maximum_constant_subtraction_candidates = 4096;
				heuristic_branch_cap( command_line_options.search_configuration ) = 8192;
				break;
			default:
				command_line_options.search_configuration.maximum_constant_subtraction_candidates = 1024;
				heuristic_branch_cap( command_line_options.search_configuration ) = 4096;
				break;
			}
		}

		// Time-first: "purely use memory for speed", keep only a small headroom so the OS remains responsive.
		if ( preset == CommandLineOptions::StrategyPreset::TimeFirst && command_line_options.strategy_available_physical_bytes != 0 )
		{
			const std::uint64_t headroom_bytes = compute_memory_headroom_bytes( command_line_options.strategy_available_physical_bytes, command_line_options.memory_headroom_mib, command_line_options.memory_headroom_mib_was_provided );
			command_line_options.strategy_target_headroom_bytes = headroom_bytes;

			const std::uint64_t budget_bytes = ( command_line_options.strategy_available_physical_bytes > headroom_bytes ) ? ( command_line_options.strategy_available_physical_bytes - headroom_bytes ) : 0;
			command_line_options.strategy_derived_budget_bytes = budget_bytes;

			// Estimate bytes per cache entry. (Conservative; unordered_map node+bucket overhead is large.)
			constexpr std::uint64_t estimated_bytes_per_cache_entry = 256ull;

			// Split budget: most goes to caches, the remainder is left for memoization/other allocations.
			// (No hard cap here: time-first is meant to be "take memory for speed".)
			const std::uint64_t cache_budget_raw = ( budget_bytes * 6ull ) / 10ull;	 // 60% of (avail - headroom)
			const std::uint64_t cache_budget = cache_budget_raw;

			const bool			enable_shared = ( command_line_options.batch_job_count > 0 && command_line_options.strategy_resolved_worker_threads > 1 );
			const std::uint64_t shared_budget = enable_shared ? ( cache_budget * 6ull / 10ull ) : 0;  // 60% of cache budget
			const std::uint64_t thread_budget = cache_budget - shared_budget;

			if ( enable_shared && shared_budget > 0 )
			{
				// We have TWO shared caches (A and B), each with up to N entries.
				const std::uint64_t entries_per_cache_u64 = shared_budget / ( 2ull * estimated_bytes_per_cache_entry );
				command_line_options.shared_cache_total_entries = std::size_t( std::min<std::uint64_t>( entries_per_cache_u64, std::uint64_t( std::numeric_limits<std::size_t>::max() ) ) );
			}
			else
			{
				command_line_options.shared_cache_total_entries = 0;
			}

			// Each thread has TWO thread-local caches (A and B), each with up to per-thread cache entries.
			const std::uint64_t denom = 2ull * std::uint64_t( std::max( 1, command_line_options.strategy_resolved_worker_threads ) ) * estimated_bytes_per_cache_entry;
			const std::uint64_t entries_per_cache_per_thread_u64 = ( denom == 0 ) ? 0 : ( thread_budget / denom );
			std::size_t			per_thread = std::size_t( std::min<std::uint64_t>( entries_per_cache_per_thread_u64, std::uint64_t( std::numeric_limits<std::size_t>::max() ) ) );
			per_thread = std::max<std::size_t>( per_thread, 4096u );
			command_line_options.cache_max_entries_per_thread = per_thread;
		}

		// Auto-tune shared-cache shards when shared cache is enabled and the user didn't override it.
		// (Strategy mode doesn't expose --cache-shards, but we still want shards to scale with threads/cache size.)
		if ( command_line_options.shared_cache_total_entries != 0 && !command_line_options.shared_cache_shards_was_provided )
		{
			command_line_options.shared_cache_shards = compute_auto_shared_cache_shards( command_line_options.shared_cache_total_entries, command_line_options.strategy_resolved_worker_threads );
		}

		// Hard caps for maximum_search_nodes to avoid accidental "infinite" runs.
		{
			const std::size_t cap = ( preset == CommandLineOptions::StrategyPreset::TimeFirst ) ? std::size_t( 250'000'000 ) : ( preset == CommandLineOptions::StrategyPreset::Balanced ) ? std::size_t( 50'000'000 ) : std::size_t( 10'000'000 );
			command_line_options.search_configuration.maximum_search_nodes = std::clamp<std::size_t>( command_line_options.search_configuration.maximum_search_nodes, 1u, cap );
		}

		command_line_options.strategy_preset = preset;
		command_line_options.strategy_heuristics_enabled = heuristics_enabled;
	}

	static bool parse_command_line_detail_mode( int argument_count, char** argument_values, int start_index, CommandLineOptions& command_line_options )
	{
		// Optional positional args: [rounds] [delta_a] [delta_b]
		int	 argument_index = start_index;
		auto is_option = []( const char* s ) -> bool {
			return s && s[ 0 ] == '-';
		};
		if ( argument_index < argument_count && !is_option( argument_values[ argument_index ] ) )
		{
			int round_count = 0;
			if ( !parse_signed_integer_32( argument_values[ argument_index ], round_count ) || round_count <= 0 )
				return false;
			command_line_options.round_count = round_count;
			++argument_index;
		}
		if ( argument_index < argument_count && !is_option( argument_values[ argument_index ] ) )
		{
			if ( !parse_unsigned_integer_32( argument_values[ argument_index ], command_line_options.initial_branch_a_difference ) )
				return false;
			command_line_options.initial_differences_were_provided = true;
			++argument_index;
		}
		if ( command_line_options.initial_differences_were_provided )
		{
			// If delta_a is provided positionally, require delta_b as well (avoid "system decides" partial defaulting).
			if ( argument_index >= argument_count || is_option( argument_values[ argument_index ] ) )
				return false;
			if ( !parse_unsigned_integer_32( argument_values[ argument_index ], command_line_options.initial_branch_b_difference ) )
				return false;
			++argument_index;
		}

		bool		  delta_a_option_was_provided = false;
		bool		  delta_b_option_was_provided = false;
		std::uint32_t delta_a_option_value = 0;
		std::uint32_t delta_b_option_value = 0;

		// Options
		for ( ; argument_index < argument_count; ++argument_index )
		{
			const std::string argument = argument_values[ argument_index ];
			if ( argument == "--selftest" || argument == "--help" || argument == "-h" )
				continue;
			if ( argument == "--mode" )
			{
				if ( argument_index + 1 < argument_count )
					++argument_index;
				continue;
			}  // handled by dispatcher

			if ( ( argument == "--round-count" || argument == "--rounds" ) && argument_index + 1 < argument_count )
			{
				int round_count = 0;
				if ( !parse_signed_integer_32( argument_values[ ++argument_index ], round_count ) || round_count <= 0 )
					return false;
				command_line_options.round_count = round_count;
			}

			else if ( ( argument == "--delta-a" || argument == "--initial-branch-a-difference" ) && argument_index + 1 < argument_count )
			{
				if ( !parse_unsigned_integer_32( argument_values[ ++argument_index ], delta_a_option_value ) )
					return false;
				delta_a_option_was_provided = true;
			}
			else if ( ( argument == "--delta-b" || argument == "--initial-branch-b-difference" ) && argument_index + 1 < argument_count )
			{
				if ( !parse_unsigned_integer_32( argument_values[ ++argument_index ], delta_b_option_value ) )
					return false;
				delta_b_option_was_provided = true;
			}

			else if ( ( argument == "--addition-weight-cap" || argument == "--add" ) && argument_index + 1 < argument_count )
			{
				int value = 0;
				if ( !parse_signed_integer_32( argument_values[ ++argument_index ], value ) )
					return false;
				command_line_options.search_configuration.addition_weight_cap = std::clamp( value, 0, 31 );
			}
			else if ( ( argument == "--constant-subtraction-weight-cap" || argument == "--subtract" ) && argument_index + 1 < argument_count )
			{
				int value = 0;
				if ( !parse_signed_integer_32( argument_values[ ++argument_index ], value ) )
					return false;
				command_line_options.search_configuration.constant_subtraction_weight_cap = std::clamp( value, 0, 32 );
			}
			else if ( ( argument == "--maximum-constant-subtraction-candidates" || argument == "--maxconst" ) && argument_index + 1 < argument_count )
			{
				command_line_options.search_configuration.maximum_constant_subtraction_candidates = std::size_t( std::strtoull( argument_values[ ++argument_index ], nullptr, 10 ) );
			}
			else if ( ( argument == "--heuristic-branch-cap" || argument == "--hcap" ) && argument_index + 1 < argument_count )
			{
				heuristic_branch_cap( command_line_options.search_configuration ) = std::size_t( std::strtoull( argument_values[ ++argument_index ], nullptr, 10 ) );
			}
			else if ( ( argument == "--maximum-search-nodes" || argument == "--maxnodes" ) && argument_index + 1 < argument_count )
			{
				command_line_options.search_configuration.maximum_search_nodes = std::size_t( std::strtoull( argument_values[ ++argument_index ], nullptr, 10 ) );
			}
			else if ( ( argument == "--target-best-weight" || argument == "--target-weight" ) && argument_index + 1 < argument_count )
			{
				int target_best_weight = 0;
				if ( !parse_signed_integer_32( argument_values[ ++argument_index ], target_best_weight ) )
					return false;
				command_line_options.search_configuration.target_best_weight = target_best_weight;
			}

			else if ( ( argument == "--batch-job-count" || argument == "--batch" ) && argument_index + 1 < argument_count )
			{
				command_line_options.batch_job_count = std::size_t( std::strtoull( argument_values[ ++argument_index ], nullptr, 10 ) );
			}
			else if ( argument == "--batch-file" && argument_index + 1 < argument_count )
			{
				command_line_options.batch_job_file = argument_values[ ++argument_index ];
				command_line_options.batch_job_file_was_provided = true;
			}
			else if ( ( argument == "--thread-count" || argument == "--threads" ) && argument_index + 1 < argument_count )
			{
				int thread_count = 0;
				if ( !parse_signed_integer_32( argument_values[ ++argument_index ], thread_count ) || thread_count < 0 )
					return false;
				command_line_options.batch_thread_count = thread_count;
			}
			else if ( argument == "--seed" && argument_index + 1 < argument_count )
			{
				if ( !parse_unsigned_integer_64( argument_values[ ++argument_index ], command_line_options.batch_seed ) )
					return false;
				command_line_options.batch_seed_was_provided = true;
			}
			else if ( ( argument == "--progress-every-jobs" || argument == "--progress" ) && argument_index + 1 < argument_count )
			{
				std::uint64_t job_interval = 0;
				if ( !parse_unsigned_integer_64( argument_values[ ++argument_index ], job_interval ) )
					return false;
				command_line_options.progress_every_jobs = std::size_t( job_interval );
			}
			else if ( ( argument == "--progress-every-seconds" || argument == "--progress-sec" ) && argument_index + 1 < argument_count )
			{
				std::uint64_t seconds = 0;
				if ( !parse_unsigned_integer_64( argument_values[ ++argument_index ], seconds ) )
					return false;
				command_line_options.progress_every_seconds = seconds;
			}
			else if ( argument == "--memory-headroom-mib" && argument_index + 1 < argument_count )
			{
				std::uint64_t mib = 0;
				if ( !parse_unsigned_integer_64( argument_values[ ++argument_index ], mib ) )
					return false;
				command_line_options.memory_headroom_mib = mib;
				command_line_options.memory_headroom_mib_was_provided = true;
			}
			else if ( argument == "--memory-ballast" )
			{
				command_line_options.memory_ballast_enabled = true;
			}
			else if ( ( argument == "--cache-max-entries-per-thread" || argument == "--cache" ) && argument_index + 1 < argument_count )
			{
				std::uint64_t entries = 0;
				if ( !parse_unsigned_integer_64( argument_values[ ++argument_index ], entries ) )
					return false;
				command_line_options.cache_max_entries_per_thread = std::size_t( entries );
				command_line_options.cache_was_provided = true;
			}
			else if ( ( argument == "--shared-cache-total-entries" || argument == "--cache-shared" ) && argument_index + 1 < argument_count )
			{
				std::uint64_t entries = 0;
				if ( !parse_unsigned_integer_64( argument_values[ ++argument_index ], entries ) )
					return false;
				command_line_options.shared_cache_total_entries = std::size_t( entries );
				command_line_options.shared_cache_was_provided = true;
			}
			else if ( ( argument == "--shared-cache-shards" || argument == "--cache-shards" ) && argument_index + 1 < argument_count )
			{
				std::uint64_t shard_count = 0;
				if ( !parse_unsigned_integer_64( argument_values[ ++argument_index ], shard_count ) || shard_count == 0 )
					return false;
				command_line_options.shared_cache_shards = std::size_t( shard_count );
				command_line_options.shared_cache_shards_was_provided = true;
			}
			else if ( argument == "--disable-state-memoization" || argument == "--nomemo" )
			{
				command_line_options.search_configuration.enable_state_memoization = false;
			}
			else if ( argument == "--enable-state-memoization" )
			{
				command_line_options.search_configuration.enable_state_memoization = true;
			}
			else if ( argument == "--enable-verbose-output" || argument == "--verbose" )
			{
				command_line_options.search_configuration.enable_verbose_output = true;
			}
			else if ( argument == "--suffix-weight-lb" && argument_index + 1 < argument_count )
			{
				std::vector<int> suffix_weight_lower_bounds {};
				if ( !parse_suffix_weight_lower_bounds_list( argument_values[ ++argument_index ], suffix_weight_lower_bounds ) )
					return false;
				command_line_options.search_configuration.enable_remaining_round_lower_bound = true;
				command_line_options.search_configuration.remaining_round_min_weight = std::move( suffix_weight_lower_bounds );
			}
			else if ( argument == "--suffix-weight-lb-file" && argument_index + 1 < argument_count )
			{
				std::vector<int> suffix_weight_lower_bounds {};
				if ( !load_suffix_weight_lower_bounds_file( argument_values[ ++argument_index ], suffix_weight_lower_bounds ) )
					return false;
				command_line_options.search_configuration.enable_remaining_round_lower_bound = true;
				command_line_options.search_configuration.remaining_round_min_weight = std::move( suffix_weight_lower_bounds );
			}
			else
			{
				// Unknown option
				return false;
			}
		}

		// If user provided --delta-a/--delta-b, require both, and override positional.
		if ( delta_a_option_was_provided || delta_b_option_was_provided )
		{
			if ( !( delta_a_option_was_provided && delta_b_option_was_provided ) )
				return false;
			command_line_options.initial_branch_a_difference = delta_a_option_value;
			command_line_options.initial_branch_b_difference = delta_b_option_value;
			command_line_options.initial_differences_were_provided = true;
		}

		command_line_options.search_configuration.addition_weight_cap = std::clamp( command_line_options.search_configuration.addition_weight_cap, 0, 31 );
		command_line_options.search_configuration.constant_subtraction_weight_cap = std::clamp( command_line_options.search_configuration.constant_subtraction_weight_cap, 0, 32 );
		// maximum_constant_subtraction_candidates: 0 means exact/unlimited
		// heuristic_branch_cap: 0 means exact/unlimited
		// maximum_search_nodes: 0 means unlimited
		if ( command_line_options.round_count <= 0 )
			command_line_options.round_count = 1;

		const bool batch_enabled = ( command_line_options.batch_job_count > 0 ) || command_line_options.batch_job_file_was_provided;

		// Single-run contract:
		// - If user provided (delta_a, delta_b): use as-is.
		// - Otherwise: must provide --seed, then generate a non-zero pair using MT19937_64.
		if ( !batch_enabled )
		{
			if ( !command_line_options.initial_differences_were_provided )
			{
				if ( !command_line_options.batch_seed_was_provided )
					return false;  // no (delta_a, delta_b) and no seed -> error
				std::mt19937_64 random_number_generator( command_line_options.batch_seed );
				std::uint32_t	generated_delta_a = 0;
				std::uint32_t	generated_delta_b = 0;
				do
				{
					generated_delta_a = static_cast<std::uint32_t>( random_number_generator() );
					generated_delta_b = static_cast<std::uint32_t>( random_number_generator() );
				} while ( generated_delta_a == 0u && generated_delta_b == 0u );
				command_line_options.initial_branch_a_difference = generated_delta_a;
				command_line_options.initial_branch_b_difference = generated_delta_b;
				command_line_options.initial_differences_were_generated = true;
			}
		}
		else
		{
			// Batch contract:
			// - If using random-number-generator jobs (--batch-job-count): require explicit --seed.
			// - If using file jobs (--batch-file): seed is not required.
			if ( command_line_options.batch_job_count > 0 && !command_line_options.batch_job_file_was_provided && !command_line_options.batch_seed_was_provided )
				return false;
		}
		return true;
	}

	static bool parse_command_line_strategy_mode( int argument_count, char** argument_values, int start_index, CommandLineOptions& command_line_options )
	{
		CommandLineOptions::StrategyPreset preset = CommandLineOptions::StrategyPreset::Balanced;
		bool							   preset_was_provided = false;
		bool							   maximum_search_nodes_was_provided = false;
		std::size_t						   maximum_search_nodes_override = 0;

		// Allow a first positional token to be the preset (time/balanced/space).
		auto is_option = []( const char* s ) -> bool {
			return s && s[ 0 ] == '-';
		};
		if ( start_index < argument_count && !is_option( argument_values[ start_index ] ) )
		{
			if ( !parse_strategy_preset( argument_values[ start_index ], preset ) )
				return false;
			preset_was_provided = true;
			++start_index;
		}

		// Parse strategy-only command_line_options.
		bool		  delta_a_option_was_provided = false;
		bool		  delta_b_option_was_provided = false;
		std::uint32_t delta_a_option_value = 0;
		std::uint32_t delta_b_option_value = 0;

		for ( int argument_index = start_index; argument_index < argument_count; ++argument_index )
		{
			const std::string argument = argument_values[ argument_index ];
			if ( argument == "--selftest" || argument == "--help" || argument == "-h" )
				continue;
			if ( argument == "--mode" )
			{
				if ( argument_index + 1 < argument_count )
					++argument_index;
				continue;
			}

			if ( ( argument == "--preset" || argument == "--strategy" ) && argument_index + 1 < argument_count )
			{
				if ( !parse_strategy_preset( argument_values[ ++argument_index ], preset ) )
					return false;
				preset_was_provided = true;
			}

			else if ( ( argument == "--round-count" || argument == "--rounds" ) && argument_index + 1 < argument_count )
			{
				int round_count = 0;
				if ( !parse_signed_integer_32( argument_values[ ++argument_index ], round_count ) || round_count <= 0 )
					return false;
				command_line_options.round_count = round_count;
			}

			else if ( ( argument == "--delta-a" || argument == "--initial-branch-a-difference" ) && argument_index + 1 < argument_count )
			{
				if ( !parse_unsigned_integer_32( argument_values[ ++argument_index ], delta_a_option_value ) )
					return false;
				delta_a_option_was_provided = true;
			}
			else if ( ( argument == "--delta-b" || argument == "--initial-branch-b-difference" ) && argument_index + 1 < argument_count )
			{
				if ( !parse_unsigned_integer_32( argument_values[ ++argument_index ], delta_b_option_value ) )
					return false;
				delta_b_option_was_provided = true;
			}

			else if ( ( argument == "--batch-job-count" || argument == "--batch" ) && argument_index + 1 < argument_count )
			{
				// Strategy-only convenience:
				// - "--batch-job-count N" is explicit.
				// - "--batch N" is accepted (backward-compatible habit).
				// - "--batch" without a value means "enable batch", and total-work decides the count.
				//
				// We treat "--batch" as a mode toggle when the next token looks like another option.
				const bool next_is_option = ( argument_index + 1 < argument_count ) && argument_values[ argument_index + 1 ] && argument_values[ argument_index + 1 ][ 0 ] == '-';
				if ( argument == "--batch" && next_is_option )
				{
					command_line_options.strategy_batch_was_requested = true;
				}
				else
				{
					command_line_options.strategy_batch_was_requested = true;
					command_line_options.batch_job_count = std::size_t( std::strtoull( argument_values[ ++argument_index ], nullptr, 10 ) );
				}
			}
			else if ( argument == "--batch" )
			{
				// "--batch" at end of argument_values
				command_line_options.strategy_batch_was_requested = true;
			}
			else if ( argument == "--batch-file" && argument_index + 1 < argument_count )
			{
				command_line_options.batch_job_file = argument_values[ ++argument_index ];
				command_line_options.batch_job_file_was_provided = true;
				command_line_options.strategy_batch_was_requested = true;
			}
			else if ( ( argument == "--thread-count" || argument == "--threads" ) && argument_index + 1 < argument_count )
			{
				int thread_count = 0;
				if ( !parse_signed_integer_32( argument_values[ ++argument_index ], thread_count ) || thread_count < 0 )
					return false;
				command_line_options.batch_thread_count = thread_count;
				// If user specifies threads in strategy mode, they almost certainly mean batch.
				if ( thread_count != 0 )
					command_line_options.strategy_batch_was_requested = true;
			}
			else if ( ( argument == "--total-work" || argument == "--total" ) && argument_index + 1 < argument_count )
			{
				std::uint64_t total_work = 0;
				if ( !parse_unsigned_integer_64( argument_values[ ++argument_index ], total_work ) || total_work == 0 )
					return false;
				command_line_options.strategy_total_work = total_work;
				command_line_options.strategy_total_work_was_provided = true;
			}
			else if ( ( argument == "--maximum-search-nodes" || argument == "--maxnodes" ) && argument_index + 1 < argument_count )
			{
				maximum_search_nodes_override = std::size_t( std::strtoull( argument_values[ ++argument_index ], nullptr, 10 ) );
				maximum_search_nodes_was_provided = true;
			}
			else if ( ( argument == "--target-best-weight" || argument == "--target-weight" ) && argument_index + 1 < argument_count )
			{
				int target_best_weight = 0;
				if ( !parse_signed_integer_32( argument_values[ ++argument_index ], target_best_weight ) )
					return false;
				command_line_options.search_configuration.target_best_weight = target_best_weight;
			}
			else if ( argument == "--seed" && argument_index + 1 < argument_count )
			{
				if ( !parse_unsigned_integer_64( argument_values[ ++argument_index ], command_line_options.batch_seed ) )
					return false;
				command_line_options.batch_seed_was_provided = true;
			}
			else if ( ( argument == "--progress-every-jobs" || argument == "--progress" ) && argument_index + 1 < argument_count )
			{
				std::uint64_t job_interval = 0;
				if ( !parse_unsigned_integer_64( argument_values[ ++argument_index ], job_interval ) )
					return false;
				command_line_options.progress_every_jobs = std::size_t( job_interval );
			}
			else if ( ( argument == "--progress-every-seconds" || argument == "--progress-sec" ) && argument_index + 1 < argument_count )
			{
				std::uint64_t seconds = 0;
				if ( !parse_unsigned_integer_64( argument_values[ ++argument_index ], seconds ) )
					return false;
				command_line_options.progress_every_seconds = seconds;
			}
			else if ( argument == "--memory-headroom-mib" && argument_index + 1 < argument_count )
			{
				std::uint64_t mib = 0;
				if ( !parse_unsigned_integer_64( argument_values[ ++argument_index ], mib ) )
					return false;
				command_line_options.memory_headroom_mib = mib;
				command_line_options.memory_headroom_mib_was_provided = true;
			}
			else if ( argument == "--memory-ballast" )
			{
				command_line_options.memory_ballast_enabled = true;
			}
			else if ( argument == "--suffix-weight-lb" && argument_index + 1 < argument_count )
			{
				std::vector<int> suffix_weight_lower_bounds {};
				if ( !parse_suffix_weight_lower_bounds_list( argument_values[ ++argument_index ], suffix_weight_lower_bounds ) )
					return false;
				command_line_options.search_configuration.enable_remaining_round_lower_bound = true;
				command_line_options.search_configuration.remaining_round_min_weight = std::move( suffix_weight_lower_bounds );
			}
			else if ( argument == "--suffix-weight-lb-file" && argument_index + 1 < argument_count )
			{
				std::vector<int> suffix_weight_lower_bounds {};
				if ( !load_suffix_weight_lower_bounds_file( argument_values[ ++argument_index ], suffix_weight_lower_bounds ) )
					return false;
				command_line_options.search_configuration.enable_remaining_round_lower_bound = true;
				command_line_options.search_configuration.remaining_round_min_weight = std::move( suffix_weight_lower_bounds );
			}
			else
			{
				// Strategy mode intentionally exposes fewer knobs.
				return false;
			}
		}

		// total-work decides BOTH batch-job-count and maximum_search_nodes:
		// - maximum_search_nodes is scaled regardless of single/batch.
		// - batch-job-count is derived from total-work ONLY when the user explicitly requested batch mode.
		if ( command_line_options.strategy_total_work_was_provided && command_line_options.strategy_batch_was_requested && command_line_options.batch_job_count == 0 )
		{
			command_line_options.batch_job_count = std::size_t( std::min<std::uint64_t>( command_line_options.strategy_total_work, std::uint64_t( std::numeric_limits<std::size_t>::max() ) ) );
		}
		// If batch was requested but we still have no job count and no file, that's an error.
		if ( command_line_options.strategy_batch_was_requested && command_line_options.batch_job_count == 0 && !command_line_options.batch_job_file_was_provided )
			return false;

		// Apply the preset (touches only search/caching knobs).
		( void )preset_was_provided;
		{
			const int resolved_threads = resolve_worker_thread_count_for_command_line_interface( command_line_options.batch_job_count, command_line_options.batch_job_file_was_provided, command_line_options.batch_thread_count );
			apply_strategy_defaults( command_line_options, preset, resolved_threads );
		}
		if ( maximum_search_nodes_was_provided )
		{
			// Allow 0=unlimited.
			command_line_options.search_configuration.maximum_search_nodes = maximum_search_nodes_override;
		}

		// If user provided --delta-a/--delta-b, require both.
		if ( delta_a_option_was_provided || delta_b_option_was_provided )
		{
			if ( !( delta_a_option_was_provided && delta_b_option_was_provided ) )
				return false;
			command_line_options.initial_branch_a_difference = delta_a_option_value;
			command_line_options.initial_branch_b_difference = delta_b_option_value;
			command_line_options.initial_differences_were_provided = true;
		}

		// Selftest/help should be runnable without requiring (delta_a, delta_b) or --seed.
		if ( command_line_options.selftest || command_line_options.show_help )
			return true;

		const bool batch_enabled = ( command_line_options.batch_job_count > 0 ) || command_line_options.batch_job_file_was_provided;

		// Single-run only: decide how to obtain the initial input differences (same contract as detail).
		if ( !batch_enabled )
		{
			if ( !command_line_options.initial_differences_were_provided )
			{
				if ( !command_line_options.batch_seed_was_provided )
					return false;  // no (delta_a, delta_b) and no seed -> error
				std::mt19937_64 random_number_generator( command_line_options.batch_seed );
				std::uint32_t	generated_delta_a = 0;
				std::uint32_t	generated_delta_b = 0;
				do
				{
					generated_delta_a = static_cast<std::uint32_t>( random_number_generator() );
					generated_delta_b = static_cast<std::uint32_t>( random_number_generator() );
				} while ( generated_delta_a == 0u && generated_delta_b == 0u );
				command_line_options.initial_branch_a_difference = generated_delta_a;
				command_line_options.initial_branch_b_difference = generated_delta_b;
				command_line_options.initial_differences_were_generated = true;
			}
		}
		else
		{
			// Batch random-number-generator jobs require a seed; batch file does not.
			if ( command_line_options.batch_job_count > 0 && !command_line_options.batch_job_file_was_provided && !command_line_options.batch_seed_was_provided )
				return false;
		}
		return true;
	}

	static bool parse_command_line( int argument_count, char** argument_values, CommandLineOptions& command_line_options )
	{
		// Fast scan for help/selftest first (so we can exit early with help even on invalid args).
		for ( int i = 1; i < argument_count; ++i )
		{
			const std::string a = argument_values[ i ];
			if ( a == "--selftest" )
				command_line_options.selftest = true;
			if ( a == "--help" || a == "-h" )
				command_line_options.show_help = true;
		}

		// Selftest/help should be runnable without requiring (delta_a, delta_b) or --seed.
		if ( command_line_options.selftest || command_line_options.show_help )
			return true;

		// Dispatcher: decide which frontend to use.
		CommandLineOptions::FrontendMode frontend = CommandLineOptions::FrontendMode::Detail;
		int								 start_index = 1;

		// Subcommand form: exe strategy|detail|auto ...
		if ( argument_count >= 2 )
		{
			const std::string sub = to_lowercase_ascii( std::string( argument_values[ 1 ] ) );
			if ( sub == "strategy" )
			{
				frontend = CommandLineOptions::FrontendMode::Strategy;
				start_index = 2;
			}
			else if ( sub == "detail" )
			{
				frontend = CommandLineOptions::FrontendMode::Detail;
				start_index = 2;
			}
			else if ( sub == "auto" )
			{
				frontend = CommandLineOptions::FrontendMode::Auto;
				start_index = 2;
			}
		}

		// Flag form: --mode strategy|detail|auto (if present, overrides default detail when no subcommand is used).
		if ( start_index == 1 )
		{
			for ( int i = 1; i + 1 < argument_count; ++i )
			{
				const std::string a = argument_values[ i ];
				if ( a != "--mode" )
					continue;
				const std::string m = to_lowercase_ascii( std::string( argument_values[ i + 1 ] ) );
				if ( m == "strategy" )
					frontend = CommandLineOptions::FrontendMode::Strategy;
				else if ( m == "detail" )
					frontend = CommandLineOptions::FrontendMode::Detail;
				else if ( m == "auto" )
					frontend = CommandLineOptions::FrontendMode::Auto;
			}
		}

		command_line_options.frontend_mode = frontend;

		switch ( frontend )
		{
		case CommandLineOptions::FrontendMode::Strategy:
			return parse_command_line_strategy_mode( argument_count, argument_values, start_index, command_line_options );
		case CommandLineOptions::FrontendMode::Detail:
			return parse_command_line_detail_mode( argument_count, argument_values, start_index, command_line_options );
		case CommandLineOptions::FrontendMode::Auto:
			return parse_command_line_auto_mode( argument_count, argument_values, start_index, command_line_options );
		default:
			return parse_command_line_detail_mode( argument_count, argument_values, start_index, command_line_options );
		}
	}

	static void print_result( const BestSearchResult& result );

	static inline double weight_to_abs_correlation( double weight )
	{
		if ( !std::isfinite( weight ) )
			return 0.0;
		return std::pow( 2.0, -weight );
	}

	static int run_auto_mode( const CommandLineOptions& command_line_options )
	{
		// Auto mode is single-run only (no batch).
		if ( command_line_options.batch_job_count > 0 || command_line_options.batch_job_file_was_provided )
		{
			std::cerr << "[Auto] ERROR: auto mode does not support batch mode.\n";
			return 1;
		}
		if ( !command_line_options.initial_differences_were_provided )
		{
			std::cerr << "[Auto] ERROR: auto mode requires explicit --delta-a/--delta-b (no --seed fallback).\n";
			return 1;
		}

		std::cout << "[Auto] round_count=" << command_line_options.round_count << "\n";
		print_word32_hex( "[Auto] start_delta_a=", command_line_options.initial_branch_a_difference );
		std::cout << "\n";
		print_word32_hex( "[Auto] start_delta_b=", command_line_options.initial_branch_b_difference );
		std::cout << "\n\n";

		// ---------------------------------------------------------------------
		// Stage 1: "breadth" scan (small resources, many candidates) to find sweet-spot initial (delta_a, delta_b).
		// ---------------------------------------------------------------------
		const unsigned hardware_thread_concurrency = std::thread::hardware_concurrency();
		const int	   breadth_threads = ( command_line_options.auto_breadth_thread_count > 0 ) ? command_line_options.auto_breadth_thread_count : int( ( hardware_thread_concurrency == 0 ) ? 1 : hardware_thread_concurrency );

		// Configure caches (auto mode default: eat as much available physical memory as possible, keep small headroom).
		// This is intentionally more aggressive than batch defaults.
		const SystemMemoryInfo mem = query_system_memory_info();
		const std::uint64_t	   avail_bytes = mem.available_physical_bytes;
		const std::uint64_t	   auto_headroom_bytes = compute_memory_headroom_bytes( avail_bytes, command_line_options.memory_headroom_mib, command_line_options.memory_headroom_mib_was_provided );

		// Configure PMR budget for this run (hard cap + graceful degradation on OOM in hot containers).
		pmr_configure_for_run( avail_bytes, auto_headroom_bytes );
		memory_governor_enable_for_run( auto_headroom_bytes );
		memory_governor_set_poll_fn( &governor_poll_system_memory_once );

		MemoryBallast memory_ballast( auto_headroom_bytes );
		if ( command_line_options.memory_ballast_enabled && auto_headroom_bytes != 0 )
		{
			IosStateGuard g( std::cout );
			std::cout << "[Auto] memory_ballast=on  headroom_gibibytes=" << std::fixed << std::setprecision( 2 ) << bytes_to_gibibytes( auto_headroom_bytes ) << "\n";
			memory_ballast.start();
		}

		auto compute_aggressive_cache_budget = [ & ]( int thread_count, std::size_t& out_per_thread, std::size_t& out_shared_total ) {
			// Conservative estimate: unordered_map node+bucket overhead is large.
			constexpr std::uint64_t estimated_bytes_per_cache_entry = 256ull;
			if ( avail_bytes == 0 )
			{
				// Unknown memory info: fall back to old conservative defaults.
				out_per_thread = std::size_t( 262144 );
				out_shared_total = 0;
				return;
			}

			const std::uint64_t headroom_bytes = compute_memory_headroom_bytes( avail_bytes, command_line_options.memory_headroom_mib, command_line_options.memory_headroom_mib_was_provided );

			const std::uint64_t budget_bytes = ( avail_bytes > headroom_bytes ) ? ( avail_bytes - headroom_bytes ) : 0;
			const std::uint64_t cache_budget = ( budget_bytes * 6ull ) / 10ull;	 // 60% of (available - headroom)

			const bool			enable_shared = ( thread_count > 1 );
			const std::uint64_t shared_budget = enable_shared ? ( cache_budget * 6ull / 10ull ) : 0;  // 60% of cache budget
			const std::uint64_t thread_budget = cache_budget - shared_budget;

			if ( enable_shared && shared_budget > 0 )
			{
				const std::uint64_t entries_per_cache_u64 = shared_budget / ( 2ull * estimated_bytes_per_cache_entry );	 // 2 shared caches (A,B)
				out_shared_total = std::size_t( std::min<std::uint64_t>( entries_per_cache_u64, std::uint64_t( std::numeric_limits<std::size_t>::max() ) ) );
			}
			else
			{
				out_shared_total = 0;
			}

			// Each thread has TWO thread-local caches (A and B), each with up to per-thread entries.
			const std::uint64_t denom = 2ull * std::uint64_t( std::max( 1, thread_count ) ) * estimated_bytes_per_cache_entry;
			const std::uint64_t entries_per_cache_per_thread_u64 = ( denom == 0 ) ? 0 : ( thread_budget / denom );
			std::size_t			per_thread = std::size_t( std::min<std::uint64_t>( entries_per_cache_per_thread_u64, std::uint64_t( std::numeric_limits<std::size_t>::max() ) ) );
			per_thread = std::max<std::size_t>( per_thread, 4096u );
			out_per_thread = per_thread;
		};

		std::size_t cache_per_thread = command_line_options.cache_max_entries_per_thread;
		bool		cache_is_auto = false;
		if ( !command_line_options.cache_was_provided )
		{
			std::size_t computed_shared_total = 0;
			compute_aggressive_cache_budget( breadth_threads, cache_per_thread, computed_shared_total );
			cache_is_auto = true;
		}
		g_injection_cache_max_entries_per_thread = cache_per_thread;

		// Shared cache: auto-enable in auto mode unless user explicitly disabled/overrode it.
		std::size_t shared_total_entries = command_line_options.shared_cache_total_entries;
		bool		shared_total_is_auto = false;
		if ( !command_line_options.shared_cache_was_provided )
		{
			std::size_t computed_per_thread = cache_per_thread;
			std::size_t computed_shared_total = 0;
			compute_aggressive_cache_budget( breadth_threads, computed_per_thread, computed_shared_total );
			shared_total_entries = computed_shared_total;
			shared_total_is_auto = true;
		}

		std::size_t shared_shards = command_line_options.shared_cache_shards;
		bool		shared_shards_is_auto = false;
		if ( shared_total_entries != 0 && !command_line_options.shared_cache_shards_was_provided )
		{
			shared_shards = compute_auto_shared_cache_shards( shared_total_entries, breadth_threads );
			shared_shards_is_auto = true;
		}
		g_shared_injection_cache_branch_a.configure( shared_total_entries, shared_shards );
		g_shared_injection_cache_branch_b.configure( shared_total_entries, shared_shards );

		struct AutoCandidate
		{
			std::uint32_t							 start_delta_a = 0;
			std::uint32_t							 start_delta_b = 0;
			bool									 found = false;
			int										 entry_round1_weight = INFINITE_WEIGHT;
			int										 best_weight = INFINITE_WEIGHT;
			std::uint64_t							 nodes = 0;
			bool									 hit_maximum_search_nodes_limit = false;
			std::uint32_t							 entry_delta_a = 0;
			std::uint32_t							 entry_delta_b = 0;
			std::vector<DifferentialTrailStepRecord> trail;	 // kept only for top-K
		};

		auto candidate_key_better = [ & ]( const AutoCandidate& a, const AutoCandidate& b ) -> bool {
			// Primary: total weight (full trail); Secondary: entry (round1) weight.
			if ( a.best_weight != b.best_weight )
				return a.best_weight < b.best_weight;
			if ( a.entry_round1_weight != b.entry_round1_weight )
				return a.entry_round1_weight < b.entry_round1_weight;
			return a.nodes < b.nodes;
		};

		// Candidate generator (structured neighborhood around the user-provided start diff).
		const std::uint64_t derived_seed = ( std::uint64_t( command_line_options.initial_branch_a_difference ) << 32 ) ^ std::uint64_t( command_line_options.initial_branch_b_difference ) ^ 0x9e3779b97f4a7c15ull;
		const std::uint64_t seed = command_line_options.auto_breadth_seed_was_provided ? command_line_options.auto_breadth_seed : derived_seed;
		std::mt19937_64		rng( seed );

		struct Job
		{
			std::uint32_t delta_a;
			std::uint32_t delta_b;
		};
		std::vector<Job> jobs;
		jobs.reserve( std::max<std::size_t>( 1, command_line_options.auto_breadth_candidate_count ) );
		std::unordered_set<std::uint64_t> seen;
		seen.reserve( std::max<std::size_t>( 64, command_line_options.auto_breadth_candidate_count * 2 ) );

		const std::uint32_t base_delta_a = command_line_options.initial_branch_a_difference;
		const std::uint32_t base_delta_b = command_line_options.initial_branch_b_difference;

		auto try_add_job = [ & ]( std::uint32_t delta_a, std::uint32_t delta_b ) {
			if ( delta_a == 0u && delta_b == 0u )
				return;
			const std::uint64_t key = pack_two_word32_differences( delta_a, delta_b );
			if ( !seen.insert( key ).second )
				return;
			if ( jobs.size() >= command_line_options.auto_breadth_candidate_count )
				return;
			jobs.push_back( { delta_a, delta_b } );
		};

		// Always include the user-provided start diff first.
		try_add_job( base_delta_a, base_delta_b );

		// Deterministic "close neighbors": single-bit flips in either lane.
		for ( int bit = 0; bit < 32 && jobs.size() < command_line_options.auto_breadth_candidate_count; ++bit )
		{
			const std::uint32_t m = ( 1u << bit );
			try_add_job( base_delta_a ^ m, base_delta_b );
			try_add_job( base_delta_a, base_delta_b ^ m );
			try_add_job( base_delta_a ^ m, base_delta_b ^ m );
		}

		// Byte-level toggles (structured, helps explore ARX-relevant diffusion).
		for ( int byte = 0; byte < 4 && jobs.size() < command_line_options.auto_breadth_candidate_count; ++byte )
		{
			const std::uint32_t m = ( 0xFFu << ( 8 * byte ) );
			try_add_job( base_delta_a ^ m, base_delta_b );
			try_add_job( base_delta_a, base_delta_b ^ m );
		}

		// Nibble-level toggles (a bit denser than single-bit).
		for ( int nib = 0; nib < 8 && jobs.size() < command_line_options.auto_breadth_candidate_count; ++nib )
		{
			const std::uint32_t m = ( 0xFu << ( 4 * nib ) );
			try_add_job( base_delta_a ^ m, base_delta_b );
			try_add_job( base_delta_a, base_delta_b ^ m );
		}

		// Randomized neighborhood fill: apply up to F random bit flips, biased toward small flip counts.
		const int max_flips = std::clamp( command_line_options.auto_breadth_max_bit_flips, 1, 32 );
		while ( jobs.size() < command_line_options.auto_breadth_candidate_count )
		{
			// Geometric-ish distribution: 1,2,3,... with rapidly decreasing probability.
			int flips = 1;
			while ( flips < max_flips && ( rng() & 3ull ) == 0ull )
				++flips;  // ~25% chance to increase each step

			std::uint32_t m_da = 0u;
			std::uint32_t m_db = 0u;
			for ( int k = 0; k < flips; ++k )
			{
				const int			lane = int( rng() & 1ull );	 // 0 -> delta_a, 1 -> delta_b
				const int			bit = int( rng() % 32ull );
				const std::uint32_t m = ( 1u << bit );
				if ( lane == 0 )
					m_da ^= m;
				else
					m_db ^= m;
			}
			try_add_job( base_delta_a ^ m_da, base_delta_b ^ m_db );
		}

		DifferentialBestSearchConfiguration breadth_configuration = command_line_options.search_configuration;
		breadth_configuration.maximum_constant_subtraction_candidates = command_line_options.auto_breadth_maximum_constant_subtraction_candidates;
		heuristic_branch_cap( breadth_configuration ) = command_line_options.auto_breadth_heuristic_branch_cap;
		breadth_configuration.maximum_search_nodes = std::max<std::size_t>( 1, command_line_options.auto_breadth_maximum_search_nodes );

		std::cout << "[Auto][Breadth] jobs=" << jobs.size() << "  threads=" << breadth_threads << "  seed=0x" << std::hex << seed << std::dec << ( command_line_options.auto_breadth_seed_was_provided ? "" : " (derived)" ) << "\n";
		std::cout << "  per_candidate: maximum_search_nodes=" << breadth_configuration.maximum_search_nodes << "  maximum_constant_subtraction_candidates=" << breadth_configuration.maximum_constant_subtraction_candidates << "  heuristic_branch_cap=" << heuristic_branch_cap( breadth_configuration ) << "  maximum_bit_flips=" << command_line_options.auto_breadth_max_bit_flips << "  state_memoization=" << ( breadth_configuration.enable_state_memoization ? "on" : "off" ) << "\n";
		if ( avail_bytes != 0 )
		{
			IosStateGuard g( std::cout );
			std::cout << "  system_memory: available_physical_gibibytes=" << std::fixed << std::setprecision( 2 ) << bytes_to_gibibytes( avail_bytes ) << "\n";
		}
		std::cout << "  cache_entries_per_thread=" << cache_per_thread << ( cache_is_auto ? " (auto)" : "" ) << "\n";
		std::cout << "  transition_shared_cache_total_entries=" << shared_total_entries << " shards=" << round_up_power_of_two( std::max<std::size_t>( 1, shared_shards ) ) << ( shared_shards_is_auto ? " (auto)" : "" ) << ( shared_total_entries ? "" : " (off)" ) << ( shared_total_is_auto ? " (auto)" : "" ) << "\n\n";

		if ( command_line_options.auto_print_breadth_candidates )
		{
			std::cout << "[Auto][Breadth] candidates:\n";
			for ( std::size_t i = 0; i < jobs.size(); ++i )
			{
				std::cout << "  #" << ( i + 1 ) << " ";
				print_word32_hex( "delta_a=", jobs[ i ].delta_a );
				std::cout << " ";
				print_word32_hex( "delta_b=", jobs[ i ].delta_b );
				std::cout << "\n";
			}
			std::cout << "\n";
		}

		const std::uint64_t breadth_progress_sec = ( command_line_options.progress_every_seconds == 0 ) ? 1 : command_line_options.progress_every_seconds;

		std::atomic<std::size_t>   next_index { 0 };
		std::atomic<std::size_t>   completed { 0 };
		std::atomic<std::uint64_t> total_nodes { 0 };

		const int breadth_threads_clamped = std::max( 1, breadth_threads );
		// Track "currently running" job id per worker thread so auto mode can print what's being worked on.
		// (0 means idle; job ids are 1-based.)
		std::vector<std::atomic<std::size_t>> active_job_id_by_thread( static_cast<std::size_t>( breadth_threads_clamped ) );
		for ( auto& x : active_job_id_by_thread )
			x.store( 0, std::memory_order_relaxed );

		std::mutex				   top_mutex;
		std::vector<AutoCandidate> top_candidates;
		top_candidates.reserve( std::max<std::size_t>( 1, command_line_options.auto_breadth_top_k ) );

		auto try_update_top_candidates = [ & ]( AutoCandidate&& c ) {
			if ( !c.found )
				return;
			std::scoped_lock lk( top_mutex );
			if ( top_candidates.size() < command_line_options.auto_breadth_top_k )
			{
				top_candidates.push_back( std::move( c ) );
			}
			else
			{
				// Find worst candidate in top_candidates.
				std::size_t worst = 0;
				for ( std::size_t i = 1; i < top_candidates.size(); ++i )
				{
					if ( candidate_key_better( top_candidates[ worst ], top_candidates[ i ] ) )
						continue;
					worst = i;
				}
				if ( candidate_key_better( c, top_candidates[ worst ] ) )
				{
					top_candidates[ worst ] = std::move( c );
				}
				else
				{
					return;
				}
			}
			// Keep top_candidates sorted for stable printing.
			std::sort( top_candidates.begin(), top_candidates.end(), [ & ]( const AutoCandidate& a, const AutoCandidate& b ) { return candidate_key_better( a, b ); } );
		};

		auto worker = [ & ]( int thread_id ) {
			for ( ;; )
			{
				const std::size_t job_index = next_index.fetch_add( 1, std::memory_order_relaxed );
				if ( job_index >= jobs.size() )
					break;
				const Job		   job = jobs[ job_index ];
				const std::size_t job_id_one_based = job_index + 1;
				active_job_id_by_thread[ std::size_t( thread_id ) ].store( job_id_one_based, std::memory_order_relaxed );

				BestSearchResult result {};
				try
				{
					result = run_matsui_best_search_with_injection_internal( command_line_options.round_count, job.delta_a, job.delta_b, breadth_configuration, false, 0 );
				}
				catch ( const std::bad_alloc& )
				{
					// Any unexpected OOM outside the "best-effort" caches: mark job as failed and continue.
					pmr_report_oom_once( "auto_breadth.run" );
					result.found = false;
					result.best_weight = INFINITE_WEIGHT;
					result.nodes_visited = 0;
					result.hit_maximum_search_nodes = false;
					result.hit_time_limit = false;
				}
				total_nodes.fetch_add( result.nodes_visited, std::memory_order_relaxed );

				AutoCandidate c {};
				c.start_delta_a = job.delta_a;
				c.start_delta_b = job.delta_b;
				c.nodes = result.nodes_visited;
				c.hit_maximum_search_nodes_limit = result.hit_maximum_search_nodes;
				c.found = result.found && !result.best_trail.empty();
				if ( c.found )
				{
					c.best_weight = result.best_weight;
					c.entry_round1_weight = result.best_trail.front().round_weight;
					c.entry_delta_a = result.best_trail.front().output_branch_a_difference;
					c.entry_delta_b = result.best_trail.front().output_branch_b_difference;
					// Keep the trail only if it has a chance to make top-K.
					c.trail = std::move( result.best_trail );
					try_update_top_candidates( std::move( c ) );
				}
				completed.fetch_add( 1, std::memory_order_relaxed );
			}
			active_job_id_by_thread[ std::size_t( thread_id ) ].store( 0, std::memory_order_relaxed );
		};

		auto progress_monitor = [ & ]() {
			const std::size_t total = jobs.size();
			if ( total == 0 )
				return;
			if ( breadth_progress_sec == 0 )
				return;
			std::size_t last_done = 0;
			auto		start_time = std::chrono::steady_clock::now();
			auto		last_time = start_time;
			for ( ;; )
			{
				const std::size_t done = completed.load( std::memory_order_relaxed );
				const auto		  now = std::chrono::steady_clock::now();
				memory_governor_poll_if_needed( now );
				const double since_last = std::chrono::duration<double>( now - last_time ).count();
				if ( since_last >= double( breadth_progress_sec ) || done == total )
				{
					const double	  elapsed = std::chrono::duration<double>( now - start_time ).count();
					const double	  window = std::max( 1e-9, since_last );
					const std::size_t delta = ( done >= last_done ) ? ( done - last_done ) : 0;
					const double	  rate = double( delta ) / window;

					AutoCandidate best_snapshot {};
					bool		  has_best = false;
					{
						std::scoped_lock lk( top_mutex );
						if ( !top_candidates.empty() )
						{
							best_snapshot = top_candidates.front();
							has_best = true;
						}
					}

					// Snapshot active jobs (what breadth is currently working on).
					struct ActiveJob
					{
						std::size_t  thread_id = 0;
						std::size_t  job_id_one_based = 0;
						std::uint32_t delta_a = 0;
						std::uint32_t delta_b = 0;
					};
					std::vector<ActiveJob> active;
					active.reserve( active_job_id_by_thread.size() );
					for ( std::size_t i = 0; i < active_job_id_by_thread.size(); ++i )
					{
						const std::size_t id = active_job_id_by_thread[ i ].load( std::memory_order_relaxed );
						if ( id == 0 )
							continue;
						const std::size_t job_index = id - 1;
						if ( job_index >= jobs.size() )
							continue;
						const Job& j = jobs[ job_index ];
						active.push_back( ActiveJob { i, id, j.delta_a, j.delta_b } );
					}

					IosStateGuard g( std::cout );
					std::cout << "[Auto][Breadth] progress " << done << "/" << total << " (" << std::fixed << std::setprecision( 2 ) << ( 100.0 * double( done ) / double( total ) ) << "%)"
							  << "  jobs_per_sec=" << std::setprecision( 2 ) << rate << "  elapsed_sec=" << std::setprecision( 2 ) << elapsed;
					if ( has_best )
					{
						std::cout << "  best_entry_w=" << best_snapshot.entry_round1_weight << "  best_w=" << best_snapshot.best_weight << "  best_start=";
						print_word32_hex( "delta_a=", best_snapshot.start_delta_a );
						std::cout << " ";
						print_word32_hex( "delta_b=", best_snapshot.start_delta_b );
					}
					if ( !active.empty() )
					{
						std::cout << "  active=" << active.size() << " {";
						const std::size_t show = std::min<std::size_t>( active.size(), 8 );
						for ( std::size_t i = 0; i < show; ++i )
						{
							if ( i )
								std::cout << ", ";
							std::cout << "[Job#" << active[ i ].job_id_one_based << "@" << active[ i ].thread_id << "] ";
							print_word32_hex( "delta_a=", active[ i ].delta_a );
							std::cout << " ";
							print_word32_hex( "delta_b=", active[ i ].delta_b );
						}
						if ( active.size() > show )
							std::cout << ", ...";
						std::cout << "}";
					}
					std::cout << "\n";

					last_done = done;
					last_time = now;
				}
				if ( done >= total )
					break;
				std::this_thread::sleep_for( std::chrono::milliseconds( 50 ) );
			}
		};

		run_worker_threads_with_monitor( breadth_threads_clamped, [ & ]( int t ) { worker( t ); }, progress_monitor );

		std::cout << "\n[Auto][Breadth] done. total_nodes_visited=" << total_nodes.load() << "\n";
		if ( top_candidates.empty() )
		{
			std::cout << "[Auto][Breadth] FAIL: no trail found in any candidate (within breadth limits).\n";
			return 0;
		}

		std::cout << "[Auto][Breadth] TOP-" << top_candidates.size() << ":\n";
		for ( std::size_t i = 0; i < top_candidates.size(); ++i )
		{
			const auto& c = top_candidates[ i ];
			std::cout << "  #" << ( i + 1 ) << "  entry_round1_weight=" << c.entry_round1_weight << "  best_weight=" << c.best_weight << "  start=";
			print_word32_hex( "delta_a=", c.start_delta_a );
			std::cout << " ";
			print_word32_hex( "delta_b=", c.start_delta_b );
			std::cout << "  entry=";
			print_word32_hex( "delta_a_round1=", c.entry_delta_a );
			std::cout << " ";
			print_word32_hex( "delta_b_round1=", c.entry_delta_b );
			std::cout << "  nodes=" << c.nodes << ( c.hit_maximum_search_nodes_limit ? " [HIT maximum_search_nodes limit]" : "" ) << "\n";
		}
		std::cout << "\n";

		// ---------------------------------------------------------------------
		// Stage 2: "deep" run for the best candidate (selected from the top-K pool).
		// ---------------------------------------------------------------------
		// Reconfigure caches for deep: single-thread defaults (unless user explicitly provided otherwise).
		{
			std::size_t deep_cache_per_thread = command_line_options.cache_was_provided ? command_line_options.cache_max_entries_per_thread : std::size_t( 262144 );
			if ( !command_line_options.cache_was_provided )
			{
				std::size_t deep_shared_total_unused = 0;
				compute_aggressive_cache_budget( 1, deep_cache_per_thread, deep_shared_total_unused );
			}
			g_injection_cache_max_entries_per_thread = deep_cache_per_thread;
			// Keep the shared cache configuration from breadth stage (it can help warm-start deep runs).
		}

		DifferentialBestSearchConfiguration deep_configuration = command_line_options.search_configuration;
		// Auto mode deep search: remove heuristic caps (time-first extreme). Stop conditions are only:
		// - reach target_best_weight (if provided)
		// - hit maximum_search_seconds (if provided and maximum_search_nodes==0)
		// - hit maximum_search_nodes (if provided)
		deep_configuration.maximum_constant_subtraction_candidates = 0;									// 0=exact/all
		heuristic_branch_cap( deep_configuration ) = 0;													// 0=exact/all
		deep_configuration.maximum_search_nodes = command_line_options.auto_deep_maximum_search_nodes;	// 0=unlimited
		// Time budget is used only when node budget is unlimited (requested behavior).
		deep_configuration.maximum_search_seconds = ( deep_configuration.maximum_search_nodes == 0 ) ? command_line_options.auto_max_time_seconds : 0;

		// Force progress printing (needed to get data during long runs), and force printing diffs.
		// Keep behavior consistent with breadth/strategy:
		// - Use --progress-every-seconds when provided
		// - In auto mode we still force a non-zero interval to avoid "silent" long runs
		const std::uint64_t deep_progress_sec = ( command_line_options.progress_every_seconds == 0 ) ? 1 : command_line_options.progress_every_seconds;

		std::cout << "[Auto][Deep] inputs (from breadth top candidates): count=" << top_candidates.size() << "\n";
		for ( std::size_t i = 0; i < top_candidates.size(); ++i )
		{
			const auto& c = top_candidates[ i ];
			std::cout << "  #" << ( i + 1 ) << " ";
			print_word32_hex( "delta_a=", c.start_delta_a );
			std::cout << " ";
			print_word32_hex( "delta_b=", c.start_delta_b );
			std::cout << "  breadth_entry_w=" << c.entry_round1_weight << "  breadth_best_w=" << ( ( c.best_weight >= INFINITE_WEIGHT ) ? -1 : c.best_weight ) << "\n";
		}
		if ( deep_configuration.target_best_weight >= 0 )
		{
			std::cout << "  target_best_weight=" << deep_configuration.target_best_weight << "  (prob >= 2^-" << deep_configuration.target_best_weight << ")\n";
		}
		std::cout << "  deep_maximum_search_nodes=" << deep_configuration.maximum_search_nodes << ( deep_configuration.maximum_search_nodes == 0 ? " (unlimited)" : "" ) << "\n";
		if ( deep_configuration.maximum_search_seconds != 0 )
		{
			std::cout << "  deep_maximum_search_seconds=" << deep_configuration.maximum_search_seconds << "\n";
		}
		else if ( command_line_options.auto_max_time_seconds != 0 && deep_configuration.maximum_search_nodes != 0 )
		{
			std::cout << "  deep_max_time_seconds=(ignored because deep maximum_search_nodes is non-zero)\n";
		}
		std::cout << "\n";

		{
			const auto& c = top_candidates.front();
			std::cout << "[Auto][Deep] selected_best #1/" << top_candidates.size() << "  maximum_search_nodes=" << deep_configuration.maximum_search_nodes << ( deep_configuration.maximum_search_nodes == 0 ? "(unlimited)" : "" ) << "  progress_every_seconds=" << deep_progress_sec << "\n";
			std::cout << "  start=";
			print_word32_hex( "delta_a=", c.start_delta_a );
			std::cout << " ";
			print_word32_hex( "delta_b=", c.start_delta_b );
			std::cout << "  (seeded_upper_bound_weight=" << ( ( c.best_weight >= INFINITE_WEIGHT ) ? -1 : c.best_weight ) << ")\n\n";

			const int										seed_weight = c.best_weight;
			const std::vector<DifferentialTrailStepRecord>* seed_trail = c.trail.empty() ? nullptr : &c.trail;

			BestWeightCheckpointWriter checkpoint {};
			const std::string		   checkpoint_path = BestWeightCheckpointWriter::default_path( command_line_options.round_count, c.start_delta_a, c.start_delta_b );
			if ( checkpoint.open_append( checkpoint_path ) )
			{
				std::cout << "[Auto][Deep] checkpoint_file=" << checkpoint_path << " (append on best-weight changes)\n\n";
			}
			else
			{
				std::cout << "[Auto][Deep] WARNING: cannot open checkpoint file for writing: " << checkpoint_path << "\n\n";
			}

			const std::string prefix = "[Auto][Deep][Job#1@0] ";
			TwilightDream::runtime_component::ProgressPrefixGuard prefix_guard( prefix.c_str() );
			try
			{
				( void )run_matsui_best_search_with_injection_internal( command_line_options.round_count, c.start_delta_a, c.start_delta_b, deep_configuration, true, deep_progress_sec,
																		true,  // progress_print_differences
																		seed_weight, seed_trail, checkpoint.out ? &checkpoint : nullptr );
			}
			catch ( const std::bad_alloc& )
			{
				pmr_report_oom_once( "auto_deep.run" );
				std::cout << "[Auto][Deep] ERROR: out of memory; aborted this candidate.\n\n";
			}
			std::cout << "\n";
		}

		memory_governor_disable_for_run();

		// Explicitly clear shared caches with progress to avoid slow exit-time teardown.
		g_shared_injection_cache_branch_a.clear_and_release_with_progress( "shared_cache.branch_a" );
		g_shared_injection_cache_branch_b.clear_and_release_with_progress( "shared_cache.branch_b" );
		return 0;
	}

	static int run_single_mode( const CommandLineOptions& command_line_options )
	{
		const SystemMemoryInfo mem = query_system_memory_info();
		const std::uint64_t	   avail_bytes = mem.available_physical_bytes;
		std::uint64_t		   headroom_bytes = ( command_line_options.strategy_target_headroom_bytes != 0 ) ? command_line_options.strategy_target_headroom_bytes : compute_memory_headroom_bytes( avail_bytes, command_line_options.memory_headroom_mib, command_line_options.memory_headroom_mib_was_provided );
		if ( avail_bytes != 0 && headroom_bytes > avail_bytes )
			headroom_bytes = avail_bytes;

		// Configure PMR budget for this run.
		pmr_configure_for_run( avail_bytes, headroom_bytes );
		memory_governor_enable_for_run( headroom_bytes );
		memory_governor_set_poll_fn( &governor_poll_system_memory_once );

		MemoryBallast memory_ballast( headroom_bytes );
		if ( command_line_options.memory_ballast_enabled && headroom_bytes != 0 )
		{
			IosStateGuard g( std::cout );
			std::cout << "[MemoryBallast] enabled  headroom_gibibytes=" << std::fixed << std::setprecision( 2 ) << bytes_to_gibibytes( headroom_bytes ) << "\n";
			memory_ballast.start();
		}

		// Configure caches for this run.
		// Single-run defaults can be larger because only one worker thread exists.
		const std::size_t cache_per_thread = command_line_options.cache_was_provided ? command_line_options.cache_max_entries_per_thread : std::size_t( 262144 );
		g_injection_cache_max_entries_per_thread = cache_per_thread;
		g_shared_injection_cache_branch_a.configure( command_line_options.shared_cache_total_entries, command_line_options.shared_cache_shards );
		g_shared_injection_cache_branch_b.configure( command_line_options.shared_cache_total_entries, command_line_options.shared_cache_shards );

		std::cout << "round_count=" << command_line_options.round_count << "\n";
		print_word32_hex( "initial_branch_a_difference=", command_line_options.initial_branch_a_difference );
		std::cout << "\n";
		print_word32_hex( "initial_branch_b_difference=", command_line_options.initial_branch_b_difference );
		std::cout << "\n\n";
		if ( command_line_options.initial_differences_were_generated )
		{
			std::cout << "(initial differences generated from --seed=0x" << std::hex << command_line_options.batch_seed << std::dec << ")\n\n";
		}

		// Strategy mode is meant to be "lazy": show all auto-derived knobs up-front.
		if ( command_line_options.frontend_mode == CommandLineOptions::FrontendMode::Strategy )
		{
			std::cout << "[Strategy] resolved settings:\n";
			std::cout << "  preset=" << to_string( command_line_options.strategy_preset ) << "  heuristics=" << ( command_line_options.strategy_heuristics_enabled ? "on" : "off" ) << "\n";
			if ( command_line_options.strategy_total_work_was_provided )
			{
				std::cout << "  total_work=" << command_line_options.strategy_total_work << "\n";
			}
			std::cout << "  resolved_worker_threads=" << command_line_options.strategy_resolved_worker_threads << "\n";
			if ( command_line_options.strategy_available_physical_bytes != 0 )
			{
				IosStateGuard g( std::cout );
				std::cout << "  system_memory: total_physical_gibibytes=" << std::fixed << std::setprecision( 2 ) << bytes_to_gibibytes( command_line_options.strategy_total_physical_bytes ) << "  available_physical_gibibytes=" << std::fixed << std::setprecision( 2 ) << bytes_to_gibibytes( command_line_options.strategy_available_physical_bytes );
				if ( command_line_options.strategy_target_headroom_bytes != 0 )
				{
					std::cout << "  headroom_gibibytes=" << std::fixed << std::setprecision( 2 ) << bytes_to_gibibytes( command_line_options.strategy_target_headroom_bytes );
				}
				if ( command_line_options.strategy_derived_budget_bytes != 0 )
				{
					std::cout << "  derived_budget_gibibytes=" << std::fixed << std::setprecision( 2 ) << bytes_to_gibibytes( command_line_options.strategy_derived_budget_bytes );
				}
				std::cout << "\n";
			}
			std::cout << "  addition_weight_cap=" << command_line_options.search_configuration.addition_weight_cap << "  constant_subtraction_weight_cap=" << command_line_options.search_configuration.constant_subtraction_weight_cap << "  maximum_constant_subtraction_candidates=" << command_line_options.search_configuration.maximum_constant_subtraction_candidates << "  heuristic_branch_cap=" << heuristic_branch_cap( command_line_options.search_configuration ) << "  maximum_search_node=" << command_line_options.search_configuration.maximum_search_nodes << "  enable_state_memoization=" << ( command_line_options.search_configuration.enable_state_memoization ? "on" : "off" ) << "\n";
			std::cout << "  cache_per_thread=" << cache_per_thread << "  cache_shared_total=" << command_line_options.shared_cache_total_entries << "  cache_shared_shards=" << round_up_power_of_two( std::max<std::size_t>( 1, command_line_options.shared_cache_shards ) ) << ( command_line_options.shared_cache_total_entries ? "" : " (off)" ) << "\n\n";
		}

		try
		{
			( void )run_matsui_best_search_with_injection_internal( command_line_options.round_count, command_line_options.initial_branch_a_difference, command_line_options.initial_branch_b_difference, command_line_options.search_configuration, true, command_line_options.progress_every_seconds );
		}
		catch ( const std::bad_alloc& )
		{
			pmr_report_oom_once( "single.run" );
			std::cout << "[ERROR] out of memory.\n";
			return 1;
		}

		memory_governor_disable_for_run();

		// Explicitly clear shared caches with progress to avoid slow exit-time teardown.
		g_shared_injection_cache_branch_a.clear_and_release_with_progress( "shared_cache.branch_a" );
		g_shared_injection_cache_branch_b.clear_and_release_with_progress( "shared_cache.branch_b" );
		return 0;
	}

	static int run_batch_mode( const CommandLineOptions& command_line_options )
	{
		const SystemMemoryInfo mem = query_system_memory_info();
		const std::uint64_t	   avail_bytes = mem.available_physical_bytes;
		std::uint64_t		   headroom_bytes = ( command_line_options.strategy_target_headroom_bytes != 0 ) ? command_line_options.strategy_target_headroom_bytes : compute_memory_headroom_bytes( avail_bytes, command_line_options.memory_headroom_mib, command_line_options.memory_headroom_mib_was_provided );
		if ( avail_bytes != 0 && headroom_bytes > avail_bytes )
			headroom_bytes = avail_bytes;

		// Configure PMR budget for this run.
		pmr_configure_for_run( avail_bytes, headroom_bytes );
		memory_governor_enable_for_run( headroom_bytes );
		memory_governor_set_poll_fn( &governor_poll_system_memory_once );

		MemoryBallast memory_ballast( headroom_bytes );
		if ( command_line_options.memory_ballast_enabled && headroom_bytes != 0 )
		{
			IosStateGuard g( std::cout );
			std::cout << "[MemoryBallast] enabled  headroom_gibibytes=" << std::fixed << std::setprecision( 2 ) << bytes_to_gibibytes( headroom_bytes ) << "\n";
			memory_ballast.start();
		}

		// In batch mode we ignore the positional (delta_a, delta_b) and generate random ones.
		std::cout << "round_count=" << command_line_options.round_count << ( command_line_options.batch_job_file_was_provided ? " (default; file may override per job)" : "" ) << "\n";
		std::cout << "initial_branch_a_difference=(ignored in --batch)\n";
		std::cout << "initial_branch_b_difference=(ignored in --batch)\n\n";

		if ( command_line_options.frontend_mode == CommandLineOptions::FrontendMode::Strategy )
		{
			std::cout << "[Strategy] resolved settings:\n";
			std::cout << "  preset=" << to_string( command_line_options.strategy_preset ) << "  heuristics=" << ( command_line_options.strategy_heuristics_enabled ? "on" : "off" ) << "\n";
			if ( command_line_options.strategy_total_work_was_provided )
			{
				std::cout << "  total_work=" << command_line_options.strategy_total_work << "\n";
			}
			std::cout << "  resolved_worker_threads=" << command_line_options.strategy_resolved_worker_threads << "\n";
			if ( command_line_options.strategy_available_physical_bytes != 0 )
			{
				IosStateGuard g( std::cout );
				std::cout << "  system_memory: total_physical_gibibytes=" << std::fixed << std::setprecision( 2 ) << bytes_to_gibibytes( command_line_options.strategy_total_physical_bytes ) << "  available_physical_gibibytes=" << std::fixed << std::setprecision( 2 ) << bytes_to_gibibytes( command_line_options.strategy_available_physical_bytes );
				if ( command_line_options.strategy_target_headroom_bytes != 0 )
				{
					std::cout << "  headroom_gibibytes=" << std::fixed << std::setprecision( 2 ) << bytes_to_gibibytes( command_line_options.strategy_target_headroom_bytes );
				}
				if ( command_line_options.strategy_derived_budget_bytes != 0 )
				{
					std::cout << "  derived_budget_gibibytes=" << std::fixed << std::setprecision( 2 ) << bytes_to_gibibytes( command_line_options.strategy_derived_budget_bytes );
				}
				std::cout << "\n";
			}
			std::cout << "  addition_weight_cap=" << command_line_options.search_configuration.addition_weight_cap << "  constant_subtraction_weight_cap=" << command_line_options.search_configuration.constant_subtraction_weight_cap << "  maximum_constant_subtraction_candidates=" << command_line_options.search_configuration.maximum_constant_subtraction_candidates << "  heuristic_branch_cap=" << heuristic_branch_cap( command_line_options.search_configuration ) << "  maximum_search_nodes=" << command_line_options.search_configuration.maximum_search_nodes << "  enable_state_memoization=" << ( command_line_options.search_configuration.enable_state_memoization ? "on" : "off" ) << "\n";
			std::cout << "  cache_max_entries_per_thread=" << command_line_options.cache_max_entries_per_thread << "  shared_cache_total_entries=" << command_line_options.shared_cache_total_entries << "  shared_cache_shards=" << round_up_power_of_two( std::max<std::size_t>( 1, command_line_options.shared_cache_shards ) ) << ( command_line_options.shared_cache_total_entries ? "" : " (off)" ) << "\n\n";
		}

		const unsigned hw = std::thread::hardware_concurrency();
		const int	   worker_thread_count = ( command_line_options.batch_thread_count > 0 ) ? command_line_options.batch_thread_count : int( ( hw == 0 ) ? 1 : hw );

		// Configure caches for this run.
		// For large thread counts (HPC), we default to an AUTO cap that keeps total cached entries
		// roughly constant (~1M across all threads), unless the user explicitly overrides it.
		std::size_t cache_per_thread = command_line_options.cache_max_entries_per_thread;
		bool		cache_is_auto = false;
		if ( !command_line_options.cache_was_provided )
		{
			const std::size_t total_budget_entries = 1'048'576;	 // ~1M total entries across all threads
			const std::size_t per_thread = total_budget_entries / std::size_t( std::max( 1, worker_thread_count ) );
			cache_per_thread = std::clamp( per_thread, std::size_t( 4096 ), std::size_t( 262144 ) );
			cache_is_auto = true;
		}
		g_injection_cache_max_entries_per_thread = cache_per_thread;

		// Configure optional shared cache (cross-thread). Default: disabled unless explicitly provided.
		std::size_t shared_cache_shard_count = command_line_options.shared_cache_shards;
		bool		shared_shards_is_auto = false;
		if ( command_line_options.shared_cache_total_entries != 0 && !command_line_options.shared_cache_shards_was_provided )
		{
			shared_cache_shard_count = compute_auto_shared_cache_shards( command_line_options.shared_cache_total_entries, worker_thread_count );
			shared_shards_is_auto = true;
		}
		g_shared_injection_cache_branch_a.configure( command_line_options.shared_cache_total_entries, shared_cache_shard_count );
		g_shared_injection_cache_branch_b.configure( command_line_options.shared_cache_total_entries, shared_cache_shard_count );

		struct BatchJob
		{
			int			  rounds;
			std::uint32_t initial_branch_a_difference;
			std::uint32_t initial_branch_b_difference;
		};
		std::vector<BatchJob> jobs;

		enum class BatchLineParseResult
		{
			Ignore,
			Ok,
			Error
		};
		auto parse_batch_job_line = [ & ]( const std::string& raw_line, int line_no, BatchJob& out ) -> BatchLineParseResult {
			std::string line = raw_line;
			// Strip comments starting with '#'
			if ( const std::size_t p = line.find( '#' ); p != std::string::npos )
				line.resize( p );
			// Normalize separators: commas -> spaces
			for ( char& ch : line )
				if ( ch == ',' )
					ch = ' ';

			// Skip empty/whitespace-only lines
			bool any_non_ws = false;
			for ( char ch : line )
			{
				if ( !( ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n' ) )
				{
					any_non_ws = true;
					break;
				}
			}
			if ( !any_non_ws )
				return BatchLineParseResult::Ignore;

			std::istringstream iss( line );
			std::string		   token0, token1, token2;
			if ( !( iss >> token0 >> token1 ) )
			{
				std::cerr << "[Batch] ERROR: invalid line " << line_no << " in batch file (need at least 2 tokens): " << raw_line << "\n";
				return BatchLineParseResult::Error;
			}
			if ( iss >> token2 )
			{
				// 3 tokens: rounds delta_a delta_b
				int			  round_count = 0;
				std::uint32_t initial_branch_a_difference = 0, initial_branch_b_difference = 0;
				if ( !parse_signed_integer_32( token0.c_str(), round_count ) || round_count <= 0 )
				{
					std::cerr << "[Batch] ERROR: invalid rounds on line " << line_no << ": " << raw_line << "\n";
					return BatchLineParseResult::Error;
				}
				if ( !parse_unsigned_integer_32( token1.c_str(), initial_branch_a_difference ) || !parse_unsigned_integer_32( token2.c_str(), initial_branch_b_difference ) )
				{
					std::cerr << "[Batch] ERROR: invalid initial branch differences on line " << line_no << ": " << raw_line << "\n";
					return BatchLineParseResult::Error;
				}
				if ( initial_branch_a_difference == 0u && initial_branch_b_difference == 0u )
				{
					std::cerr << "[Batch] ERROR: (initial_branch_a_difference, initial_branch_b_difference)=(0,0) is not allowed (line " << line_no << ")\n";
					return BatchLineParseResult::Error;
				}
				out = BatchJob { round_count, initial_branch_a_difference, initial_branch_b_difference };
				return BatchLineParseResult::Ok;
			}

			// 2 tokens: delta_a delta_b (use global rounds)
			{
				std::uint32_t initial_branch_a_difference = 0, initial_branch_b_difference = 0;
				if ( !parse_unsigned_integer_32( token0.c_str(), initial_branch_a_difference ) || !parse_unsigned_integer_32( token1.c_str(), initial_branch_b_difference ) )
				{
					std::cerr << "[Batch] ERROR: invalid initial branch differences on line " << line_no << ": " << raw_line << "\n";
					return BatchLineParseResult::Error;
				}
				if ( initial_branch_a_difference == 0u && initial_branch_b_difference == 0u )
				{
					std::cerr << "[Batch] ERROR: (initial_branch_a_difference, initial_branch_b_difference)=(0,0) is not allowed (line " << line_no << ")\n";
					return BatchLineParseResult::Error;
				}
				out = BatchJob { command_line_options.round_count, initial_branch_a_difference, initial_branch_b_difference };
				return BatchLineParseResult::Ok;
			}
		};

		if ( command_line_options.batch_job_file_was_provided )
		{
			std::ifstream f( command_line_options.batch_job_file );
			if ( !f )
			{
				std::cerr << "[Batch] ERROR: cannot open batch file: " << command_line_options.batch_job_file << "\n";
				return 1;
			}
			const std::size_t limit = ( command_line_options.batch_job_count > 0 ) ? command_line_options.batch_job_count : std::numeric_limits<std::size_t>::max();
			jobs.reserve( std::min<std::size_t>( limit, 1024 ) );
			std::string line;
			int			line_no = 0;
			while ( std::getline( f, line ) )
			{
				++line_no;
				BatchJob   job {};
				const auto parse_result = parse_batch_job_line( line, line_no, job );
				if ( parse_result == BatchLineParseResult::Error )
					return 1;
				if ( parse_result == BatchLineParseResult::Ok )
				{
					jobs.push_back( job );
					if ( jobs.size() >= limit )
						break;
				}
			}
			if ( jobs.empty() )
			{
				std::cerr << "[Batch] ERROR: batch file contains no jobs: " << command_line_options.batch_job_file << "\n";
				return 1;
			}
		}
		else
		{
			jobs.reserve( command_line_options.batch_job_count );
			std::mt19937_64 rng( command_line_options.batch_seed );
			for ( std::size_t job_index = 0; job_index < command_line_options.batch_job_count; ++job_index )
			{
				std::uint32_t initial_branch_a_difference = 0, initial_branch_b_difference = 0;
				do
				{
					initial_branch_a_difference = static_cast<std::uint32_t>( rng() );
					initial_branch_b_difference = static_cast<std::uint32_t>( rng() );
				} while ( initial_branch_a_difference == 0u && initial_branch_b_difference == 0u );
				jobs.push_back( { command_line_options.round_count, initial_branch_a_difference, initial_branch_b_difference } );
			}
		}

		int min_rounds = std::numeric_limits<int>::max();
		int max_rounds = 0;
		for ( const auto& j : jobs )
		{
			min_rounds = std::min( min_rounds, j.rounds );
			max_rounds = std::max( max_rounds, j.rounds );
		}

		std::cout << "[Batch] mode=matsui(injection-affine)\n";
		if ( min_rounds == max_rounds )
		{
			std::cout << "  rounds=" << min_rounds;
		}
		else
		{
			std::cout << "  rounds_range=[" << min_rounds << "," << max_rounds << "]";
		}
		std::cout << "  jobs=" << jobs.size() << "  threads=" << worker_thread_count;
		if ( command_line_options.batch_job_file_was_provided )
		{
			std::cout << "  batch_file=" << command_line_options.batch_job_file << "\n";
		}
		else
		{
			std::cout << "  seed=0x" << std::hex << command_line_options.batch_seed << std::dec << "\n";
		}
		std::cout << "  per_job: addition_weight_cap=" << command_line_options.search_configuration.addition_weight_cap << " constant_subtraction_weight_cap=" << command_line_options.search_configuration.constant_subtraction_weight_cap << " maximum_constant_subtraction_candidates=" << command_line_options.search_configuration.maximum_constant_subtraction_candidates << " heuristic_branch_cap=" << heuristic_branch_cap( command_line_options.search_configuration ) << " maximum_search_nodes=" << command_line_options.search_configuration.maximum_search_nodes << " enable_state_memoization=" << ( command_line_options.search_configuration.enable_state_memoization ? "on" : "off" ) << "\n";
		std::cout << " cache_per_thread=" << cache_per_thread << ( cache_is_auto ? " (auto)" : "" ) << "\n";
		std::cout << " shared_cache_total=" << command_line_options.shared_cache_total_entries << " shards=" << round_up_power_of_two( std::max<std::size_t>( 1, shared_cache_shard_count ) ) << ( shared_shards_is_auto ? " (auto)" : "" ) << ( command_line_options.shared_cache_total_entries ? "" : " (off)" ) << "\n";
		std::cout << "  progress_every_jobs=" << command_line_options.progress_every_jobs << "  progress_every_seconds=" << command_line_options.progress_every_seconds << "\n\n";

		// Batch mode now follows an auto-like two-stage pipeline:
		//   Stage 1: breadth scan across ALL jobs (small budget; keep TOP-K)
		//   Stage 2: deep run on TOP-K jobs (parallel; one job per thread)
		const int		  breadth_threads_clamped = std::max( 1, worker_thread_count );
		const std::size_t deep_top_k = std::min<std::size_t>( jobs.size(), std::size_t( breadth_threads_clamped ) );

		struct BreadthCandidate
		{
			bool									 found = false;
			std::size_t								 job_index = 0;
			std::uint32_t							 start_delta_a = 0;
			std::uint32_t							 start_delta_b = 0;
			std::uint32_t							 entry_delta_a = 0;
			std::uint32_t							 entry_delta_b = 0;
			int										 entry_round1_weight = INFINITE_WEIGHT;
			int										 best_weight = INFINITE_WEIGHT;
			std::uint64_t							 nodes = 0;
			bool									 hit_maximum_search_nodes_limit = false;
			std::vector<DifferentialTrailStepRecord> trail;
		};

		auto candidate_key_better = [ & ]( const BreadthCandidate& a, const BreadthCandidate& b ) -> bool {
			if ( a.best_weight != b.best_weight )
				return a.best_weight < b.best_weight;
			if ( a.entry_round1_weight != b.entry_round1_weight )
				return a.entry_round1_weight < b.entry_round1_weight;
			if ( a.job_index != b.job_index )
				return a.job_index < b.job_index;
			if ( a.start_delta_a != b.start_delta_a )
				return a.start_delta_a < b.start_delta_a;
			if ( a.start_delta_b != b.start_delta_b )
				return a.start_delta_b < b.start_delta_b;
			return a.nodes < b.nodes;
		};

		DifferentialBestSearchConfiguration breadth_configuration = command_line_options.search_configuration;
		breadth_configuration.maximum_constant_subtraction_candidates = command_line_options.auto_breadth_maximum_constant_subtraction_candidates;
		heuristic_branch_cap( breadth_configuration ) = command_line_options.auto_breadth_heuristic_branch_cap;
		breadth_configuration.maximum_search_nodes = std::max<std::uint64_t>( 1, command_line_options.auto_breadth_maximum_search_nodes );
		breadth_configuration.maximum_search_seconds = 0;

		std::cout << "[Batch][Breadth] start: jobs=" << jobs.size() << " threads=" << breadth_threads_clamped << " keep_top_k=" << deep_top_k << "\n";
		std::cout << "  breadth_maximum_search_nodes=" << breadth_configuration.maximum_search_nodes << "  breadth_heuristic_branch_cap=" << heuristic_branch_cap( breadth_configuration ) << "  breadth_maximum_constant_subtraction_candidates=" << breadth_configuration.maximum_constant_subtraction_candidates << "\n\n";

		std::atomic<std::size_t>   next_index { 0 };
		std::atomic<std::size_t>   completed { 0 };
		std::atomic<std::uint64_t> total_nodes_breadth { 0 };

		// Track active job-id (1-based) per thread for progress printing.
		std::vector<std::atomic<std::size_t>> active_job_id_by_thread( static_cast<std::size_t>( breadth_threads_clamped ) );
		for ( auto& x : active_job_id_by_thread )
			x.store( 0, std::memory_order_relaxed );

		std::mutex					  top_mutex;
		std::vector<BreadthCandidate> top_candidates;
		top_candidates.reserve( std::max<std::size_t>( 1, deep_top_k ) );

		auto try_update_top_candidates = [ & ]( BreadthCandidate&& c ) {
			if ( !c.found )
				return;
			std::scoped_lock lk( top_mutex );
			if ( top_candidates.size() < deep_top_k )
			{
				top_candidates.push_back( std::move( c ) );
			}
			else
			{
				std::size_t worst = 0;
				for ( std::size_t i = 1; i < top_candidates.size(); ++i )
				{
					if ( candidate_key_better( top_candidates[ worst ], top_candidates[ i ] ) )
						worst = i;
				}
				if ( candidate_key_better( c, top_candidates[ worst ] ) )
					top_candidates[ worst ] = std::move( c );
			}

			std::sort( top_candidates.begin(), top_candidates.end(), candidate_key_better );
		};

		const auto start_time_breadth = std::chrono::steady_clock::now();

		auto worker = [ & ]( int thread_id ) {
			for ( ;; )
			{
				const std::size_t job_index = next_index.fetch_add( 1, std::memory_order_relaxed );
				if ( job_index >= jobs.size() )
					break;

				active_job_id_by_thread[ std::size_t( thread_id ) ].store( job_index + 1, std::memory_order_relaxed );
				const BatchJob job = jobs[ job_index ];

				BestSearchResult result {};
				try
				{
					result = run_matsui_best_search_with_injection_internal( job.rounds, job.initial_branch_a_difference, job.initial_branch_b_difference, breadth_configuration, false, 0 );
				}
				catch ( const std::bad_alloc& )
				{
					pmr_report_oom_once( "batch.breadth" );
					result.found = false;
					result.best_weight = INFINITE_WEIGHT;
					result.nodes_visited = 0;
					result.hit_maximum_search_nodes = false;
					result.hit_time_limit = false;
				}

				total_nodes_breadth.fetch_add( result.nodes_visited, std::memory_order_relaxed );

				BreadthCandidate c {};
				c.job_index = job_index;
				c.start_delta_a = job.initial_branch_a_difference;
				c.start_delta_b = job.initial_branch_b_difference;
				c.best_weight = result.best_weight;
				c.nodes = result.nodes_visited;
				c.hit_maximum_search_nodes_limit = result.hit_maximum_search_nodes;
				c.trail = std::move( result.best_trail );
				c.found = result.found && !c.trail.empty();
				if ( c.found )
				{
					c.entry_delta_a = c.trail.front().input_branch_a_difference;
					c.entry_delta_b = c.trail.front().input_branch_b_difference;
					c.entry_round1_weight = c.trail.front().round_weight;
					try_update_top_candidates( std::move( c ) );
				}

				active_job_id_by_thread[ std::size_t( thread_id ) ].store( 0, std::memory_order_relaxed );
				completed.fetch_add( 1, std::memory_order_relaxed );
			}
		};

		auto progress_monitor = [ & ]() {
			const std::size_t total = jobs.size();
			if ( total == 0 )
				return;

			const std::uint64_t breadth_progress_sec = ( command_line_options.progress_every_seconds == 0 ) ? 1 : command_line_options.progress_every_seconds;
			std::size_t			last_done = 0;
			auto				last_time = start_time_breadth;

			for ( ;; )
			{
				const std::size_t done = completed.load( std::memory_order_relaxed );
				const auto		  now_for_governor = std::chrono::steady_clock::now();
				memory_governor_poll_if_needed( now_for_governor );

				const auto	 now = std::chrono::steady_clock::now();
				const double since_last = std::chrono::duration<double>( now - last_time ).count();
				if ( since_last >= double( breadth_progress_sec ) || done >= total )
				{
					const double	  elapsed = std::chrono::duration<double>( now - start_time_breadth ).count();
					const double	  window = std::max( 1e-9, std::chrono::duration<double>( now - last_time ).count() );
					const std::size_t delta = ( done >= last_done ) ? ( done - last_done ) : 0;
					const double	  rate = double( delta ) / window;

					BreadthCandidate best_snapshot {};
					best_snapshot.best_weight = INFINITE_WEIGHT;
					{
						std::scoped_lock lk( top_mutex );
						if ( !top_candidates.empty() )
							best_snapshot = top_candidates.front();
					}

					struct ActiveBatchJob
					{
						std::size_t  thread_id = 0;
						std::size_t  job_id_one_based = 0;
						std::uint32_t delta_a = 0;
						std::uint32_t delta_b = 0;
					};
					std::vector<ActiveBatchJob> active;
					active.reserve( active_job_id_by_thread.size() );
					for ( std::size_t i = 0; i < active_job_id_by_thread.size(); ++i )
					{
						const std::size_t id = active_job_id_by_thread[ i ].load( std::memory_order_relaxed );
						if ( id == 0 )
							continue;
						const std::size_t job_index = id - 1;
						if ( job_index >= jobs.size() )
							continue;
						const BatchJob& j = jobs[ job_index ];
						active.push_back( ActiveBatchJob { i, id, j.initial_branch_a_difference, j.initial_branch_b_difference } );
					}

					IosStateGuard g( std::cout );
					std::cout << "[Batch][Breadth] progress " << done << "/" << total << " (" << std::fixed << std::setprecision( 2 ) << ( 100.0 * double( done ) / double( total ) ) << "%)"
							  << " jobs_per_sec=" << std::setprecision( 2 ) << rate << " elapsed_sec=" << std::setprecision( 2 ) << elapsed << " total_nodes=" << total_nodes_breadth.load( std::memory_order_relaxed );
					if ( best_snapshot.best_weight < INFINITE_WEIGHT )
						std::cout << " best_weight=" << best_snapshot.best_weight << " best_job=#" << ( best_snapshot.job_index + 1 );
					if ( !active.empty() )
					{
						std::cout << " active={";
						const std::size_t show = std::min<std::size_t>( active.size(), 16 );
						for ( std::size_t i = 0; i < show; ++i )
						{
							if ( i )
								std::cout << ",";
							std::cout << "[Job#" << active[ i ].job_id_one_based << "@" << active[ i ].thread_id << "] ";
							print_word32_hex( "delta_a=", active[ i ].delta_a );
							std::cout << " ";
							print_word32_hex( "delta_b=", active[ i ].delta_b );
						}
						if ( active.size() > show )
							std::cout << ",...";
						std::cout << "}";
					}
					std::cout << "\n";

					last_done = done;
					last_time = now;
				}

				if ( done >= total )
					break;
				std::this_thread::sleep_for( std::chrono::milliseconds( 50 ) );
			}
		};

		run_worker_threads_with_monitor( breadth_threads_clamped, [ & ]( int t ) { worker( t ); }, progress_monitor );

		const auto	 end_time_breadth = std::chrono::steady_clock::now();
		const double elapsed_breadth = std::chrono::duration<double>( end_time_breadth - start_time_breadth ).count();

		{
			std::scoped_lock lk( top_mutex );
			std::sort( top_candidates.begin(), top_candidates.end(), candidate_key_better );
		}

		{
			IosStateGuard g( std::cout );
			std::cout << "\n[Batch][Breadth] done. elapsed_sec=" << std::fixed << std::setprecision( 2 ) << elapsed_breadth << " total_nodes_visited=" << total_nodes_breadth.load() << " top_k_found=" << top_candidates.size() << "\n";
		}

		if ( top_candidates.empty() )
		{
			std::cout << "[Batch] FAIL: breadth found no trail in any job (within breadth limits).\n";
			memory_governor_disable_for_run();
			g_shared_injection_cache_branch_a.clear_and_release_with_progress( "shared_cache.branch_a" );
			g_shared_injection_cache_branch_b.clear_and_release_with_progress( "shared_cache.branch_b" );
			return 0;
		}

		std::cout << "[Batch][Breadth] TOP-" << top_candidates.size() << " candidates:\n";
		for ( std::size_t i = 0; i < top_candidates.size(); ++i )
		{
			const auto&	  current_candidate = top_candidates[ i ];
			const auto&	  current_job = jobs[ current_candidate.job_index ];
			IosStateGuard g( std::cout );
			std::cout << "  #" << ( i + 1 ) << "  job=#" << ( current_candidate.job_index + 1 ) << "  rounds=" << current_job.rounds << "  best_weight=" << current_candidate.best_weight << "  nodes=" << current_candidate.nodes << ( current_candidate.hit_maximum_search_nodes_limit ? " [HIT maximum_search_nodes limit]" : "" ) << "\n";
		}
		std::cout << "\n";

		// ---------------------------------------------------------------------
		// Stage 2: deep run on TOP-K jobs (parallel, one job per thread)
		// ---------------------------------------------------------------------
		DifferentialBestSearchConfiguration deep_configuration = command_line_options.search_configuration;
		deep_configuration.maximum_constant_subtraction_candidates = 0;
		heuristic_branch_cap( deep_configuration ) = 0;
		deep_configuration.maximum_search_nodes = command_line_options.auto_deep_maximum_search_nodes;	// 0=unlimited
		deep_configuration.maximum_search_seconds = ( deep_configuration.maximum_search_nodes == 0 ) ? command_line_options.auto_max_time_seconds : 0;
		if ( command_line_options.auto_target_best_weight >= 0 )
			deep_configuration.target_best_weight = command_line_options.auto_target_best_weight;

		const std::uint64_t deep_progress_sec = ( command_line_options.progress_every_seconds == 0 ) ? 1 : command_line_options.progress_every_seconds;

		std::cout << "[Batch][Deep] start: inputs=" << top_candidates.size() << " deep_threads=" << top_candidates.size() << " progress_every_seconds=" << deep_progress_sec << "\n";
		std::cout << "  deep_maximum_search_nodes=" << deep_configuration.maximum_search_nodes << " deep_maximum_search_seconds=" << deep_configuration.maximum_search_seconds << " deep_target_best_weight=" << deep_configuration.target_best_weight << "\n\n";

		struct DeepResult
		{
			std::size_t		 job_index = 0;
			BestSearchResult result {};
		};
		std::vector<DeepResult> deep_results( top_candidates.size() );

		auto add_job_suffix_to_checkpoint_path = []( std::string path, std::size_t job_id_one_based ) -> std::string {
			const std::string suffix = "_job" + std::to_string( job_id_one_based );
			const std::string ext = ".log";
			if ( path.size() >= ext.size() && path.substr( path.size() - ext.size() ) == ext )
			{
				path.insert( path.size() - ext.size(), suffix );
				return path;
			}
			return path + suffix;
		};

		const auto start_time_deep = std::chrono::steady_clock::now();

		auto deep_worker = [ & ]( int thread_id ) {
			const BreadthCandidate& current_candidate = top_candidates[ static_cast<std::size_t>(thread_id) ];
			const BatchJob			current_job = jobs[ current_candidate.job_index ];
			const std::size_t		job_id = current_candidate.job_index + 1;

			const std::string prefix = "[Batch][Deep][Job#" + std::to_string( job_id ) + "@" + std::to_string( thread_id ) + "] ";
			TwilightDream::runtime_component::ProgressPrefixGuard prefix_guard( prefix.c_str() );

			BestWeightCheckpointWriter checkpoint {};
			const std::string		   checkpoint_path_base = BestWeightCheckpointWriter::default_path( current_job.rounds, current_candidate.start_delta_a, current_candidate.start_delta_b );
			const std::string		   checkpoint_path = add_job_suffix_to_checkpoint_path( checkpoint_path_base, job_id );
			const bool				   checkpoint_ok = checkpoint.open_append( checkpoint_path );
			{
				std::scoped_lock lk( TwilightDream::runtime_component::cout_mutex() );
				TwilightDream::runtime_component::print_progress_prefix( std::cout );
				if ( checkpoint_ok )
					std::cout << "[Deep] checkpoint_file=" << checkpoint_path << " (append on best-weight changes)\n";
				else
					std::cout << "[Deep] WARNING: cannot open checkpoint file for writing: " << checkpoint_path << "\n";
			}

			const int										seed_weight = current_candidate.best_weight;
			const std::vector<DifferentialTrailStepRecord>* seed_trail = current_candidate.trail.empty() ? nullptr : &current_candidate.trail;

			BestSearchResult result {};
			try
			{
				result = run_matsui_best_search_with_injection_internal( current_job.rounds, current_candidate.start_delta_a, current_candidate.start_delta_b, deep_configuration, true, deep_progress_sec, true, seed_weight, seed_trail, checkpoint_ok ? &checkpoint : nullptr );
			}
			catch ( const std::bad_alloc& )
			{
				pmr_report_oom_once( "batch.deep" );
				result.found = false;
				result.best_weight = INFINITE_WEIGHT;
				result.nodes_visited = 0;
				result.hit_maximum_search_nodes = false;
				result.hit_time_limit = false;
			}

			deep_results[ static_cast<std::size_t>(thread_id) ].job_index = current_candidate.job_index;
			deep_results[ static_cast<std::size_t>(thread_id) ].result = std::move( result );
		};

		TwilightDream::runtime_component::run_worker_threads( int( top_candidates.size() ), deep_worker );

		const auto	 end_time_deep = std::chrono::steady_clock::now();
		const double elapsed_deep = std::chrono::duration<double>( end_time_deep - start_time_deep ).count();

		std::uint64_t	 total_nodes_deep = 0;
		bool			 global_best_found = false;
		std::size_t		 global_best_job_index = 0;
		BestSearchResult global_best_result {};

		for ( const auto& dr : deep_results )
		{
			total_nodes_deep += dr.result.nodes_visited;
			if ( dr.result.found && !dr.result.best_trail.empty() && ( !global_best_found || dr.result.best_weight < global_best_result.best_weight ) )
			{
				global_best_found = true;
				global_best_job_index = dr.job_index;
				global_best_result = dr.result;
			}
		}

		{
			IosStateGuard g( std::cout );
			std::cout << "\n[Batch][Deep] done. elapsed_sec=" << std::fixed << std::setprecision( 2 ) << elapsed_deep << " total_nodes_visited=" << total_nodes_deep << "\n";
		}

		if ( !global_best_found || !global_best_result.found || global_best_result.best_weight >= INFINITE_WEIGHT || global_best_result.best_trail.empty() )
		{
			std::cout << "[Batch] FAIL: no trail found in TOP-K deep runs.\n";
			memory_governor_disable_for_run();
			g_shared_injection_cache_branch_a.clear_and_release_with_progress( "shared_cache.branch_a" );
			g_shared_injection_cache_branch_b.clear_and_release_with_progress( "shared_cache.branch_b" );
			return 0;
		}

		const BatchJob& best_job = jobs[ global_best_job_index ];
		{
			IosStateGuard g( std::cout );
			const double  approx_dp = weight_to_abs_correlation( double( global_best_result.best_weight ) );
			std::cout << "[Batch] BEST (from deep TOP-K): weight=" << global_best_result.best_weight << "  approx_DP=" << std::scientific << std::setprecision( 10 ) << approx_dp << std::defaultfloat << "\n";
		}
		std::cout << "  best_job=#" << ( global_best_job_index + 1 ) << "  best_rounds=" << best_job.rounds << "\n";
		print_word32_hex( "  best_initial_branch_a_difference=", best_job.initial_branch_a_difference );
		std::cout << "\n";
		print_word32_hex( "  best_initial_branch_b_difference=", best_job.initial_branch_b_difference );
		std::cout << "\n\n";

		print_result( global_best_result );

		memory_governor_disable_for_run();
		g_shared_injection_cache_branch_a.clear_and_release_with_progress( "shared_cache.branch_a" );
		g_shared_injection_cache_branch_b.clear_and_release_with_progress( "shared_cache.branch_b" );
		return 0;
	}

	static void print_result( const BestSearchResult& result )
	{
		if ( !result.found || result.best_weight >= INFINITE_WEIGHT || result.best_trail.empty() )
		{
			std::cout << "[FAIL] no trail found within limits.\n";
			std::cout << "  nodes_visited=" << result.nodes_visited;
			if ( result.hit_maximum_search_nodes )
				std::cout << "  [HIT maximum_search_nodes]";
			if ( result.hit_time_limit )
				std::cout << "  [HIT maximum_search_seconds]";
			std::cout << "\n";
			return;
		}

		{
			IosStateGuard g( std::cout );
			const double  approx_dp = weight_to_abs_correlation( double( result.best_weight ) );
			std::cout << "[OK] best_weight=" << result.best_weight << "  (DP ~= 2^-" << result.best_weight << ")\n";
			std::cout << "  approx_DP=" << std::scientific << std::setprecision( 10 ) << approx_dp << std::defaultfloat << "\n";
		}
		std::cout << "  nodes_visited=" << result.nodes_visited;
		if ( result.hit_maximum_search_nodes )
			std::cout << "  [HIT maximum_search_nodes]";
		if ( result.hit_time_limit )
			std::cout << "  [HIT maximum_search_seconds]";
		std::cout << "\n\n";

		for ( const auto& s : result.best_trail )
		{
			std::cout << "R" << s.round_index << "  round_weight=" << s.round_weight << "  weight_first_addition=" << s.weight_first_addition << "  weight_first_constant_subtraction=" << s.weight_first_constant_subtraction << "  weight_injection_from_branch_b=" << s.weight_injection_from_branch_b << "  weight_second_addition=" << s.weight_second_addition << "  weight_second_constant_subtraction=" << s.weight_second_constant_subtraction << "  weight_injection_from_branch_a=" << s.weight_injection_from_branch_a << "\n";
			print_word32_hex( "  input_branch_a_difference=", s.input_branch_a_difference );
			std::cout << "  ";
			print_word32_hex( "input_branch_b_difference=", s.input_branch_b_difference );
			std::cout << "\n";
			print_word32_hex( "  output_branch_a_difference=", s.output_branch_a_difference );
			std::cout << "  ";
			print_word32_hex( "output_branch_b_difference=", s.output_branch_b_difference );
			std::cout << "\n";
		}
	}

}  // namespace

int main( int argument_count, char** argument_values )
{
	CommandLineOptions command_line_options {};
	if ( !parse_command_line( argument_count, argument_values, command_line_options ) || command_line_options.show_help )
	{
		print_usage_information( ( argument_count > 0 && argument_values && argument_values[ 0 ] ) ? argument_values[ 0 ] : "test_neoalzette_differential_best_search.exe" );
		return command_line_options.show_help ? 0 : 1;
	}
	if ( command_line_options.selftest )
		return run_arx_operator_self_test();

	print_banner_and_mode( command_line_options );

	if ( command_line_options.frontend_mode == CommandLineOptions::FrontendMode::Auto )
	{
		return run_auto_mode( command_line_options );
	}

	if ( command_line_options.batch_job_count > 0 || command_line_options.batch_job_file_was_provided )
	{
		return run_batch_mode( command_line_options );
	}
	return run_single_mode( command_line_options );
}
