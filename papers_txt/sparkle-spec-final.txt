Schwaemm and Esch: Lightweight Authenticated Encryption and
Hashing using the Sparkle Permutation Family
Christof Beierle1,2 , Alex Biryukov1 , Luan Cardoso dos Santos1 , Johann Großschädl1 ,
Amir Moradi2 , Léo Perrin3 , Aein Rezaei Shahmirzadi2 , Aleksei Udovenko1,4 , Vesselin
Velichkov5 , and Qingju Wang1
1 DSC and SnT, University of Luxembourg, Luxembourg
2 Ruhr University Bochum, Horst Görtz Institute for IT Security, Germany
3 Inria, Paris, France
4 CryptoExperts, Paris, France
5 University of Edinburgh, U.K.

Version v1.2 (2021-05-17)

Corresponding submitter:
Prof. Dr. Alex Biryukov
Email: alex.biryukov@uni.lu
Phone: +352 466644-6793
University of Luxembourg
Maison du Nombre, 6, Avenue de la Fonte,
L–4364 Esch-sur-Alzette,
Luxembourg

Contact email for the whole Sparkle group:
sparklegrupp@googlegroups.com
Homepage of Schwaemm, Esch and Sparkle:
https://sparkle-lwc.github.io/

i

Algorithms Specified in this Document

†

Type

Name

Internal state size
(bytes)

Data block size
(bytes)

Security level
(bits)

Data limit
(bytes)

Hash function

Esch256†
Esch384

48
64

16
16

128
192

2132
2196

Extendable-output function (XOF)

XOEsch256
XOEsch384

48
64

16
16

min{128, 𝑡}
min{192, 𝑡}

2132
2196

AEAD

Schwaemm128-128
Schwaemm256-128†
Schwaemm192-192
Schwaemm256-256

32
48
48
64

16
32
24
32

120
120
184
248

268
268
268
2133

Primary instances.

We, the authors, faithfully declare that the algorithms presented in this document are, to the
best of our knowledge, safe from all attacks currently known. We have not hidden any weakness
in any of them.

Changelog. Version v𝑋.𝑌 refers to the 𝑌 -th updated version of the pdf with regard to the
algorithm specification 𝑋. Thus, differences in v𝑋.𝑌 and v𝑋.𝑌 ′ are only in the pdf, not in the
actual algorithms. New and improved implementations might be provided.
∙ v1.0 to v1.1: Besides correcting minor typos, we did the following changes. We switched the
primary member of the AEAD schemes from Schwaemm192-192 to Schwaemm256-128. We
give a name to the ARX-box used in Sparkle, i.e., Alzette. We further added a clarification
on how to map bitstrings to 32-bit words of the state in Sparkle. We also added new
implementation results in Chapter 5.
∙ v1.1 to v1.2: Besides correcting minor typos, we did the following changes. First of all, our
team is extended by Amir Moradi and Aein Rezaei Shahmirzadi. Moreover, we included
the results of our latest publications [BBCdS+ 20a] and [BBCdS+ 20b] in this document.
In particular, we included the extendable-output functions XOEsch256 and XOEsch384.
Further, we could slightly improve the differential bound of Alzette. More precisely, we now
have that the probability of the best 7-round differential trail is equal to 2−26 , which improves
upon our previous result which only stated that this probability was at most 2−24 . We also
expanded the division property analysis of Alzette.

Acknowledgements. The work of Christof Beierle was performed while he was at the University of
Luxembourg and funded by the SnT CryptoLux RG budget. Luan Cardoso dos Santos is supported
by the Luxembourg National Research Fund through grant PRIDE15/10621687/SPsquared. The
work of Aleksei Udovenko is funded by the Fonds National de la Recherche Luxembourg (project
reference 9037104). Part of the work by Vesselin Velichkov was performed while he was at the
University of Luxembourg. The work of Qingju Wang is funded by the University of Luxembourg
Internal Research Project (IRP) FDISC.
We thank Mridul Nandi for answering some questions about the Beetle mode of operation
and also Beno^ıt Cogliati for helping out with questions about provable security of variations of the
Beetle mode.
The experiments presented in this paper were carried out using the HPC facilities of the University of Luxembourg [VBCG14] – see https://hpc.uni.lu.
ii

Contents
Notations and Abbreviations

iv

Chapter 1. Introduction
1.1 What Is This Document? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2 What Are Esch and Schwaemm? . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.3 What Is Sparkle? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.4 What Are Their Key Features? . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1
1
1
2
3

Chapter 2. Specification
2.1 The Sparkle Permutations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 The Hash Functions Esch256 and Esch384 . . . . . . . . . . . . . . . . . . . . . .
2.3 The Authenticated Cipher Family Schwaemm . . . . . . . . . . . . . . . . . . . .
2.4 Recommendations for Joint Evaluation . . . . . . . . . . . . . . . . . . . . . . . . .

6
6
9
13
24

Chapter 3. Design Rationale
3.1 The Sponge Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2 A Permutation Structure that Favours Rigorous Security Arguments . . . . . . . .
3.3 The ARX-box Alzette . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.4 The Linear Layer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.5 On the Number of Steps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

25
25
28
34
43
46

Chapter 4. Security Analysis
4.1 Security Claims . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2 Attacks and Tests Against the Permutation . . . . . . . . . . . . . . . . . . . . . .
4.3 Attacks Against the Sponge . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.4 Guess and Determine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

49
49
50
61
64

Chapter 5. Implementation Aspects
5.1 Software Implementations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.2 Hardware Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.3 Protection against Side-Channel Attacks . . . . . . . . . . . . . . . . . . . . . . . .
5.4 Implementation Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

72
72
73
73
74

Bibliography

78

Chapter A. C Implementation of Sparkle

84

Chapter B. Linear Trails in Alzette

85

Chapter C. Representations of the Primitives

87

iii

Notations and Abbreviations
F2
F𝑛2
F*2

The set {0, 1}
The set of the bitstrings of length 𝑛
The set of bitstrings of arbitrary length

𝑛𝑏
ℎ𝑏
Word
Branch

number of branches
An element of F32
2
A pair (𝑥, 𝑦) of two words

+
⊕
||
𝐵𝑖
&
𝑥≪𝑠
𝑥≫𝑠
𝑥≪𝑠
𝑥≫𝑠
hw (𝑥)
𝜖

Modular addition
Exclusive or, also called “XOR”
Concatenation of bitstrings
The 𝑖-times concatenation of the bitstring 𝐵 with itself
The bitwise AND operation
The word 𝑥 rotated left by 𝑠 bits
The word 𝑥 rotated right by 𝑠 bits
The word 𝑥 shifted left by 𝑠 bits
The word 𝑥 shifted right by 𝑠 bits
The Hamming weight of the bitstring 𝑥
A binary string of length 0

|𝐸|
Pr[𝜔]
I, ℐ

The number of elements in a set 𝐸 or the length of a string in bit
The probability of an event 𝜔
The identity mapping

IoT
AEAD
ARX
SPN
LTS
SIMD

Internet of Things
Authenticated encryption with associated data
Add-Rotation-XOR
Substitution-Permutation Network
Long trail strategy
Single Instruction Multiple Data

𝑛𝑏
2

iv

1 Introduction
With the advent of the Internet of Things (IoT), a myriad of devices are being connected to
one another in order to exchange information. This information has to be secured. Symmetric
cryptography can ensure that the data those devices share remains confidential, that it is properly
authenticated and that it has not been tampered with.
As such objects have little computing power—and even less so that is dedicated to information
security—the cost of the algorithms ensuring these properties has to be as low as possible. To
answer this need, the NIST has called for the design of authenticated ciphers and hash functions
providing a sufficient security level at as small an implementation cost as possible.
In this document, we present a suite of algorithms that answer this call. All our algorithms are
built using the same core, namely the Sparkle family of permutations. The authenticated ciphers,
Schwaemm, provide confidentiality of the plaintext as well as both integrity and authentication
for the plaintext and for additional public associated data. The hash functions, Esch, are (second)
preimage and collision-resistant. Our aim for our algorithms is to use as few CPU cycles as possible
to perform their task while retaining strong security guarantees and a small implementation size.
This speed will allow devices to use much fewer CPU cycles than what is currently needed to
ensure the protection of their data. To give one of many very concrete applications of this gain,
the energy demanded by cryptography for a battery-powered microcontroller will be decreased.
In summary, our goal is to provide fast software encryption for all platforms.
Note. The Sparkle family of permutations together with the AEAD instances Schwaemm and
the hash functions Esch is published in the Special Issue of IACR Transactions on Symmetric
Cryptology dedicated to the second-round candidates of the NIST lightweight cryptography standardization process [BBCdS+ 20b].

1.1

What Is This Document?

In this document, we specify the cryptographic hash function family Esch and the authenticated
encryption scheme Schwaemm, submitted to the NIST lightweight cryptography standardization
process.
Together with the specification of the algorithms (Chapter 2), we provide a detailed design
rationale that explains the choice of the overall structure and its internal components (Chapter 3).
Further, we provide a detailed analysis of the security of our schemes with regard to state-of-the art
attacks, and beyond (Chapter 4). Proper design rationale and security analysis are essential parts in
a design proposal as they are necessary for other people to trust cryptographic algorithms. Indeed,
this trust comes from both a proper security analysis and the attention of external cryptographers,
and a document explaining the design choices and trade-offs made is necessary in order to satisfy
either of these conditions. We further provide details on how the algorithms allow for optimized
implementations (Chapter 5).

1.2

What Are Esch and Schwaemm?

Both are cryptographic algorithms that were designed to be lightweight in software (i.e., to have
small code size and low RAM footprint) and still reach high performance on a wide range of 8, 16,
and 32-bit microcontrollers. Section 5.1 gives an overview of software implementation options for
different platforms. Esch and Schwaemm can also be well optimized to achieve small silicon area
and low power consumption when implemented in hardware. Hardware implementation aspects
(including a proposal for a lightweight hardware architecture for the Sparkle permutation) are
discussed in Section 5.2.

1

Our schemes are built from well-understood principles, i.e., the sponge (resp. duplex-sponge)
construction based on a cryptographic permutation, which, for example, the NIST hashing standard
SHA-3 employs as well. Our underlying permutation, Sparkle, follows an ARX construction like
SHA-2 and Chacha/Salsa but, unlike most ARX constructions, we provide security guarantees
with regard to differential and linear cryptanalysis thanks to the long trail strategy (LTS). The
particular structure it imposes is also convenient to investigate other attacks (integral, impossible
differential, etc.) and thus to argue about the security of our algorithms against them. The
LTS is a strategy which was first used to design the lightweight block cipher Sparx, presented
at ASIACRYPT 2016 [DPU+ 16]. Several independent research teams have already analyzed this
algorithm and their results have bolstered our confidence in this design approach. We provide
more details about this strategy and third-party results in Section 3.2.

1.2.1

The Hash Function Esch

A hash function takes a message of arbitrary length and outputs a digest with a fixed length.
It should provide the cryptographic security notions of preimage resistance, second preimage resistance and collision resistance. The main instance of Esch (i.e., the primary member of the
submission for the hash functionality) is Esch256 which produces a 256-bit digest, offering a security level of 128 bits with regard to the above mentioned security goals. It is based on the
permutation family Sparkle384 (see Section 1.3). We also provide the member Esch384 based
on the permutation family Sparkle512, which produces a 384-bit digest and offers a security level
of 192 bits. Both of those hash functions serve as the basis for two Extendable-Output Functions
(XOFs): XOEsch256 and XOEsch384.
The name Esch stands for
Efficient, Sponge-based, and Cheap Hashing.
It is also the part of the name of a small town in southern Luxembourg, which is close to the
campus of the University of Luxembourg. Esch is pronounced ["ES].

1.2.2

The Authenticated Cipher Schwaemm

A scheme for authenticated encryption with associated data (AEAD) takes a key and a nonce of
fixed length, as well as a message and associated data of arbitrary size. The encryption procedure
outputs a ciphertext of the message as well as a fixed-size authentication tag. The decryption
procedure takes the key, nonce, associated data and the ciphertext and tag as input and outputs the
decrypted message if the tag is valid, otherwise a symbolic error ⊥. An AEAD scheme should fulfill
the security notions of confidentiality and integrity. Users must not reuse nonces for processing
messages in a fixed-key instance.
The main instance of Schwaemm (i.e., the primary member of the submission for the AEAD
functionality) is Schwaemm256-128 which takes a 256-bit nonce, a 128-bit key and outputs a
128-bit authentication tag. It achieves a security level of 120 bits with regard to confidentiality
and integrity. We further provide three other instances, i.e., Schwaemm128-128, Schwaemm192192, and Schwaemm256-256 which differ in the length of key, nonce and tag and in the achieved
security level.
The name Schwaemm stands for
Sponge-based Cipher for Hardened but Weightless Authenticated Encryption
on Many Microcontrollers
It is also the Luxembourgish word for “sponges”. Schwaemm is pronounced ["SvEm].

1.3

What Is Sparkle?

It is a family of cryptographic permutations based on an ARX design. Its name comes from the
block cipher Sparx [DPU+ 16], which Sparkle is closely related to. Sparkle is basically a Sparx
instance with a wider block size and a fixed key, hence its name:
2

SPARx, but Key LEss.
We provide three versions corresponding to three block sizes, i.e., Sparkle256, Sparkle384,
and Sparkle512. The number of steps used varies with the use case as our design approach is not
hermetic (see Section 1.4.2).

1.4

What Are Their Key Features?

Both Schwaemm and Esch employ the well-known sponge construction. The underlying Sparkle
family of permutation was designed from scratch, but based on well-known and widely accepted
principles, to achieve high security and high efficiency. The following two subsections give an
overview of the main features of Schwaemm and Esch. A more detailed discussion is provided in
Chapter 5.

1.4.1

What is Their Efficiency Based On?

In the context of cryptographic software, the term efficiency is commonly associated with fast
execution times, low run-time memory (i.e., RAM) requirements, and small code size. However,
these three metrics are mutually exclusive since standard software optimization techniques to
increase performance, such as loop unrolling or the use of look-up tables to speed up certain
operations (e.g., SubBytes in AES), come at the expense of increased code size or increased RAM
footprint or both. On the other hand, a cryptographic hardware implementation is called efficient
when it achieves small silicon area and, depending on the requirements of the target application,
low power consumption, low latency, or high throughput, whereby one of these metrics can be
optimized at the expense of the other(s).
Small State Size. Both Schwaemm and Esch are characterized by a relatively small state size,
which is only 256 bits for the most lightweight instance of Schwaemm described in this document
(achieving a security level of 120 bits) and 384 bits for the lightest variant of Esch. Having a small
state is an important asset for lightweight cryptosystems for several reasons. First and foremost,
the size of the state determines to a large extent the RAM consumption (in the case of software
implementation) and the silicon area (when implemented in hardware) of a symmetric algorithm.
In particular, software implementations for 8 and 16-bit microcontrollers with little register space
(e.g., Atmel AVR or TI MSP430) can profit significantly from a small state size since it allows
a large fraction of the state to reside in registers, which reduces the number of load and store
operations. On 32-bit microcontrollers (e.g., ARM Cortex-M series) it is even possible to keep a
full 256-bit state in registers, thereby eliminating almost all loads and stores. The ability to hold
the whole state in registers does not only benefit execution time, but also provides some intrinsic
protection against side-channel attacks [BDG16]. Finally, since Schwaemm and Esch consist of
very simple arithmetic/logical operations (which are cheap in hardware), the overall silicon area
of a standard-cell implementation is primarily determined by storage required for the state.
Extremely Lightweight Permutation. The Sparkle permutation is a classical ARX design and
performs additions, rotations, and XOR operations on 32-bit words. Using a word-size of 32 bits
enables high efficiency in software on 8, 16, and 32-bit platforms; smaller word-sizes (e.g., 16 bits)
would compromise performance on 32-bit platforms, whereas 64-bit words are problematic for 8bit microcontrollers. The rotation amounts (16, 17, 24, and 31 bits) have been carefully chosen
to minimize the execution time and code size on microcontrollers that support only rotations by
one bit at a time. An implementation of Sparkle for ARM microcontrollers can exploit their
ability to combine an addition or XOR with a rotation into a single instruction with a latency of
one clock cycle. On the other hand, a small-area hardware implementation can take advantage of
the fact that only six arithmetic/logical operations need to be supported: 32-bit XOR, addition
modulo 232 , and rotations by 16, 17, 24, and 31 bits. A minimalist 32-bit Arithmetic/Logic Unit
(ALU) for these six operations can be well optimized to achieve small silicon area and low power
consumption.

3

Consistency Across Security Levels. Schwaemm and Esch were designed to be consistent across
security levels, which facilitates a parameterized software implementation of the algorithms and
the underlying permutation Sparkle. All instances of Schwaemm and Esch can use a single
implementation of Sparkle that is parameterized with respect to the block (i.e., state) size and
the number of steps. Such a parameterized implementation reduces the software development effort
significantly since only a single function for Sparkle needs to be implemented and tested.
Even Higher Speed Through Parallelism. The performance of Schwaemm and Esch on processor platforms with vector engines (e.g., ARM NEON, Intel SSE/AVX) can be significantly increased
by taking advantage of the SIMD-level parallelism they provide, which is possible since all 32-bit
words of the state perform the same operations in the same order. Hardware implementations can
trade performance for silicon area by instantiating several 32-bit ALUs that work in parallel.

1.4.2

What Is Their Security Based On?

We have not traded security for efficiency. Our detailed security finds that our algorithms are safe
from all attacks we are aware of with a comfortable security margin. Overall, the security levels
our primitives provide are on par with those of modern symmetric algorithms but their cost is
lower. Our hash functions are secure against preimage, second preimage and collision search. Our
authenticated cipher provide confidentiality, integrity and authentication.
The Security of Sponges. The security of our schemes is based on the security of the underlying
cryptographic permutations and the security of sponge-based modes, more precisely the spongebased hashing mode and the Beetle mode for authenticated encryption (which is based on a
duplexed sponge). The sponge-based approach has received a lot of attention as it the one used
by the latest NIST-standardized hash function, SHA-3. We re-use this approach to leverage both
its low memory footprint and the confidence cryptographers have gained for such components.
The Literature on Block Cipher Design. The design of the Sparkle family of permutations
is based on the decades old SPN structure which allows us to decompose its analysis into two
stages: first the study of its substitution layer, and, second, the study of its linear layer. The latter
combines the Feistel structure, which has been used since the publication of the DES [DES77],
and a linear permutation with a high branching number, like a vast number of SPNs such as the
AES [AES01]. To combine these two types of subcomponents, we rely on the design strategy that
was used for the block cipher Sparx: the long trail strategy. Our substitution layer operates on
64-bit branches using ARX-based S-boxes, where ARX stands (modular) Addition, Rotation and
XOR. The study of the differential and linear properties of modular addition in the context of block
cipher can be traced back to the late 90’s. The fact that the block size of the ARX component
(the ARX-box, named Alzette1 [BBCdS+ 20a]) is limited to 64 bits means that it is possible to
investigate it thoroughly using computer assisted methods. The simplicity and particular shape of
the linear layer then allows us to deduce the properties of the full permutation from those of the
64-bit ARX-box.
Components Tailored for Their Use Cases. When using a permutation in a mode of operation,
two approaches are possible. We can use a “hermetic” approach (see [BDPVA11, Section 8.1.1]),
meaning that no distinguishers are known to exist against the permutation. This security then
carries over directly to the whole function (e.g. to the whole hash function or AEAD scheme). The
downside in this case is that this hermetic strategy requires an expensive permutation which, in
the context of lightweight cryptography, may be too much.
At the opposite, we can use a permutation which, on its own, cannot provide the properties
needed. The security is then provided by the coupling of the permutation and the mode of operation
in which it is used. For example, the winner of the CAESAR competition Ascon [DEMS16] and
the third-round CAESAR candidate Ketje [BDP+ 16a], both authenticated ciphers, use such an
approach. The advantage in this case is a much higher efficiency as we need fewer rounds of the
1 Alzette is pronounced [alzEt].

4

permutation. However, the security guarantees are a priori weaker in this case as it is harder to
estimate the strength needed by the permutation. It is necessary to carefully assess the security
of the specific permutation used with the knowledge of the mode of operation it is intended for.
For Sparkle (and thus for both Esch and Schwaemm), we use the latter approach: the
permutation used has a number of rounds that may allow the existence of some distinguishers
(in the sense that we do not claim that the permutation behaves like one would expect from a
randomly-drawn permutation). However, using a novel application of the established long trail
strategy, we are able to prove that our algorithms are safe with regard to the most important
attack vectors (differential attacks, i.e., the method used to break SHA-1 [SBK+ 17], and linear
attacks) with a comfortable security margin. We thus get the best of both worlds: we do not
have the performance penalty of a hermetic approach but still obtain security guarantees similar
to those of a hermetic design.

1.4.3

More Security Features

Security under Random Nonces. All instances of Schwaemm, except Schwaemm128-128, permit nonce sizes higher than 192 bits. Therefore, a collision in randomly chosen nonces is not
expected to happen before 292 encryptions are performed. Therefore, the security of the authenticated encryption schemes is not affected when the user employs them with nonces chosen uniformly
at random for each encryption process.2
Integrity Security without Restrictions on the Number of Forgery Attempts. The Beetle
mode of operation allows us to use a small internal state together with a high rate to ensure
integrity security without a birthday-bound restriction on the number of forgery attempts (decryption queries) by the adversary.

2 Since Schwaemm128-128 allows nonces of 128 bits, the same claim on the security under randomly chosen
nonces holds when the number of encryptions is ≪ 264 .

5

2 Specification
For the sake of simplicity, we make no distinction between the sets F𝑎+𝑏
and F𝑎2 × F𝑏2 , we interpret
2
those to be the same. The only difference is that we write elements of the second as tuples, while
the members of the first set are bit strings corresponding to the concatenation of the two elements
in the tuple. The empty bitstring is denoted 𝜖. The algorithms assume the byte order to be
little-endian.
The specification of the Sparkle permutation and of its various instances is given in Section 2.1. Then, we use these permutations to specify the hash functions Esch in Section 2.2 and
the authenticated ciphers Schwaemm in Section 2.3.
We use “+” to denote the addition modulo 232 and ⊕ to denote the XOR of two bitstrings of
the same size.

2.1

The Sparkle Permutations

Our schemes for authenticated encryption and hashing employ the permutation family Sparkle
which we specify in the following. In particular, the Sparkle family consists of the permutations
Sparkle256𝑛𝑠 , Sparkle384𝑛𝑠 and Sparkle512𝑛𝑠 with block sizes of 256, 384, and 512 bit,
respectively. The parameter 𝑛𝑠 refers to the number of steps and a permutation can be defined for
any 𝑛𝑠 ∈ N. The permutations are built using the following main components:
∙ The ARX-box Alzette [BBCdS+ 20a] (shortly denoted 𝐴), i.e., a 64-bit block cipher with a
32-bit key
32
32
32
32
𝐴 : (F32
2 × F2 ) × F2 → (F2 × F2 ), ((𝑥, 𝑦), 𝑐) ↦→ (𝑢, 𝑣) .
32
32
32
We define 𝐴𝑐 to be the permutation (𝑥, 𝑦) ↦→ 𝐴(𝑥, 𝑦, 𝑐) from F32
2 × F2 to F2 × F2 .

𝑏
𝑏
∙ A linear diffusion layer ℒ𝑛𝑏 : F64𝑛
→ F64𝑛
, where 𝑛𝑏 denotes the number of 64-bit branches,
2
2
i.e., the block size divided by 64. It is necessary that 𝑛𝑏 is even.

The high-level structure of the permutations is given in Algorithms 2.1, 2.2 and 2.3, respectively. It is a classical Substitution-Permutation Network (SPN) construction except that functions
playing the role of the S-boxes are different in each branch. More specifically, each member of the
permutation family iterates a parallel application of Alzette under different, branch-dependent,
constants 𝑐𝑖 . This small 64-bit block cipher is specified in Section 2.1.1. It is followed by an
application of ℒ𝑛𝑏 , a linear permutation operating on all branches; it is specified in Section 2.1.2.
We call such a parallel application of Alzette followed by the linear layer a step. The high-level
structure of a step is represented in Figure 2.1. Before each step, a sparse step-dependent constant
is XORed to the cipher’s state (i.e., to 𝑦0 and 𝑦1 ).
A self-contained C implementation of the Sparkle permutation, parameterized by the number
of branches 𝑛𝑏 and the number of steps 𝑛𝑠 , can be found in Appendix A. The implementation
uses a single array named state of type uint32 t that consists of 2𝑛𝑏 elements to represent the
state. More precisely, state[0] = 𝑥0 , state[1] = 𝑦0 , state[2] = 𝑥1 , state[3] = 𝑦1 , . . .
state[2*nb-2] = 𝑥𝑛𝑏 −1 , and state[2*nb-1] = 𝑦𝑛𝑏 −1 . Each 32-bit word contains four state bytes
in little-endian order. More precisely, if (𝑚0 , 𝑚1 , . . . , 𝑚𝑛−1 ) ∈ F𝑛2 , 𝑛 ∈ {256, 384, 512}, is an input
to a Sparkle instance, it is mapped to the state words via state[𝑘] =
𝑚32𝑘+24 ‖𝑚32𝑘+25 ‖ . . . ‖𝑚32𝑘+31 ‖𝑚32𝑘+16 ‖𝑚32𝑘+17 ‖ . . . ‖𝑚32𝑘+23 ‖ . . . ‖𝑚32𝑘 ‖𝑚32𝑘+1 ‖ . . . ‖𝑚32𝑘+7
and the inverse mapping is used for transforming state words back to bitstrings.1
In what follows, we rely on the following definition given below to simplify our descriptions.
1 Note that the indirect injection through ℳ
ℎ𝑏 in Esch also operates on state words. Therefore, the same
mapping of bitstrings to words (and vice versa) is applied.

6

Definition 2.1.1 (Left/Right branches). We call left branches those that correspond to the state
inputs (𝑥0 , 𝑦0 ), (𝑥1 , 𝑦1 ), . . . , (𝑥𝑛𝑏 /2−1 , 𝑦𝑛𝑏 /2−1 ), and we call right branches those corresponding to
(𝑥𝑛𝑏 /2 , 𝑦𝑛𝑏 /2 ), . . . , (𝑥𝑛𝑏 −2 , 𝑦𝑛𝑏 −2 ), (𝑥𝑛𝑏 −1 , 𝑦𝑛𝑏 −1 ).
Algorithm
(︀ 2.1 Sparkle256
)︀ 𝑛𝑠
In/Out: (𝑥0 , 𝑦0 ), ..., (𝑥3 , 𝑦3 ) , 𝑥𝑖 , 𝑦𝑖 ∈ F32
2

Algorithm
(︀ 2.2 Sparkle384
)︀ 𝑛𝑠
In/Out: (𝑥0 , 𝑦0 ), ..., (𝑥5 , 𝑦5 ) , 𝑥𝑖 , 𝑦𝑖 ∈ F32
2

(𝑐0 , 𝑐1 ) ← (0xB7E15162,0xBF715880)
(𝑐2 , 𝑐3 ) ← (0x38B4DA56,0x324E7738)
(𝑐4 , 𝑐5 ) ← (0xBB1185EB,0x4F7C7B57)
(𝑐6 , 𝑐7 ) ← (0xCFBFA1C8,0xC2B3293D)
for all 𝑠 ∈ [0, 𝑛𝑠 − 1] do
𝑦0 ← 𝑦0 ⊕ 𝑐(𝑠 mod 8)
𝑦1 ← 𝑦1 ⊕ (𝑠 mod 232 )
for all 𝑖 ∈ [0, 3] do
(𝑥𝑖 , 𝑦𝑖 ) ← 𝐴𝑐𝑖 (𝑥𝑖 , 𝑦𝑖 )
end
for
(︀
)︀
(︀
)︀
(𝑥0 , 𝑦0 ), ..., (𝑥3 , 𝑦3 ) ← ℒ4 (𝑥0 , 𝑦0 ), ..., (𝑥3 , 𝑦3 )
end for(︀
)︀
return (𝑥0 , 𝑦0 ), ..., (𝑥3 , 𝑦3 )

(𝑐0 , 𝑐1 ) ← (0xB7E15162,0xBF715880)
(𝑐2 , 𝑐3 ) ← (0x38B4DA56,0x324E7738)
(𝑐4 , 𝑐5 ) ← (0xBB1185EB,0x4F7C7B57)
(𝑐6 , 𝑐7 ) ← (0xCFBFA1C8,0xC2B3293D)
for all 𝑠 ∈ [0, 𝑛𝑠 − 1] do
𝑦0 ← 𝑦0 ⊕ 𝑐(𝑠 mod 8)
𝑦1 ← 𝑦1 ⊕ (𝑠 mod 232 )
for all 𝑖 ∈ [0, 5] do
(𝑥𝑖 , 𝑦𝑖 ) ← 𝐴𝑐𝑖 (𝑥𝑖 , 𝑦𝑖 )
end
for
(︀
)︀
(︀
)︀
(𝑥0 , 𝑦0 ), ..., (𝑥5 , 𝑦5 ) ← ℒ6 (𝑥0 , 𝑦0 ), ..., (𝑥5 , 𝑦5 )
end for(︀
)︀
return (𝑥0 , 𝑦0 ), ..., (𝑥5 , 𝑦5 )

Algorithm
(︀ 2.3 Sparkle512
)︀ 𝑛𝑠
32
In/Out: (𝑥0 , 𝑦0 ), ..., (𝑥7 , 𝑦7 ) , 𝑥𝑖 ∈ F32
2 , 𝑦𝑖 ∈ F2
(𝑐0 , 𝑐1 ) ← (0xB7E15162,0xBF715880)
(𝑐2 , 𝑐3 ) ← (0x38B4DA56,0x324E7738)
(𝑐4 , 𝑐5 ) ← (0xBB1185EB,0x4F7C7B57)
(𝑐6 , 𝑐7 ) ← (0xCFBFA1C8,0xC2B3293D)
for all 𝑠 ∈ [0, 𝑛𝑠 − 1] do
𝑦0 ← 𝑦0 ⊕ 𝑐(𝑠 mod 8)
𝑦1 ← 𝑦1 ⊕ (𝑠 mod 232 )
for all 𝑖 ∈ [0, 7] do
(𝑥𝑖 , 𝑦𝑖 ) ← 𝐴𝑐𝑖 (𝑥𝑖 , 𝑦𝑖 )
end
for
(︀
)︀
(︀
)︀
(𝑥0 , 𝑦0 ), ..., (𝑥7 , 𝑦7 ) ← ℒ8 (𝑥0 , 𝑦0 ), ..., (𝑥7 , 𝑦7 )
end for(︀
)︀
return (𝑥0 , 𝑦0 ), ..., (𝑥7 , 𝑦7 )

z0

z1

z2

... zhb −1

zhb

zhb +1

Ac0

Ac1

Ac2

Achb −1

Achb

Achb +1 Achb +2

Mhb

⊕

⊕

zhb +2 ... znb −1
Acnb −1

⊕

⊕

Lnb

...

...

Figure 2.1: The overall structure of a step of Sparkle. 𝑧𝑖 denotes the 64-bit input (𝑥𝑖 , 𝑦𝑖 ) to the
corresponding Alzette instance.

7

Specific Instances. The Sparkle permutations are defined for 4, 6 and 8 branches and for any
number of steps. Unlike in other sponge algorithms such as, e.g., SHA-3, we use two versions of
the permutations which differ only by the number of steps used. More precisely, we use a slim and
a big instance of Sparkle. Our motivation for this difference is given in Section 3.5. The slim
and big versions of all Sparkle instances are given in Table 2.1.
Table 2.1: The different versions of each Sparkle instance.

2.1.1

Name

𝑛

# steps slim

# steps big

Sparkle256
Sparkle384
Sparkle512

256
384
512

7
7
8

10
11
12

The ARX-box Alzette

Alzette, shortly denoted 𝐴, is a 64-bit block cipher. It is specified in Algorithm 2.4 and depicted in
Figure 2.2. It can be understood as a four-round iterated block cipher for which the rounds differ
in the rotation amounts. After each round, the 32-bit constant (i.e., the key) is XORed to the left
word. Note that, as Alzette has a simple Feistel-like structure, the computation of the inverse is
straightforward.
Its purpose is to provide non-linearity to the whole permutation and to ensure a quick diffusion
within each branch—the diffusion between the branches being ensured by the linear layer (Section 2.1.2). Its round constants ensure that the computations in each branch are independent from
one another to break the symmetry of the permutation structure we chose. As the rounds themselves are different (because of different rotation amounts), we do not rely on the round constant
to provide independence between the rounds of Alzette. For more details, we provide a complete
description of the design choices we made when choosing this component in Section 3.3.
Note. After the round-2 submission, we published the design of Alzette together with its design
rationale in [BBCdS+ 20a]. For completeness, we keep the details of the design process of Alzette
in this document.
Algorithm 2.4 𝐴𝑐
32
Input/Output: (𝑥, 𝑦) ∈ F32
2 × F2
𝑥 ← 𝑥 + (𝑦 ≫ 31)
𝑦 ← 𝑦 ⊕ (𝑥 ≫ 24)
𝑥←𝑥⊕𝑐
𝑥 ← 𝑥 + (𝑦 ≫ 17)
𝑦 ← 𝑦 ⊕ (𝑥 ≫ 17)
𝑥←𝑥⊕𝑐
𝑥 ← 𝑥 + (𝑦 ≫ 0)
𝑦 ← 𝑦 ⊕ (𝑥 ≫ 31)
𝑥←𝑥⊕𝑐
𝑥 ← 𝑥 + (𝑦 ≫ 24)
𝑦 ← 𝑦 ⊕ (𝑥 ≫ 16)
𝑥←𝑥⊕𝑐
return (𝑥, 𝑦)

2.1.2

The Diffusion Layer

The diffusion layer has a structure which draws heavily from the one used in Sparx-128 [DPU+ 16].
(︀ )︀ℎ𝑏
We denote it ℒ𝑛𝑏 . It is a Feistel round with a linear Feistel function ℳℎ𝑏 which permutes F64
,
2
where ℎ𝑏 = 𝑛2𝑏 . More formally, ℳℎ𝑏 is defined as follows.
8

y

x
≫ 31
≫ 24

c
≫ 17
≫ 17

c
≫0
≫ 31

c
≫ 24
≫ 16

c
u

v

Figure 2.2: The structure of the Alzette instance 𝐴𝑐 .
𝑤
Definition 2.1.2. Let 𝑤 > 1 be an integer. We denote ℳ𝑤 the permutation of (F32
2 ) such that
(︀
)︀
(︀
)︀
ℳ𝑤 (𝑥0 , 𝑦0 ), . . . , (𝑥𝑤−1 , 𝑦𝑤−1 ) = (𝑢0 , 𝑣0 ), . . . , (𝑢𝑤−1 , 𝑣𝑤−1 )

where the branches (𝑢𝑖 , 𝑣𝑖 ) are obtained via the following equations
𝑡𝑦 ←

𝑤−1
⨁︁
𝑖=0

𝑦𝑖 , 𝑡 𝑥 ←

𝑤−1
⨁︁

𝑥𝑖 ,

𝑖=0

𝑢𝑖 ← 𝑥𝑖 ⊕ ℓ(𝑡𝑦 ), ∀𝑖 ∈ {0, ..., 𝑤 − 1} ,

(2.1)

𝑣𝑖 ← 𝑦𝑖 ⊕ ℓ(𝑡𝑥 ), ∀𝑖 ∈ {0, ..., 𝑤 − 1} ,

32
where the indices are understood modulo 𝑤, and where ℓ : F32
2 → F2 is a permutation defined by

ℓ(𝑥) = (𝑥 ≪ 16) ⊕ (𝑥&0xffff) ,
where 𝑥&𝑦 is a C-style notation denoting the bitwise AND of 𝑥 and 𝑦. Note in particular that, if
32
𝑦 and 𝑧 are in F16
2 so that 𝑦||𝑧 ∈ F2 , then
ℓ(𝑦||𝑧) = 𝑧||(𝑦 ⊕ 𝑧) .
The diffusion layer ℒ𝑛𝑏 then applies the corresponding Feistel function ℳℎ𝑏 and swaps the
left branches with the right branches. However, before the branches are swapped, we rotate the
branches on the right side by 1 branch to the left. This process is pictured in Figure 2.1. Algorithms
describing the three diffusion layers used in our permutations are given in Algorithms 2.5, 2.6
and 2.7. Our rationale for choosing these linear layers is given in Section 3.4.

2.2

The Hash Functions Esch256 and Esch384

2.2.1

Instances

We propose two instances for hashing, i.e., Esch256 and Esch384, which allow to process messages
𝑀 ∈ F*2 of arbitrary length2 and output a digest 𝐷 of bitlengths 256, and 384, respectively. Our
2 More rigorously, all bitlengths under a given (very large) threshold are supported.

9

Algorithm 2.5(︀ ℒ4
)︀
32 4
Input/Output: (𝑥0 , 𝑦0 ), (𝑥1 , 𝑦1 ), (𝑥2 , 𝑦2 ), (𝑥3 , 𝑦3 ) ∈ (F32
2 × F2 )

◁ Feistel round

(︀
(𝑡𝑥 , 𝑡𝑦 ) ← (︀𝑥0 ⊕ 𝑥1 , 𝑦0 ⊕ 𝑦1 )
)︀
(𝑡𝑥 , 𝑡𝑦 ) ← (𝑡𝑥 ⊕ (𝑡𝑥 ≪ 16)) ≪ 16, (𝑡𝑦 ⊕ (𝑡𝑦 ≪ 16)) ≪ 16
(𝑦2 , 𝑦3 ) ← (𝑦2 ⊕ 𝑦0 ⊕ 𝑡𝑥 , 𝑦3 ⊕ 𝑦1 ⊕ 𝑡𝑥 )
(𝑥2 , 𝑥3 ) ← (𝑥2 ⊕ 𝑥0 ⊕ 𝑡𝑦 , 𝑥3 ⊕ 𝑥1 ⊕ 𝑡𝑦 )

◁ Branch permutation

(𝑥0 , 𝑥1 , 𝑥2 , 𝑥3 ) ← (𝑥3 , 𝑥2 , 𝑥0 , 𝑥1 )
(𝑦0 , 𝑦1 , 𝑦(︀2 , 𝑦3 ) ← (𝑦3 , 𝑦2 , 𝑦0 , 𝑦1)︀)
return (𝑥0 , 𝑦0 ), . . . , (𝑥3 , 𝑦3 )
Algorithm 2.6(︀ ℒ6
)︀
32 6
Input/Output: (𝑥0 , 𝑦0 ), . . . , (𝑥5 , 𝑦5 ) ∈ (F32
2 × F2 )

◁ Feistel round

(︀
(𝑡𝑥 , 𝑡𝑦 ) ← (︀𝑥0 ⊕ 𝑥1 ⊕ 𝑥2 , 𝑦0 ⊕ 𝑦1 ⊕ 𝑦2 )
)︀
(𝑡𝑥 , 𝑡𝑦 ) ← (𝑡𝑥 ⊕ (𝑡𝑥 ≪ 16)) ≪ 16, (𝑡𝑦 ⊕ (𝑡𝑦 ≪ 16)) ≪ 16
(𝑦3 , 𝑦4 , 𝑦5 ) ← (𝑦3 ⊕ 𝑦0 ⊕ 𝑡𝑥 , 𝑦4 ⊕ 𝑦1 ⊕ 𝑡𝑥 , 𝑦5 ⊕ 𝑦2 ⊕ 𝑡𝑥 )
(𝑥3 , 𝑥4 , 𝑥5 ) ← (𝑥3 ⊕ 𝑥0 ⊕ 𝑡𝑦 , 𝑥4 ⊕ 𝑥1 ⊕ 𝑡𝑦 , 𝑥5 ⊕ 𝑥2 ⊕ 𝑡𝑦 )

◁ Branch permutation

(𝑥0 , 𝑥1 , 𝑥2 , 𝑥3 , 𝑥4 , 𝑥5 ) ← (𝑥4 , 𝑥5 , 𝑥3 , 𝑥0 , 𝑥1 , 𝑥2 )
(𝑦0 , 𝑦1 , 𝑦(︀2 , 𝑦3 , 𝑦4 , 𝑦5 ) ← (𝑦4 , 𝑦5)︀, 𝑦3 , 𝑦0 , 𝑦1 , 𝑦2 )
return (𝑥0 , 𝑦0 ), . . . , (𝑥5 , 𝑦5 )
Algorithm 2.7(︀ ℒ8
)︀
32 8
Input/Output: (𝑥0 , 𝑦0 ), . . . , (𝑥7 , 𝑦7 ) ∈ (F32
2 × F2 )

◁ Feistel round
(︀
(𝑡𝑥 , 𝑡𝑦 ) ← (︀𝑥0 ⊕ 𝑥1 ⊕ 𝑥2 ⊕ 𝑥3 , 𝑦0 ⊕ 𝑦1 ⊕ 𝑦2 ⊕ 𝑦3 )
)︀
(𝑡𝑥 , 𝑡𝑦 ) ← (𝑡𝑥 ⊕ (𝑡𝑥 ≪ 16)) ≪ 16, (𝑡𝑦 ⊕ (𝑡𝑦 ≪ 16)) ≪ 16
(𝑦4 , 𝑦5 , 𝑦6 , 𝑦7 ) ← (𝑦4 ⊕ 𝑦0 ⊕ 𝑡𝑥 , 𝑦5 ⊕ 𝑦1 ⊕ 𝑡𝑥 , 𝑦6 ⊕ 𝑦2 ⊕ 𝑡𝑥 , 𝑦7 ⊕ 𝑦3 ⊕ 𝑡𝑥 )
(𝑥4 , 𝑥5 , 𝑥6 , 𝑥7 ) ← (𝑥4 ⊕ 𝑥0 ⊕ 𝑡𝑦 , 𝑥5 ⊕ 𝑥1 ⊕ 𝑡𝑦 , 𝑥6 ⊕ 𝑥2 ⊕ 𝑡𝑦 , 𝑥7 ⊕ 𝑥3 ⊕ 𝑡𝑦 )
◁ Branch permutation
(𝑥0 , 𝑥1 , 𝑥2 , 𝑥3 , 𝑥4 , 𝑥5 , 𝑥6 , 𝑥7 ) ← (𝑥5 , 𝑥6 , 𝑥7 , 𝑥4 , 𝑥0 , 𝑥1 , 𝑥2 , 𝑥3 )
(𝑦0 , 𝑦1 , 𝑦(︀2 , 𝑦3 , 𝑦4 , 𝑦5 , 𝑦6 , 𝑦7 ) ←)︀(𝑦5 , 𝑦6 , 𝑦7 , 𝑦4 , 𝑦0 , 𝑦1 , 𝑦2 , 𝑦3 )
return (𝑥0 , 𝑦0 ), . . . , (𝑥7 , 𝑦7 )

primary member for hashing is Esch256. They employ the well-known sponge construction, which
is instantiated with Sparkle permutations and parameterized by the rate 𝑟 and the capacity 𝑐.
The slim version is used during both absorption and squeezing. The big one is used in between
the two phases. Table 2.2 gives an overview of the parameters used in the corresponding sponges.
The maximum length is chosen as 𝑟 × 2𝑐/2 bits, where 𝑐 is both the capacity and the digest size.
Table 2.2: The hashing instances with their security level in bit with regard to collision resistance
and (second) preimage resistance and the limitation on the message size in bytes. For the security
levels of the XOFs, we assume that 𝑡 is smaller than the allowed data limit. The first line refers
to our primary member, i.e. Esch256.
𝑛

𝑟

𝑐

collision

2nd preimage

preimage

data limit (bytes)

Esch256
Esch384

384
512

128
128

256
384

128
192

128
192

128
192

2132
2196

XOEsch256
XOEsch384

384
512

128
128

256
384

min{128, 2𝑡 }
min{192, 2𝑡 }

min{128, 𝑡}
min{192, 𝑡}

min{128, 𝑡}
min{192, 𝑡}

2132
2196

10

2.2.2

Specification of the Hash Functions

In both Esch256 and Esch384, the rate 𝑟 is fixed to 128. This means that the message 𝑀 has
to be padded such that its length in bit becomes a multiple of 128. For this, we use the simple
padding rule that appends 10* . It is formalized in Algorithm 2.8 which describes how a block with
length strictly smaller that 𝑟 is turned into a block of length 𝑟.
Algorithm 2.8 pad𝑟
Input/Output: 𝑀 ∈ F*2 , with |𝑀 | < 𝑟
𝑖 ← (−|𝑀 | − 1) mod 𝑟
𝑀 ← 𝑀 ‖1‖0𝑖
return 𝑀

0

...

192

M3

M3

P0 k064

P1 k064

M3

M3

256

Sparkle3847

Sparkle38411

Sparkle3847

Sparkle3847

192

0

Sparkle3847

The different digest sizes and the corresponding security levels are obtained using different permutation sizes in the sponge, i.e., Sparkle3847 and Sparkle38411 for Esch256 and Sparkle5128
and Sparkle51212 for Esch384. The algorithms are formally specified in Algorithm 2.9 and 2.10
and are depicted in Figure 2.3 and Figure 2.4, respectively. Note that the 128 bits of message
blocks are injected indirectly, i.e., they are first padded with zeros and transformed via ℳ3 in
Esch256, resp., ℳ4 in Esch384, and the resulting image is XORed to the leftmost branches of
the state. We stress that this tweak can still be expressed in the regular sponge mode. Instead
of injecting the messages through ℳℎ𝑏 , one can use an equivalent representation in which the
message is injected as usual and the permutation is defined by prepending ℳℎ𝑏 and appending
ℳ−1
ℎ𝑏 to Sparkle𝑛𝑏 .
For generating the digest, we use the simple truncation function trunc𝑡 which returns the 𝑡
leftmost bits of the internal state.
A message with a length that is a multiple of 𝑟 is not padded. To prevent trivial collisions,
we borrow the technique introduced in [Hir16] and xor ConstM to the inner part, where ConstM is
different depending on whether the message was padded or not.

128

separation

P`−2 k064 (P`−1 k064 )⊕M−1
3 (cM )

D0

D1

Figure 2.3: The Hash Function Esch256 with rate 𝑟 = 128 and capacity 𝑐 = 256. The constant 𝑐𝑀
is equal to (0, 0, . . . , 0, 1) ∈ F192
if the last block was padded and equal to (0, 0, . . . , 0, 1, 0) ∈ F192
2
2
otherwise.

11

0

...

256

M4

M4

P0 k0128

P1 k0128

M4

M4

384

Sparkle5128

Sparkle5128

Sparkle5128

256

0

Sparkle5128

return 𝐷0 ‖𝐷1

◁ Padding the message
if 𝑀 ̸= 𝜖 then
𝑃0 ‖𝑃1 ‖ . . . ‖𝑃ℓ−1 ← 𝑀
with ∀𝑖<ℓ−1 : |𝑃𝑖 |=128 and 1≤|𝑃ℓ−1 |≤128
else
ℓ←1
𝑃0 ← 𝜖
end if
if |𝑃ℓ−1 | < 128 then
𝑃ℓ−1 ← pad128 (𝑃ℓ−1 )
ConstM ← (1 ≪ 256)
else
ConstM ← (2 ≪ 256)
end if
◁ Absorption
𝑆 ← 0 ∈ F512
2
for all 𝑗 = 0, . . . , ℓ − 2 do
𝑃𝑗′ ← ℳ4 (𝑃𝑗 ‖0128 )
(︀
)︀
𝑆 ←Sparkle5128 𝑆 ⊕ (𝑃𝑗′ ‖0256 )
end for
′
𝑃ℓ−1
← ℳ4 (𝑃ℓ−1 ‖0128 )
(︀
)︀
′
𝑆 ←Sparkle51212 𝑆 ⊕ (𝑃ℓ−1
‖0256 ) ⊕ ConstM
◁ Squeezing
𝐷0 ← trunc128 (𝑆) (︀ )︀
𝑆 ← Sparkle5128 𝑆
𝐷1 ← trunc128 (𝑆) (︀ )︀
𝑆 ← Sparkle5128 𝑆
𝐷2 ← trunc128 (𝑆)
return 𝐷0 ‖𝐷1 ‖𝐷2

Sparkle5128

◁ Padding the message
if 𝑀 ̸= 𝜖 then
𝑃0 ‖𝑃1 ‖ . . . ‖𝑃ℓ−1 ← 𝑀
with ∀𝑖<ℓ−1 : |𝑃𝑖 |=128 and 1≤|𝑃ℓ−1 |≤128
else
ℓ←1
𝑃0 ← 𝜖
end if
if |𝑃ℓ−1 | < 128 then
𝑃ℓ−1 ← pad128 (𝑃ℓ−1 )
ConstM ← (1 ≪ 192)
else
ConstM ← (2 ≪ 192)
end if
◁ Absorption
𝑆 ← 0 ∈ F384
2
for all 𝑗 = 0, . . . , ℓ − 2 do
𝑃𝑗′ ← ℳ3 (𝑃𝑗 ‖064 )
(︀
)︀
𝑆 ←Sparkle3847 𝑆 ⊕ (𝑃𝑗′ ‖0192 )
end for
′
𝑃ℓ−1
← ℳ3 (𝑃ℓ−1 ‖064 )
(︀
)︀
′
𝑆 ←Sparkle38411 𝑆 ⊕ (𝑃ℓ−1
‖0192 ) ⊕ ConstM
◁ Squeezing
𝐷0 ← trunc128 (𝑆) (︀ )︀
𝑆 ← Sparkle3847 𝑆
𝐷1 ← trunc128 (𝑆)

Algorithm 2.10 Esch384
Input: 𝑀 ∈ F*2 Output: 𝐷 ∈ F384
2

Sparkle51212

Algorithm 2.9 Esch256
Input: 𝑀 ∈ F*2 Output: 𝐷 ∈ F256
2

128

separation

P`−2 k0128 P`−1 k0128 ⊕M−1
4 (cM )

D0

D1

D2

Figure 2.4: The Hash Function Esch384 with rate 𝑟 = 128 and capacity 𝑐 = 384. The constant 𝑐𝑀
is equal to (0, 0, . . . , 0, 1) ∈ F256
if the last block was padded and equal to (0, 0, . . . , 0, 1, 0) ∈ F256
2
2
otherwise.

2.2.3

The Extendable-Output Functions XOEsch256 and XOEsch384

The hash functions Esch256 and Esch384 can easily be adapted to provide outputs of arbitrary
length. We define the extendable-output functions (XOFs) XOEsch256 and XOEsch384, which
12

are very similar to their hashing counterparts. Besides that other values for the constants ConstM
are used in order to separate between the different use-cases, the only difference is that the XOFs
obtain an additional input parameter 𝑡 which defines the size of the output string. The squeezing phase is extended in order to provide the output of the required length. XOEsch256 and
XOEsch384 are formally described in Algorithms 2.11 and 2.12, respectively. The parameters
and security levels are given in Table 2.2.

Algorithm 2.11 XOEsch256
Input: 𝑀 ∈ F*2 , 𝑡 ∈ N Output: 𝐷 ∈ F𝑡2

◁ Padding the message
if 𝑀 ̸= 𝜖 then
𝑃0 ‖𝑃1 ‖ . . . ‖𝑃ℓ−1 ← 𝑀
with ∀𝑖<ℓ−1 : |𝑃𝑖 |=128 and 1≤|𝑃ℓ−1 |≤128
else
ℓ←1
𝑃0 ← 𝜖
end if
if |𝑃ℓ−1 | < 128 then
𝑃ℓ−1 ← pad128 (𝑃ℓ−1 )
ConstM ← (1 ≪ 192) ⊕ (4 ≪ 192)
else
ConstM ← (2 ≪ 192) ⊕ (4 ≪ 192)
end if
◁ Absorption
𝑆 ← 0 ∈ F384
2
for all 𝑗 = 0, . . . , ℓ − 2 do
𝑃𝑗′ ← ℳ3 (𝑃𝑗 ‖064 )
(︀
)︀
𝑆 ←Sparkle3847 𝑆 ⊕ (𝑃𝑗′ ‖0192 )
end for
′
𝑃ℓ−1
← ℳ3 (𝑃ℓ−1 ‖064 )
(︀
)︀
′
𝑆 ←Sparkle38411 𝑆 ⊕ (𝑃ℓ−1
‖0192 ) ⊕ ConstM
◁ Squeezing
𝐷0 ← trunc128 (𝑆)
for all 𝑗 = 1, . . . , ⌈𝑡/128⌉
(︀ )︀− 1 do
𝑆 ← Sparkle3847 𝑆
𝐷𝑗 ← trunc128 (𝑆)
end for
return trunc𝑡 (𝐷0 ‖𝐷1 ‖ . . . ‖𝐷⌈𝑡/128⌉−1 )

Algorithm 2.12 XOEsch384
Input: 𝑀 ∈ F*2 , 𝑡 ∈ N Output: 𝐷 ∈ F𝑡2

◁ Padding the message
if 𝑀 ̸= 𝜖 then
𝑃0 ‖𝑃1 ‖ . . . ‖𝑃ℓ−1 ← 𝑀
with ∀𝑖<ℓ−1 : |𝑃𝑖 |=128 and 1≤|𝑃ℓ−1 |≤128
else
ℓ←1
𝑃0 ← 𝜖
end if
if |𝑃ℓ−1 | < 128 then
𝑃ℓ−1 ← pad128 (𝑃ℓ−1 )
ConstM ← (1 ≪ 256) ⊕ (4 ≪ 256)
else
ConstM ← (2 ≪ 256) ⊕ (4 ≪ 256)
end if
◁ Absorption
𝑆 ← 0 ∈ F512
2
for all 𝑗 = 0, . . . , ℓ − 2 do
𝑃𝑗′ ← ℳ4 (𝑃𝑗 ‖0128 )
(︀
)︀
𝑆 ←Sparkle5128 𝑆 ⊕ (𝑃𝑗′ ‖0256 )
end for
′
𝑃ℓ−1
← ℳ4 (𝑃ℓ−1 ‖0128 )
(︀
)︀
′
𝑆 ←Sparkle51212 𝑆 ⊕ (𝑃ℓ−1
‖0256 ) ⊕ ConstM
◁ Squeezing
𝐷0 ← trunc128 (𝑆)
for all 𝑗 = 1, . . . , ⌈𝑡/128⌉
(︀ )︀− 1 do
𝑆 ← Sparkle5128 𝑆
𝐷𝑗 ← trunc128 (𝑆)
end for
return trunc𝑡 (𝐷0 ‖𝐷1 ‖ . . . ‖𝐷⌈𝑡/128⌉−1 )

2.3

The Authenticated Cipher Family Schwaemm

2.3.1

Instances

We propose four instances for authenticated encryption with associated data, i.e. Schwaemm128128, Schwaemm256-128, Schwaemm192-192 and Schwaemm256-256 which, for a given key 𝐾
and nonce 𝑁 allow to process associated data 𝐴 and messages 𝑀 of arbitrary length3 and output a
ciphertext 𝐶 with |𝐶| = |𝑀 | and an authentication tag 𝑇 . For given (𝐾, 𝑁, 𝐴, 𝐶, 𝑇 ), the decryption
procedure returns the decryption 𝑀 of 𝐶 if the tag 𝑇 is valid, otherwise it returns the error symbol
⊥. Our primary member of the family is Schwaemm256-128. All instances use (a slight variation
of) the Beetle mode of operation presented in [CDNY18], which is based on the well-known
SpongeWrap AEAD mode [BDPA11]. The difference between the instances is the version of
3 As for the hash function, the length can be chosen arbitrarily but it has do be under thresholds that are given
in Table 2.3.

13

the underlying Sparkle permutation (and thus the rate and capacity is different) and the size of
the authentication tag. As a naming convention, we used Schwaemmr-c, where 𝑟 refers to the
size of the rate and 𝑐 to the size of the capacity in bits. Similar as for hashing, we use the big
version of Sparkle for initialization, separation between processing of associated data and secret
message, and finalization, and the slim version of Sparkle for updating the intermediate state
otherwise. Table 2.3 gives an overview of the parameters of the Schwaemm instances. The data
limits correspond to 264 blocks of 𝑟 bits rounded up to the closest power of two, except for the
high security Schwaemm256-256 for which it is 𝑟 × 2128 bits.
Table 2.3: The instances we provide for authenticated encryption together with their (joint) security
level in bit with regard to confidentiality and integrity and the limitation in the data (in bytes) to
be processed. The first line refers to our primary member, i.e. Schwaemm256-128.
|𝐾|

security

data limit (in bytes)

256
192

|𝑇 |

128
192

120
184

268
268

128

128

128

120

268

256

256

256

248

2133

𝑛

𝑟

𝑐

Schwaemm256-128
Schwaemm192-192

384
384

256
192

128
192

128
192

Schwaemm128-128

256

128

128

Schwaemm256-256

512

256

256

2.3.2

|𝑁 |

The Algorithms

The main difference between the Beetle mode and duplexed sponge modes is the usage of a
combined feedback 𝜌 to differentiate the ciphertext blocks and the outer part of the states. This
combined feedback is created by applying the function FeistelSwap to the outer part of the state,
which is computed as
FeistelSwap(𝑆) = 𝑆2 ‖(𝑆2 ⊕ 𝑆1 ) ,
where 𝑆 ∈ F𝑟2 and 𝑆1 ‖𝑆2 = 𝑆 with |𝑆1 | = |𝑆2 | = 2𝑟 . The feedback function 𝜌 : (F𝑟2 ×F𝑟2 ) → (F𝑟2 ×F𝑟2 )
is defined as 𝜌(𝑆, 𝐷) = (𝜌1 (𝑆, 𝐷), 𝜌2 (𝑆, 𝐷)), where
𝜌1 : (𝑆, 𝐷) ↦→ FeistelSwap(𝑆) ⊕ 𝐷,

𝜌2 : (𝑆, 𝐷) ↦→ 𝑆 ⊕ 𝐷 .

For decryption, we have to use the inverse feedback function 𝜌′ : (F𝑟2 × F𝑟2 ) → (F𝑟2 × F𝑟2 ) defined
as 𝜌′ (𝑆, 𝐷) = (𝜌′1 (𝑆, 𝐷), 𝜌′2 (𝑆, 𝐷)), where
𝜌′1 : (𝑆, 𝐷) ↦→ FeistelSwap(𝑆) ⊕ 𝑆 ⊕ 𝐷,

𝜌′2 : (𝑆, 𝐷) ↦→ 𝑆 ⊕ 𝐷 .

After each application of 𝜌 and the additions of the domain separation constants, i.e., before
each call to the Sparkle permutation except the one for initialization, we prepend a rate whitening
layer which XORs the value of 𝒲𝑐,𝑟 (𝑆𝑅 ) to the outer part, where 𝑆𝑅 denotes the internal state
corresponding to the inner part. For the Schwaemm instances with 𝑟 = 𝑐, we define 𝒲𝑐,𝑟 : F𝑐2 → F𝑟2
as the identity (i.e., we just XOR the inner part to the outer part). For Schwaemm256-128, we
define 𝒲128,256 (𝑥, 𝑦) = (𝑥, 𝑦, 𝑥, 𝑦), where 𝑥, 𝑦 ∈ F64
2 . Note that this tweak can still be described
in the Beetle framework as the prepended rate whitening can be considered to be part of the
definition of the underlying permutation.
Figure 2.5 depicts the mode for our primary member Schwaemm256-128. The formal specifications of the encryption and decryption procedures of the four family members are given in
Algorithms 2.13-2.20.

14

big

ρ

A0

Wc,r

ρ

Wc,r

...

ρ

Sparkle3847

256

Wc,r

Sparkle3847

N

128

Sparkle3847

K

Sparkle38411

ConstA

A`A −2

A1

ρ

A`A −1

ConstM

K

big

M0

C0

M1

ρ

M`M −2 C`M −2

C1

Wc,r

ρ

M`M −1 C`M −1

Sparkle38411

ρ

Wc,r

...

Sparkle3847

ρ

Wc,r

Sparkle3847

Wc,r

Sparkle3847

Wc,r

Sparkle38411

T

big

Figure 2.5: The Authenticated Encryption Algorithm Schwaemm256-128 with rate 𝑟 = 256 and
capacity 𝑐 = 128.

15

Algorithm 2.13 Schwaemm256-128-Enc
Input: (𝐾, 𝑁, 𝐴, 𝑀 ) where 𝐾 ∈ F128
is a key, 𝑁 ∈ F256
is a nonce and 𝐴, 𝑀 ∈ F*2
2
2
*
Output: (𝐶, 𝑇 ), where 𝐶 ∈ F2 is the ciphertext and 𝑇 ∈ F128
is the authentication tag
2

◁ Padding the associated data and message
if 𝐴 ̸= 𝜖 then
𝐴0 ‖𝐴1 ‖ . . . ‖𝐴ℓ𝐴 −1 ← 𝐴 with ∀𝑖 ∈ {0, . . . , ℓ𝐴 − 2} : |𝐴𝑖 | = 256 and 1 ≤ |𝐴ℓ𝐴 −1 | ≤ 256
if |𝐴ℓ𝐴 −1 | < 256 then
𝐴ℓ𝐴 −1 ← pad256 (𝐴ℓ𝐴 −1 )
Const𝐴 ← 0 ⊕ (1 ≪ 2)
else
Const𝐴 ← 1 ⊕ (1 ≪ 2)
end if
end if
if 𝑀 ̸= 𝜖 then
𝑀0 ‖𝑀1 ‖ . . . ‖𝑀ℓ𝑀 −1 ← 𝑀 with ∀𝑖 ∈ {0, . . . , ℓ𝑀 − 2} : |𝑀𝑖 | = 256 and 1 ≤ |𝑀ℓ𝑀 −1 | ≤ 256
𝑡 ← |𝑀ℓ𝑀 −1 |
if |𝑀ℓ𝑀 −1 | < 256 then
𝑀ℓ𝑀 −1 ← pad256 (𝑀ℓ𝑀 −1 )
Const𝑀 ← 2 ⊕ (1 ≪ 2)
else
Const𝑀 ← 3 ⊕ (1 ≪ 2)
end if
end if
◁ State initialization
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle38411 𝑁 ‖𝐾 with |𝑆𝐿 | = 256 and |𝑆𝑅 | = 128
◁ Processing of associated data
if 𝐴 ̸= 𝜖 then
for all 𝑗 = 0, . . . , ℓ𝐴 − 2 do
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle3847 (𝜌1 (𝑆𝐿 , 𝐴𝑗 ) ⊕ 𝒲128,256 (𝑆𝑅 ))‖𝑆𝑅
end for
◁ Finalization if message is empty
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle38411 (𝜌1 (𝑆𝐿 , 𝐴ℓ𝐴 −1 ) ⊕ 𝒲128,256 (𝑆𝑅 ⊕ Const𝐴 ))‖(𝑆𝑅 ⊕ Const𝐴 )
end if
◁ Encrypting
if 𝑀 ̸= 𝜖 then
for all 𝑗 = 0, . . . , ℓ𝑀 − 2 do
𝐶𝑗 ← 𝜌2 (𝑆𝐿 , 𝑀𝑗 )
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle3847 (𝜌1 (𝑆𝐿 , 𝑀𝑗 ) ⊕ 𝒲128,256 (𝑆𝑅 ))‖𝑆𝑅
end for
(︀
)︀
𝐶ℓ𝑀 −1 ← trunc𝑡 𝜌2 (𝑆𝐿 , 𝑀ℓ𝑀 −1 )
◁ Finalization
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle38411 (𝜌1 (𝑆𝐿 , 𝑀ℓ𝑀 −1 ) ⊕ 𝒲128,256 (𝑆𝑅 ⊕ Const𝑀 ))‖(𝑆𝑅 ⊕ Const𝑀 )
end if
return (𝐶0 ‖𝐶1 ‖ . . . ‖𝐶ℓ𝑀 −1 , 𝑆𝑅 ⊕ 𝐾)

16

Algorithm 2.14 Schwaemm256-128-Dec
Input: (𝐾, 𝑁, 𝐴, 𝐶, 𝑇 ) where 𝐾 ∈ F128
is a key, 𝑁 ∈ F256
is a nonce, 𝐴, 𝐶 ∈ F*2 and 𝑇 ∈ F128
2
2
2
Output: Decryption 𝑀 of 𝐶 if the tag 𝑇 is valid, ⊥ otherwise

if 𝐴 ̸= 𝜖 then
𝐴0 ‖𝐴1 ‖ . . . ‖𝐴ℓ𝐴 −1 ← 𝐴 with ∀𝑖 ∈ {0, . . . , ℓ𝐴 − 2} : |𝐴𝑖 | = 256 and 1 ≤ |𝐴ℓ𝐴 −1 | ≤ 256
if |𝐴ℓ𝐴 −1 | < 256 then
𝐴ℓ𝐴 −1 ← pad256 (𝐴ℓ𝐴 −1 )
Const𝐴 ← 0 ⊕ (1 ≪ 2)
else
Const𝐴 ← 1 ⊕ (1 ≪ 2)
end if
end if
if 𝐶 ̸= 𝜖 then
𝐶0 ‖𝐶1 ‖ . . . ‖𝐶ℓ𝑀 −1 ← 𝐶 with ∀𝑖 ∈ {0, . . . , ℓ𝑀 − 2} : |𝐶𝑖 | = 256 and 1 ≤ |𝐶ℓ𝑀 −1 | ≤ 256
𝑡 ← |𝐶ℓ𝑀 −1 |
if |𝐶ℓ𝑀 −1 | < 256 then
𝐶ℓ𝑀 −1 ← pad256 (𝐶ℓ𝑀 −1 )
Const𝑀 ← 2 ⊕ (1 ≪ 2)
else
Const𝑀 ← 3 ⊕ (1 ≪ 2)
end if
end if
◁ State initialization
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle38411 𝑁 ‖𝐾 with |𝑆𝐿 | = 256 and |𝑆𝑅 | = 128
◁ Processing of associated data
if 𝐴 ̸= 𝜖 then
for all 𝑗 = 0, . . . , ℓ𝐴 − 2 do
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle3847 (𝜌1 (𝑆𝐿 , 𝐴𝑗 ) ⊕ 𝒲128,256 (𝑆𝑅 ))‖𝑆𝑅
end for
◁ Finalization if ciphertext is empty
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle38411 (𝜌1 (𝑆𝐿 , 𝐴ℓ𝐴 −1 ) ⊕ 𝒲128,256 (𝑆𝑅 ⊕ Const𝐴 ))‖(𝑆𝑅 ⊕ Const𝐴 )
end if
◁ Decrypting
if 𝐶 ̸= 𝜖 then
for all 𝑗 = 0, . . . , ℓ𝑀 − 2 do
𝑀𝑗 ← 𝜌′2 (𝑆𝐿 , 𝐶𝑗 )
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle3847 (𝜌′1 (𝑆𝐿 , 𝐶𝑗 ) ⊕ 𝒲128,256 (𝑆𝑅 ))‖𝑆𝑅
end for
(︀
)︀
𝑀ℓ𝑀 −1 ← trunc𝑡 𝜌′2 (𝑆𝐿 , 𝐶ℓ𝑀 −1 )
◁ Finalization and tag verification
if 𝑡 < 256 then
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle38411 (𝜌1 (𝑆𝐿 , pad256 (𝑀ℓ𝑀 −1 )) ⊕ 𝒲128,256 (𝑆𝑅 ⊕ Const𝑀 ))‖(𝑆𝑅 ⊕ Const𝑀 )
else
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle38411 (𝜌′1 (𝑆𝐿 , 𝐶ℓ𝑀 −1 ) ⊕ 𝒲128,256 (𝑆𝑅 ⊕ Const𝑀 ))‖(𝑆𝑅 ⊕ Const𝑀 )
end if
end if
if 𝑆𝑅 ⊕ 𝐾 = 𝑇 then
return (𝑀0 ‖𝑀1 ‖ . . . ‖𝑀ℓ𝑀 −1 )
else
return ⊥
end if

17

Algorithm 2.15 Schwaemm192-192-Enc
Input: (𝐾, 𝑁, 𝐴, 𝑀 ) where 𝐾 ∈ F192
is a key, 𝑁 ∈ F192
is a nonce and 𝐴, 𝑀 ∈ F*2
2
2
*
Output: (𝐶, 𝑇 ), where 𝐶 ∈ F2 is the ciphertext and 𝑇 ∈ F192
is the authentication tag
2

◁ Padding the associated data and message
if 𝐴 ̸= 𝜖 then
𝐴0 ‖𝐴1 ‖ . . . ‖𝐴ℓ𝐴 −1 ← 𝐴 with ∀𝑖 ∈ {0, . . . , ℓ𝐴 − 2} : |𝐴𝑖 | = 192 and 1 ≤ |𝐴ℓ𝐴 −1 | ≤ 192
if |𝐴ℓ𝐴 −1 | < 192 then
𝐴ℓ𝐴 −1 ← pad192 (𝐴ℓ𝐴 −1 )
Const𝐴 ← 0 ⊕ (1 ≪ 3)
else
Const𝐴 ← 1 ⊕ (1 ≪ 3)
end if
end if
if 𝑀 ̸= 𝜖 then
𝑀0 ‖𝑀1 ‖ . . . ‖𝑀ℓ𝑀 −1 ← 𝑀 with ∀𝑖 ∈ {0, . . . , ℓ𝑀 − 2} : |𝑀𝑖 | = 192 and 1 ≤ |𝑀ℓ𝑀 −1 | ≤ 192
𝑡 ← |𝑀ℓ𝑀 −1 |
if |𝑀ℓ𝑀 −1 | < 192 then
𝑀ℓ𝑀 −1 ← pad192 (𝑀ℓ𝑀 −1 )
Const𝑀 ← 2 ⊕ (1 ≪ 3)
else
Const𝑀 ← 3 ⊕ (1 ≪ 3)
end if
end if
◁ State initialization
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle38411 𝑁 ‖𝐾 with |𝑆𝐿 | = 192 and |𝑆𝑅 | = 192
◁ Processing of associated data
if 𝐴 ̸= 𝜖 then
for all 𝑗 = 0, . . . , ℓ𝐴 − 2 do(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle3847 (𝜌1 (𝑆𝐿 , 𝐴𝑗 ) ⊕ 𝑆𝑅 )‖𝑆𝑅
end for
◁ Finalization if)︀ message is empty
(︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle38411 (𝜌1 (𝑆𝐿 , 𝐴ℓ𝐴 −1 ) ⊕ 𝑆𝑅 ⊕ Const𝐴 )‖(𝑆𝑅 ⊕ Const𝐴 )
end if
◁ Encrypting
if 𝑀 ̸= 𝜖 then
for all 𝑗 = 0, . . . , ℓ𝑀 − 2 do
𝐶𝑗 ← 𝜌2 (𝑆𝐿 , 𝑀𝑗 )
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle3847 (𝜌1 (𝑆𝐿 , 𝑀𝑗 ) ⊕ 𝑆𝑅 )‖𝑆𝑅
end for
(︀
)︀
𝐶ℓ𝑀 −1 ← trunc𝑡 𝜌2 (𝑆𝐿 , 𝑀ℓ𝑀 −1 )
(︀
)︀ ◁ Finalization
𝑆𝐿 ‖𝑆𝑅 ← Sparkle38411 (𝜌1 (𝑆𝐿 , 𝑀ℓ𝑀 −1 ) ⊕ 𝑆𝑅 ⊕ Const𝑀 )‖(𝑆𝑅 ⊕ Const𝑀 )
end if
return (𝐶0 ‖𝐶1 ‖ . . . ‖𝐶ℓ𝑀 −1 , 𝑆𝑅 ⊕ 𝐾)

18

Algorithm 2.16 Schwaemm192-192-Dec
Input: (𝐾, 𝑁, 𝐴, 𝐶, 𝑇 ) where 𝐾 ∈ F192
is a key, 𝑁 ∈ F192
is a nonce, 𝐴, 𝐶 ∈ F*2 and 𝑇 ∈ F192
2
2
2
Output: Decryption 𝑀 of 𝐶 if the tag 𝑇 is valid, ⊥ otherwise

if 𝐴 ̸= 𝜖 then
𝐴0 ‖𝐴1 ‖ . . . ‖𝐴ℓ𝐴 −1 ← 𝐴 with ∀𝑖 ∈ {0, . . . , ℓ𝐴 − 2} : |𝐴𝑖 | = 192 and 1 ≤ |𝐴ℓ𝐴 −1 | ≤ 192
if |𝐴ℓ𝐴 −1 | < 192 then
𝐴ℓ𝐴 −1 ← pad192 (𝐴ℓ𝐴 −1 )
Const𝐴 ← 0 ⊕ (1 ≪ 3)
else
Const𝐴 ← 1 ⊕ (1 ≪ 3)
end if
end if
if 𝐶 ̸= 𝜖 then
𝐶0 ‖𝐶1 ‖ . . . ‖𝐶ℓ𝑀 −1 ← 𝐶 with ∀𝑖 ∈ {0, . . . , ℓ𝑀 − 2} : |𝐶𝑖 | = 192 and 1 ≤ |𝐶ℓ𝑀 −1 | ≤ 192
𝑡 ← |𝐶ℓ𝑀 −1 |
if |𝐶ℓ𝑀 −1 | < 192 then
𝐶ℓ𝑀 −1 ← pad192 (𝐶ℓ𝑀 −1 )
Const𝑀 ← 2 ⊕ (1 ≪ 3)
else
Const𝑀 ← 3 ⊕ (1 ≪ 3)
end if
end if
◁ State initialization
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle38411 𝑁 ‖𝐾 with |𝑆𝐿 | = 192 and |𝑆𝑅 | = 192
◁ Processing of associated data
if 𝐴 ̸= 𝜖 then
for all 𝑗 = 0, . . . , ℓ𝐴 − 2 do(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle3847 (𝜌1 (𝑆𝐿 , 𝐴𝑗 ) ⊕ 𝑆𝑅 )‖𝑆𝑅
end for
◁ Finalization if ciphertext
is empty
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle38411 (𝜌1 (𝑆𝐿 , 𝐴ℓ𝐴 −1 ) ⊕ 𝑆𝑅 ⊕ Const𝐴 )‖(𝑆𝑅 ⊕ Const𝐴 )
end if
◁ Decrypting
if 𝐶 ̸= 𝜖 then
for all 𝑗 = 0, . . . , ℓ𝑀 − 2 do
𝑀𝑗 ← 𝜌′2 (𝑆𝐿 , 𝐶𝑗 )
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle3847 (𝜌′1 (𝑆𝐿 , 𝐶𝑗 ) ⊕ 𝑆𝑅 )‖𝑆𝑅
end for
(︀
)︀
𝑀ℓ𝑀 −1 ← trunc𝑡 𝜌′2 (𝑆𝐿 , 𝐶ℓ𝑀 −1 )
◁ Finalization and tag verification
if 𝑡 < 192 then
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle38411 (𝜌1 (𝑆𝐿 , pad192 (𝑀ℓ𝑀 −1 )) ⊕ 𝑆𝑅 ⊕ Const𝑀 )‖(𝑆𝑅 ⊕ Const𝑀 )
else
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle38411 (𝜌′1 (𝑆𝐿 , 𝐶ℓ𝑀 −1 ) ⊕ 𝑆𝑅 ⊕ Const𝑀 )‖(𝑆𝑅 ⊕ Const𝑀 )
end if
end if
if 𝑆𝑅 ⊕ 𝐾 = 𝑇 then
return (𝑀0 ‖𝑀1 ‖ . . . ‖𝑀ℓ𝑀 −1 )
else
return ⊥
end if

19

Algorithm 2.17 Schwaemm128-128-Enc
Input: (𝐾, 𝑁, 𝐴, 𝑀 ) where 𝐾 ∈ F128
is a key, 𝑁 ∈ F128
is a nonce and 𝐴, 𝑀 ∈ F*2
2
2
*
Output: (𝐶, 𝑇 ), where 𝐶 ∈ F2 is the ciphertext and 𝑇 ∈ F128
is the authentication tag
2

◁ Padding the associated data and message
if 𝐴 ̸= 𝜖 then
𝐴0 ‖𝐴1 ‖ . . . ‖𝐴ℓ𝐴 −1 ← 𝐴 with ∀𝑖 ∈ {0, . . . , ℓ𝐴 − 2} : |𝐴𝑖 | = 128 and 1 ≤ |𝐴ℓ𝐴 −1 | ≤ 128
if |𝐴ℓ𝐴 −1 | < 128 then
𝐴ℓ𝐴 −1 ← pad128 (𝐴ℓ𝐴 −1 )
Const𝐴 ← 0 ⊕ (1 ≪ 2)
else
Const𝐴 ← 1 ⊕ (1 ≪ 2)
end if
end if
if 𝑀 ̸= 𝜖 then
𝑀0 ‖𝑀1 ‖ . . . ‖𝑀ℓ𝑀 −1 ← 𝑀 with ∀𝑖 ∈ {0, . . . , ℓ𝑀 − 2} : |𝑀𝑖 | = 128 and 1 ≤ |𝑀ℓ𝑀 −1 | ≤ 128
𝑡 ← |𝑀ℓ𝑀 −1 |
if |𝑀ℓ𝑀 −1 | < 128 then
𝑀ℓ𝑀 −1 ← pad128 (𝑀ℓ𝑀 −1 )
Const𝑀 ← 2 ⊕ (1 ≪ 2)
else
Const𝑀 ← 3 ⊕ (1 ≪ 2)
end if
end if
◁ State initialization
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle25610 𝑁 ‖𝐾 with |𝑆𝐿 | = 128 and |𝑆𝑅 | = 128
◁ Processing of associated data
if 𝐴 ̸= 𝜖 then
for all 𝑗 = 0, . . . , ℓ𝐴 − 2 do(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle2567 (𝜌1 (𝑆𝐿 , 𝐴𝑗 ) ⊕ 𝑆𝑅 )‖𝑆𝑅
end for
◁ Finalization if)︀ message is empty
(︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle25610 (𝜌1 (𝑆𝐿 , 𝐴ℓ𝐴 −1 ) ⊕ 𝑆𝑅 ⊕ Const𝐴 )‖(𝑆𝑅 ⊕ Const𝐴 )
end if
◁ Encrypting
if 𝑀 ̸= 𝜖 then
for all 𝑗 = 0, . . . , ℓ𝑀 − 2 do
𝐶𝑗 ← 𝜌2 (𝑆𝐿 , 𝑀𝑗 )
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle2567 (𝜌1 (𝑆𝐿 , 𝑀𝑗 ) ⊕ 𝑆𝑅 )‖𝑆𝑅
end for
(︀
)︀
𝐶ℓ𝑀 −1 ← trunc𝑡 𝜌2 (𝑆𝐿 , 𝑀ℓ𝑀 −1 )
(︀
)︀ ◁ Finalization
𝑆𝐿 ‖𝑆𝑅 ← Sparkle25610 (𝜌1 (𝑆𝐿 , 𝑀ℓ𝑀 −1 ) ⊕ 𝑆𝑅 ⊕ Const𝑀 )‖(𝑆𝑅 ⊕ Const𝑀 )
end if
return (𝐶0 ‖𝐶1 ‖ . . . ‖𝐶ℓ𝑀 −1 , 𝑆𝑅 ⊕ 𝐾)

20

Algorithm 2.18 Schwaemm128-128-Dec
Input: (𝐾, 𝑁, 𝐴, 𝐶, 𝑇 ) where 𝐾 ∈ F128
is a key, 𝑁 ∈ F128
is a nonce, 𝐴, 𝐶 ∈ F*2 and 𝑇 ∈ F128
2
2
2
Output: Decryption 𝑀 of 𝐶 if the tag 𝑇 is valid, ⊥ otherwise

if 𝐴 ̸= 𝜖 then
𝐴0 ‖𝐴1 ‖ . . . ‖𝐴ℓ𝐴 −1 ← 𝐴 with ∀𝑖 ∈ {0, . . . , ℓ𝐴 − 2} : |𝐴𝑖 | = 128 and 1 ≤ |𝐴ℓ𝐴 −1 | ≤ 128
if |𝐴ℓ𝐴 −1 | < 128 then
𝐴ℓ𝐴 −1 ← pad128 (𝐴ℓ𝐴 −1 )
Const𝐴 ← 0 ⊕ (1 ≪ 2)
else
Const𝐴 ← 1 ⊕ (1 ≪ 2)
end if
end if
if 𝐶 ̸= 𝜖 then
𝐶0 ‖𝐶1 ‖ . . . ‖𝐶ℓ𝑀 −1 ← 𝐶 with ∀𝑖 ∈ {0, . . . , ℓ𝑀 − 2} : |𝐶𝑖 | = 128 and 1 ≤ |𝐶ℓ𝑀 −1 | ≤ 128
𝑡 ← |𝐶ℓ𝑀 −1 |
if |𝐶ℓ𝑀 −1 | < 128 then
𝐶ℓ𝑀 −1 ← pad128 (𝐶ℓ𝑀 −1 )
Const𝑀 ← 2 ⊕ (1 ≪ 2)
else
Const𝑀 ← 3 ⊕ (1 ≪ 2)
end if
end if
◁ State initialization
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle25610 𝑁 ‖𝐾 with |𝑆𝐿 | = 128 and |𝑆𝑅 | = 128
◁ Processing of associated data
if 𝐴 ̸= 𝜖 then
for all 𝑗 = 0, . . . , ℓ𝐴 − 2 do(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle2567 (𝜌1 (𝑆𝐿 , 𝐴𝑗 ) ⊕ 𝑆𝑅 )‖𝑆𝑅
end for
◁ Finalization if ciphertext
is empty
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle25610 (𝜌1 (𝑆𝐿 , 𝐴ℓ𝐴 −1 ) ⊕ 𝑆𝑅 ⊕ Const𝐴 )‖(𝑆𝑅 ⊕ Const𝐴 )
end if
◁ Decrypting
if 𝐶 ̸= 𝜖 then
for all 𝑗 = 0, . . . , ℓ𝑀 − 2 do
𝑀𝑗 ← 𝜌′2 (𝑆𝐿 , 𝐶𝑗 )
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle2567 (𝜌′1 (𝑆𝐿 , 𝐶𝑗 ) ⊕ 𝑆𝑅 )‖𝑆𝑅
end for
(︀
)︀
𝑀ℓ𝑀 −1 ← trunc𝑡 𝜌′2 (𝑆𝐿 , 𝐶ℓ𝑀 −1 )
◁ Finalization and tag verification
if 𝑡 < 128 then
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle25610 (𝜌1 (𝑆𝐿 , pad128 (𝑀ℓ𝑀 −1 )) ⊕ 𝑆𝑅 ⊕ Const𝑀 )‖(𝑆𝑅 ⊕ Const𝑀 )
else
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle25610 (𝜌′1 (𝑆𝐿 , 𝐶ℓ𝑀 −1 ) ⊕ 𝑆𝑅 ⊕ Const𝑀 )‖(𝑆𝑅 ⊕ Const𝑀 )
end if
end if
if 𝑆𝑅 ⊕ 𝐾 = 𝑇 then
return (𝑀0 ‖𝑀1 ‖ . . . ‖𝑀ℓ𝑀 −1 )
else
return ⊥
end if

21

Algorithm 2.19 Schwaemm256-256-Enc
Input: (𝐾, 𝑁, 𝐴, 𝑀 ) where 𝐾 ∈ F256
is a key, 𝑁 ∈ F256
is a nonce and 𝐴, 𝑀 ∈ F*2
2
2
*
Output: (𝐶, 𝑇 ), where 𝐶 ∈ F2 is the ciphertext and 𝑇 ∈ F256
is the authentication tag
2

◁ Padding the associated data and message
if 𝐴 ̸= 𝜖 then
𝐴0 ‖𝐴1 ‖ . . . ‖𝐴ℓ𝐴 −1 ← 𝐴 with ∀𝑖 ∈ {0, . . . , ℓ𝐴 − 2} : |𝐴𝑖 | = 256 and 1 ≤ |𝐴ℓ𝐴 −1 | ≤ 256
if |𝐴ℓ𝐴 −1 | < 256 then
𝐴ℓ𝐴 −1 ← pad256 (𝐴ℓ𝐴 −1 )
Const𝐴 ← 0 ⊕ (1 ≪ 4)
else
Const𝐴 ← 1 ⊕ (1 ≪ 4)
end if
end if
if 𝑀 ̸= 𝜖 then
𝑀0 ‖𝑀1 ‖ . . . ‖𝑀ℓ𝑀 −1 ← 𝑀 with ∀𝑖 ∈ {0, . . . , ℓ𝑀 − 2} : |𝑀𝑖 | = 256 and 1 ≤ |𝑀ℓ𝑀 −1 | ≤ 256
𝑡 ← |𝑀ℓ𝑀 −1 |
if |𝑀ℓ𝑀 −1 | < 256 then
𝑀ℓ𝑀 −1 ← pad256 (𝑀ℓ𝑀 −1 )
Const𝑀 ← 2 ⊕ (1 ≪ 4)
else
Const𝑀 ← 3 ⊕ (1 ≪ 4)
end if
end if
◁ State initialization
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle51212 𝑁 ‖𝐾 with |𝑆𝐿 | = 256 and |𝑆𝑅 | = 256
◁ Processing of associated data
if 𝐴 ̸= 𝜖 then
for all 𝑗 = 0, . . . , ℓ𝐴 − 2 do(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle5128 (𝜌1 (𝑆𝐿 , 𝐴𝑗 ) ⊕ 𝑆𝑅 )‖𝑆𝑅
end for
◁ Finalization if)︀ message is empty
(︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle51212 (𝜌1 (𝑆𝐿 , 𝐴ℓ𝐴 −1 ) ⊕ 𝑆𝑅 ⊕ Const𝐴 )‖(𝑆𝑅 ⊕ Const𝐴 )
end if
◁ Encrypting
if 𝑀 ̸= 𝜖 then
for all 𝑗 = 0, . . . , ℓ𝑀 − 2 do
𝐶𝑗 ← 𝜌2 (𝑆𝐿 , 𝑀𝑗 )
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle5128 (𝜌1 (𝑆𝐿 , 𝑀𝑗 ) ⊕ 𝑆𝑅 )‖𝑆𝑅
end for
(︀
)︀
𝐶ℓ𝑀 −1 ← trunc𝑡 𝜌2 (𝑆𝐿 , 𝑀ℓ𝑀 −1 )
(︀
)︀ ◁ Finalization
𝑆𝐿 ‖𝑆𝑅 ← Sparkle51212 (𝜌1 (𝑆𝐿 , 𝑀ℓ𝑀 −1 ) ⊕ 𝑆𝑅 ⊕ Const𝑀 )‖(𝑆𝑅 ⊕ Const𝑀 )
end if
return (𝐶0 ‖𝐶1 ‖ . . . ‖𝐶ℓ𝑀 −1 , 𝑆𝑅 ⊕ 𝐾)

22

Algorithm 2.20 Schwaemm256-256-Dec
Input: (𝐾, 𝑁, 𝐴, 𝐶, 𝑇 ) where 𝐾 ∈ F256
is a key, 𝑁 ∈ F256
is a nonce, 𝐴, 𝐶 ∈ F*2 and 𝑇 ∈ F256
2
2
2
Output: Decryption 𝑀 of 𝐶 if the tag 𝑇 is valid, ⊥ otherwise

if 𝐴 ̸= 𝜖 then
𝐴0 ‖𝐴1 ‖ . . . ‖𝐴ℓ𝐴 −1 ← 𝐴 with ∀𝑖 ∈ {0, . . . , ℓ𝐴 − 2} : |𝐴𝑖 | = 256 and 1 ≤ |𝐴ℓ𝐴 −1 | ≤ 256
if |𝐴ℓ𝐴 −1 | < 256 then
𝐴ℓ𝐴 −1 ← pad256 (𝐴ℓ𝐴 −1 )
Const𝐴 ← 0 ⊕ (1 ≪ 4)
else
Const𝐴 ← 1 ⊕ (1 ≪ 4)
end if
end if
if 𝐶 ̸= 𝜖 then
𝐶0 ‖𝐶1 ‖ . . . ‖𝐶ℓ𝑀 −1 ← 𝐶 with ∀𝑖 ∈ {0, . . . , ℓ𝑀 − 2} : |𝐶𝑖 | = 256 and 1 ≤ |𝐶ℓ𝑀 −1 | ≤ 256
𝑡 ← |𝐶ℓ𝑀 −1 |
if |𝐶ℓ𝑀 −1 | < 256 then
𝐶ℓ𝑀 −1 ← pad256 (𝐶ℓ𝑀 −1 )
Const𝑀 ← 2 ⊕ (1 ≪ 4)
else
Const𝑀 ← 3 ⊕ (1 ≪ 4)
end if
end if
◁ State initialization
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle51212 𝑁 ‖𝐾 with |𝑆𝐿 | = 256 and |𝑆𝑅 | = 256
◁ Processing of associated data
if 𝐴 ̸= 𝜖 then
for all 𝑗 = 0, . . . , ℓ𝐴 − 2 do(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle5128 (𝜌1 (𝑆𝐿 , 𝐴𝑗 ) ⊕ 𝑆𝑅 )‖𝑆𝑅
end for
◁ Finalization if ciphertext
is empty
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle51212 (𝜌1 (𝑆𝐿 , 𝐴ℓ𝐴 −1 ) ⊕ 𝑆𝑅 ⊕ Const𝐴 )‖(𝑆𝑅 ⊕ Const𝐴 )
end if
◁ Decrypting
if 𝐶 ̸= 𝜖 then
for all 𝑗 = 0, . . . , ℓ𝑀 − 2 do
𝑀𝑗 ← 𝜌′2 (𝑆𝐿 , 𝐶𝑗 )
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle5128 (𝜌′1 (𝑆𝐿 , 𝐶𝑗 ) ⊕ 𝑆𝑅 )‖𝑆𝑅
end for
(︀
)︀
𝑀ℓ𝑀 −1 ← trunc𝑡 𝜌′2 (𝑆𝐿 , 𝐶ℓ𝑀 −1 )
◁ Finalization and tag verification
if 𝑡 < 256 then
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle51212 (𝜌1 (𝑆𝐿 , pad256 (𝑀ℓ𝑀 −1 )) ⊕ 𝑆𝑅 ⊕ Const𝑀 )‖(𝑆𝑅 ⊕ Const𝑀 )
else
(︀
)︀
𝑆𝐿 ‖𝑆𝑅 ← Sparkle51212 (𝜌′1 (𝑆𝐿 , 𝐶ℓ𝑀 −1 ) ⊕ 𝑆𝑅 ⊕ Const𝑀 )‖(𝑆𝑅 ⊕ Const𝑀 )
end if
end if
if 𝑆𝑅 ⊕ 𝐾 = 𝑇 then
return (𝑀0 ‖𝑀1 ‖ . . . ‖𝑀ℓ𝑀 −1 )
else
return ⊥
end if

23

2.4

Recommendations for Joint Evaluation

We recommend the joint evaluation of the AEAD and hashing schemes that use the same Sparkle
version as the underlying permutation. The particular pairings are shown in Table 2.4. Note that
we do not pair Schwaemm128-128 with a hashing algorithm as we did not specify a member of
the Esch family that employs Sparkle256.
Table 2.4: Recommendations for joint evaluation of Esch and Schwaemm. The first pairing refers
to the primary member of both functionalities.
Hashing

AEAD

based on

Esch256
Esch256

Schwaemm256-128
Schwaemm192-192

Sparkle384
Sparkle384

Esch384

Schwaemm256-256

Sparkle512

–

Schwaemm128-128

Sparkle256

24

3 Design Rationale
In this chapter, we explain why and how we chose the various components of our algorithms. First,
we justify the choice of a sponge construction (Section 3.1). Then, we present the motivation
behind the overall structure of the permutation in Section 3.2. In particular, we recall the Long
Trail Strategy (LTS) as it was introduced in the design of Sparx [DPU+ 16] and explain how it
can be adapted to design sponges that are not hermetic but retain very strong security guarantees.
Finally, we describe the rationale behind the choice of our two main subcomponents: the ARXbox Alzette (Section 3.3) and the linear layer (Section 3.4). The section will be concluded by a
statement on the number of steps used in the permutations (Section 3.5).
Remark on the Notion of a Distinguisher By specifying a fixed cryptographic permutation,
i.e., Sparkle, generic distinguishers that distinguish the permutation from a random one trivially
exist. For instance, take the property that the Sparkle family can be described by a single page
of C code, which is not expected to happen for a randomly chosen permutation. When using the
term distinguisher throughout this document, we actually refer to structural distinguishers. In a
nutshell, a structural distinguisher allows to obtain information about the internal structure of
the permutation or the ability to reverse-engineer it given (a reasonable) number of input-output
pairs. Such distinguishers include differential and linear attacks, integral attacks, meet-in-the
middle attacks or attacks based on symmetries.

3.1

The Sponge Structure

We decided to use the well-known sponge construction [BDPVA07, BDPVA11] based on a cryptographic permutation. We explain the reasoning behind this decision in this section.

3.1.1

Permutation Versus (Tweakable) Block Cipher

As the aim is to provide authenticated ciphers and hash functions, two broad approaches exist:
one based on (tweakable) block ciphers and the sponge structure. Compared to a (tweakable)
block cipher, a permutation uses less memory and is conceptually simpler. Because we do not
have to evaluate security against related-key distinguishers, we can use the long trail strategy to
get bounds for all differential and linear trails that could be leveraged by an attacker. Moreover,
as we have a fixed permutation, we can conduct statistical experiments. For example we can
experimentally check clustering effects for differential or linear trails or the distribution of lowweight monomials (as was for example also done in Keccak). In a block cipher, every key defines
a different permutation and experimentally checking all such permutations would of course be
unfeasible.
In summary, we find the sponge to make a better use of memory while allowing the experimental
verification of the properties of its building blocks that does not rely on assumptions about the
key distribution.

3.1.2

Modes of Operation

We use a sponge mode because of its provable security in the idealized setting, i.e., when a random
permutation is assumed as its underlying permutation. For hashing, we use the classical sponge
mode of operation, similar to that of the NIST standard SHA-3 [Dwo15]. However, we slightly
adapt it to allow a minimum-size padding, by employing a similar domain extension scheme as
proposed in [Hir16]. In the idealized model, Hirose proved that the corresponding sponge is indifferentiable from a random oracle up to the birthday bound [Hir18].
For authenticated encryption, we use the mode of operation proposed by the designers of
Beetle [CDNY18]. It is a variant of a duplexed sponge [BDPA11]. The reasoning for using this
25

mode is that it guarantees a security level with regard to confidentiality and integrity (close to) its
capacity size in bits instead of an integrity security level of half of the capacity size. It therefore
allows us to process more data per permutation call for a given security level and thus to increase
the efficiency of our algorithms. We slightly adapted the Beetle mode by shortening the key to
the size of the capacity 𝑐, which only adds a term of 2𝑞𝑐 in the bound on the advantage of the
adversary (where 𝑞 denotes the number of permutation queries). We further shortened the tag to
the size of the capacity to limit the increase in the ciphertext size and adapted the handling in case
of empty associated data and message. We further XOR the key before outputting the tag. We
finally changed the particular constants ConstA and ConstM for domain extension by encoding the
capacity size into them. This differentiates the Schwaemm instances that use the same underlying
Sparkle permutations.
Our use of big and slim permutations means that the security of our high level algorithms is not
directly implied by standard provable security arguments. However, a careful analysis of various
cryptanalysis techniques allows us to claim with a high confidence that this discrepancy is not
important in our case.
On Sponge-based Constructions in the Past. The sponge construction for hashing was introduced at the ECRYPT hash workshop in 2007 ([BDPVA07]) and it was proven that a random
sponge is indistinguishable from a random oracle up to inner collisions, thus imposing a security
level of 2𝑐 bits, where 𝑐 denotes the capacity. At EUROCRYPT 2008, it was shown that the sponge
𝑐
is also indifferentiable of a random oracle up to complexity 2 2 in the ideal permutation (resp.,
ideal function) model [BDPV08]. In this setting, the adversary has also access to the random permutation (resp., function) implemented in the sponge. The sponge as an underlying construction
was adopted in the NIST standard SHA-3 [Dwo15] in 2015. We point to [BDPVA11] for a detailed
documentation of the sponge and its variants, including duplexed sponges. They were introduced
at SAC 2011 [BDPA11] and allow to both inject and output messages between each permutation
call. When initialized with a secret key, the authors showed that a duplexed sponge can simply
be applied for authenticated
(︀
)︀ encryption in a mode called SpongeWrap, for which they proved a
security level of min 𝜅, 2𝑐 bits in the ideal permutation model, where 𝜅 denotes the key size.
The elegant construction of a duplexed sponge inspired lots of cryptographers to submit authenticated ciphers to the CAESAR competition that were based on such a construction, e.g., the
winner for the use case of lightweight applications Ascon [DEMS16], the third-round candidates
Ketje [BDP+ 16a], Keyak [BDP+ 16b] and Norx [AJN16], and many more first and second-round
competitors.
In [JLM14], the authors derived improved security bounds on sponge-based constructions for
authenticated encryption (i.e., duplexed(︀ sponge
)︀ constructions). Their main result was an improved
security level on confidentiality of min 2𝑏 , 𝑐, 𝜅 bits, where 𝑏 denotes the block size of the permutation, 𝑐 the capacity, and 𝜅 the size of the key. The authors derived a similar improved security
for integrity under the assumption that the number of forgery attempts of the adversary is re𝑐
stricted to fulfill the inequality 𝑞𝑝 + 𝜎𝐸 + 𝜎𝐷 ≤ 𝜎2𝐷 , where 𝑞𝑝 denotes the number of permutation
queries, 𝜎𝐸 the number of encryption queries and 𝜎𝐷 the number of forgery attempts (see [JLM14,
Theorem 2]). This improved result affected many CAESAR competitors and some teams reduced
the capacity size in their submissions (e.g., Norx and Ascon-128a). However, in their Journal of
Cryptology version of the paper [JLM+ 18], the authors explicitly mention that ”caution must be
taken” if the ciphers with reduced capacity are used in applications in which the forgery attempts
by the adversary are not limited. They refer to a discussion on that topic on the CAESAR mailing
list.1
In [ADMA15], the authors considered the keyed duplex sponge construction more generally
(i.e., not only in the use case of authenticated encryption) and proved its indistinguishability from
a random oracle, also allowing the adversary access to the underlying permutation, up to a security
level of 𝑐. Thus they obtain a result similar to [JLM14], but, unlike in the latter paper, the authors
of [ADMA15] do not restrict themselves to specific authenticated ciphers. Moreover, they analyze
the indistinguishability in multi-key settings.
1 https://groups.google.com/forum/#!topic/crypto-competitions/YZ3sMMzzXro

26

In [CDNY18], the authors proposed a variation of the duplexed sponge mode, called Beetle,
that uses a combined feedback function 𝜌 for injecting and producing message/ciphertext blocks.
While in classical duplexed sponges the ciphertext blocks equal the outer part of the internal states,
the feedback function does not leak information about the(︀ internal state from
)︀ a ciphertext only. The
authors proved a security of their construction of min 𝑟, 2𝑏 , 𝑐 − log2 (𝑟) , both for confidentiality
and integrity, and without the restriction on the number of forgery attempts. Here, 𝑟 denotes the
size of the rate in bits.

3.1.3

Improving Sponge-based Modes

As our approach is not hermetic, our choices are guided by the best attack that can be found
against the permutations in a mode. In order to mitigate some of them, we propose some simple
modifications to the sponge-based modes we use. These changes are equivalent to alterations of
the permutation used, meaning that they are compatible with the sponge structure.
3.1.3.1

Rate Whitening

In a sponge-based authenticated cipher, the security of the primitive is based on the secrecy of
the inner part. Hence, we can safely allow the adversary to read the content of the outer part.
However, in practice, this can allow the attacker to compute a part of the permutation. Indeed,
if the outer part is aligned with the S-box layer then the attacker can evaluate said S-box layer
on the outer part. In our case, as half of the linear layer is the identity function, it would allow
the attacker to partially evaluate two steps of the permutation. It is not clear what advantage
they could derive from such observations as the content of the inner part remains secret in this
case. However, it is easy to prevent this phenomena using what we call rate whitening. It simply
consists in XORing branches from the inner part into the outer part just before the permutation
call. That way, the attacker cannot evaluate a part of the permutation without first guessing parts
of the inner part.
This modification to the mode can be instead interpreted as the use of an altered permutation
which contains the rate whitening. Thus, this improvement to a sponge-based mode is compatible
with said mode.
3.1.3.2

Indirect Injection

In a sponge-based hash function, an 𝑟-bit message block is XORed into the outer part. In Esch, it
is not exactly the case. Instead, the 𝑟-bit message block is first expanded into a larger message using
a linear function and the result is injected into the state of the sponge. We call this pre-processing
of the message blocks “indirect injection”.
As with rate whitening, the purpose of this modification is to alleviate potential issues arising
when the outer part is aligned with the S-box layer. Indeed, in such a case, the attacker does not
need to find a differential trail covering the whole permutation to find a collision. Instead, they can
find a differential covering all but the first and last layers of S-boxes which will propagate through
this layer with probability 1.
In order to prevent such attacks, it is sufficient to modify the injection procedure so that the
space in which the injected message lies is not aligned with the S-box layer. To this end, we reuse
the linear Feistel function used in our Sparkle instances. For example, in Esch256, we do not
inject message branches 𝑥 and 𝑦 directly but, instead, inject the 3-branch message ℳ3 (𝑥, 𝑦, 0).
This is equivalent to using a regular injection while composing the permutation with an application
of ℳ3 in the input and one of ℳ−1
3 in the output, so that this modification still yields a “regular
sponge”.
This simple modification to the injection procedure efficiently disrupts the alignment between
the outer part and the Alzette layer. Furthermore, because the linear functions we use for the
indirect injection (ℳ3 and ℳ4 ) have a branching number of 4, and because only two branches
are injected through them, we know that at least two double Alzette instances are activated during
message injection. Similarly, a differential trail yielding a possible cancellation by an indirectly
injected message in the output of a permutation implies that two double Alzette instances are active
in the end of the trail. Because this pattern cannot be truncated, it means that a differential trail
27

mapping an indirectly injected difference to an indirectly injected difference has a probability upperbounded by the double ARX-box bound to the power 4. As the best differential trail covering a
double ARX-box has a probability at most equal to 2−32 , we deduce the following lemma.2
Lemma 3.1.1. The probability (taken over all inputs) of a differential trail that is introduced
and then cancelled via indirectly injected messages after at least one iteration of Sparkle384 or
Sparkle512 is at most equal to 2−128 .
The general principle consisting in applying a linear code to the message block before injection is reminiscent of the technique used to input the message blocks in the SHA-3 candidate
Hamsi [Küç09].
In our case, messages that have a length multiple of 𝑟 are not padded, instead, a constant is
added into the state of the sponge that is outside the control of the adversary. This constant is
added on the left part of the state to ensure its diffusion but, at first glance, we might think that it
could be cancelled via a difference in a message block since the indirect injection XORs data into
the whole left part of the state. However, since the constant is only over a single word, a difference
cancelling it would have to span 3 (respectively 4) input branches of the linear permutation used
for indirect injection in Esch256 (resp. Esch384). Because we fix 1 (resp. 2) inputs of this linear
permutation to 0, a direct application of Theorem 3.4.1 shows that no message difference can cancel
this constant.

3.2

A Permutation Structure that Favours Rigorous Security Arguments

After settling on the design of a permutation, we need to decide how to build it. The structure
used must allow strong arguments to be made for the security it offers against various attacks
while being amenable to very efficient implementations in terms of code size, RAM usage and
speed. First, we present the mathematical framework of provable security against differential and
linear attacks (Section 3.2.1). Then we present the Long Trail Strategy (LTS) as introduced in the
design of Sparx3 (Section 3.2.2). Finally, we argue that the use of the LTS allows us to bound the
probability of all differential/linear trails, including those that are obtained by absorbing (possibly
many) blocks into a sponge (Section 3.2.3). Thus, it allows us to have some guarantees even if
the permutation “in a vacuum” has some distinguishers. In other words, it allows us to build
non-hermetic algorithms with the same security arguments as hermetic ones.

3.2.1

Provable Security Against Differential and Linear Attacks

The resistance of a symmetric-key primitive against differential and linear cryptanalysis is determined by the differential (resp. linear) characteristic/s with maximum probability (resp. absolute
correlation). The reason is that the success probability of a differential (resp. linear) attack depends on the amount of data (number of plaintexts) necessary to execute the attack. The latter
is, in turn, proportional to the inverse of the probability (resp. absolute correlation) of the best
differential (resp. linear) characteristic.
For keyed constructions the maximum 𝑁 -round probability (resp. absolute correlation) for a
fixed key is approximated by the expected maximum probability (resp. absolute correlation) over
all keys. This is known as assuming the Hypothesis of Stochastic Equivalence (see e.g. [LMM91]
[DR02, S 8.7.2, pp. 121]).
We denote the two quantities – the maximum expected differential trail (or characteristic) probability and the maximum expected absolute linear trail (or characteristic) correlation – respectively
by MEDCP and MELCC. These abbreviations have been previously used in the literature e.g.
in [KS07].
For computing the MEDCP and MELCC we work under the assumption of independent round
keys. The latter allows us to compute the probability of an 𝑁 -round characteristic as the product
2 In the specific cases of the Esch functions, an attacker could try and leverage the padding scheme and the
different constants added in the outer part to add a difference to the state in a way which is not coherent with indirect
injections. Still, our LTS-derived differential bounds (see Section 4.3.1) allow us to simply solve this problem.
3 As hinted by its name, Sparkle is a descendent of the block cipher Sparx. In fact, this block cipher was
co-designed by members of our team.

28

of its corresponding 1-round transitions. This is also known as assuming the Hypothesis of Independent Round Keys (see e.g. [DR02, S 8.7.2, pp. 121]). Note that, since we are in the permutation
setting, we do not have any round keys. Therefore, this assumption indeed doesn’t hold technically.
However, we have validated experimentally that it is a good approximation for what happens in
practice.
We prove that the proposed designs – Schwaemm and Esch – are resistant against differential and linear attacks by showing that for the underlying permutation Sparkle, there does not
exist differential and linear characteristics with MEDCP and MELCC that are high enough to be
exploited in an attack. The tools that make it possible to prove such statements lie in the heart
of the Long Trail Strategy, which will be presented in more detail next.

3.2.2

The Long Trail Strategy

The Long Trail Strategy (LTS) is a design approach that was introduced by the designers of
Sparx [DPU+ 16] to bound the differential probabilities and absolute linear correlations for ARXbased primitives with large internal states.
Up to that point, the only formal bounds available for ARX-based algorithms were obtained
via computer search which, for computational reasons, were restricted to small block sizes (mostly
32 bits, possibly up to 64) [BVC16]. The LTS is an approach that allows the construction of round
functions operating on a much larger state in such a way that the bounds obtained computationally
over a small state can be used to derive bounds for the larger structure. This very high level
description is virtually identical to that of the Wide Trail Strategy (WTS), introduced in [Dae95]
and famously used to design the AES [AES01]. However, the specifics of these two methods are
very different (see Section 3.2.2.3). First, we recall how a long trail argument works to bound the
differential probabilities and absolute linear correlations (Section 3.2.2.1).
3.2.2.1

The Long Trail Argument

In what follows, we focus on the case of differential probabilities. The linear case is virtually
identical. In order to build a cipher according to the LTS, we need:
∙ a non-linear operation 𝐴 operating on 𝑏 bits such that the differential probability for multiple
iterations of 𝐴 is bounded,
∙ a linear layer operating on 𝑏-bit branches.
The bound is then computed by looping over all the truncated trails that are allowed by the linear
layer. As the number of 𝑏-bit branches is low (in our case, at most 8) and as the linear layer is
sparse (in our case, half of the outputs are copies of the input), this loop is very efficient. Then,
for each truncated trail, we perform two operations.
1. First, we decompose the truncated into long trails. A long trail is a continuous differential
trail at the branch level that receives no difference from other words. If 𝑟 iterations of 𝐴
are performed on a branch without any call to the linear layer, then the probability of all
differential trails that fit in this truncated trail is at most equal to the bound for 𝑟 rounds
of 𝐴. More subtly, if 𝑥 ← 𝐴𝑟 (𝐴𝑟 (𝑥) ⊕ 𝐿(𝑦)) and the difference over 𝑦 is equal to 0 then we
can bound the differential probability by the one corresponding to 2𝑟 rounds of 𝐴.
The decomposition of a truncated trail into its constitutive long trails is obtained by grouping
all the chains of 𝑡 active branches that do not receive differences from the outside into long
trails of length 𝑡.
2. In order to bound the probability of all differential trails that fit in a truncated trail over 𝑟
rounds, we use
𝑟
∏︁
𝑝 𝑡 × 𝑛𝑡 ,
𝑡=1

where 𝑝𝑡 is the bound for 𝑡 rounds of 𝐴 and where 𝑛𝑡 is the number of long trails of length 𝑡
in the truncated trail.
29

Example 3.2.1. Here, we reproduce the example given in the specification of Sparx [DPU+ 16].
Consider a 64-bit block cipher using a 32-bit S-box, one round of Feistel network as its linear
layer and 4 steps without a final linear layer. Consider the differential trail (𝛿0𝐿 , 𝛿0𝑅 ) → (𝛿1𝐿 , 𝛿1𝑅 ) →
(0, 𝛿2𝑅 ) → (𝛿3𝐿 , 0) (see Fig. 3.1 where the zero difference is dashed). Then this differential trail can
be decomposed into 3 long trails represented in black, blue and red: the first one has length 1 and
𝛿0𝑅 as its input; the second one has length 2 and 𝛿0𝐿 as its input; and the third one has length 3 and
𝛿1𝐿 as its input so that the long trail decomposition of this trail is {𝑡1 = 1, 𝑡2 = 1, 𝑡3 = 1}, where 𝑡𝑖
denotes the number of of long trails of length 𝑖.
𝛿0𝐿
𝐴
𝐿
𝛿1𝐿

𝛿0𝑅
𝐴
⊕

𝛿1𝑅

𝐴
𝐿
0
𝐴
𝐿
𝛿3𝐿

𝐴
⊕

𝛿2𝑅
𝐴
⊕
0
𝐴

𝐴

Figure 3.1: The decomposition into long trails of a truncated trail in a simple cipher.
A good structure to leverage long trail is the one described in Figure 3.2. By forcing the
chaining of multiple rounds of 𝐴 in each branch and in each step, it ensures the existence of some
long trails. In order to further exploit the long trails, we can set 𝐿 to be essentially a Feistel round
defined by
(︀
)︀
(𝑥0 , ..., 𝑥𝑖−1 ), (𝑦0 , ..., 𝑦𝑖−1 ) ↦→ 𝑦0 ⊕ ℓ0 (𝑥0 , ..., 𝑥𝑖−1 ), ..., 𝑦𝑖−1 ⊕ ℓ𝑖−1 (𝑥0 , ..., 𝑥𝑖−1 ) , (𝑥0 , ..., 𝑥𝑖−1 ) ,
where the ℓ𝑖 are linear functions operating on 𝑖 branches. Indeed, such linear trails ensure the
existence of long trails of length 2𝑟 because half of the inputs are copied to the output. At the
same time, the diffusion provided by a Feistel round is well understood and it is the same in both
the forward and backward directions.4
These observations led us to use such a linear layer when designing Sparx. Now that Sparx
has undergone third-party cryptanalysis (see Section 3.2.2.2) we confidently reuse this structure.
round
step

𝛾00

⊕
𝐴0

𝛾0𝑤−1

⊕
𝐴0

0
𝛾𝑡−1

⊕
𝐴𝑡−1

𝑤−1
𝛾𝑡−1

⊕
𝐴𝑡−1

𝐿
Figure 3.2: The overall structure of a step for the long trail strategy. The wires correspond to
branches which, in our case, are divided into two words.

3.2.2.2

Literature on SPARX and the LTS

The sanity of the long trail strategy was confirmed by several cryptanalysis attempts targetting
Sparx. In [AL18], the authors describe some attacks against round-reduced versions of the ciphers
4 Again, we stress that we assume independent calls to Alzette and use bounds on the MEDCP/MELCC, although
we don’t have round keys.

30

and confirm that no differential trail with a probability higher than the one found via the long
trail argument exists. In a follow-up work presented at SAC’18 [AK18], the authors found that the
differential effect is not a threat to the security of Sparx, i.e. that the clustering of differential
trails was rather small—as in all ARX-based ciphers. Other authors have analyzed Sparx without
finding any significant attack [ATY17, TAY17].
The LTS served as the basic principle for the design of other algorithms by another team. The
sLiSCP permutation [ARH+ 17] was designed with hardware efficiency in mind. It uses a generalized
Feistel structure with a few rounds of the block cipher Simeck [YZS+ 15] as the Feistel function.
The bounds for the differential probability and absolute linear correlations were obtained using a
long trail argument. It was later improved by replacing the generalized Feistel structure with a
generalized MISTY structure, thus saving some copies of the state. Again, long trail arguments
were used by the designers. The result, sLiSCP-light, was published later [ARH+ 18].
3.2.2.3

LTS versus WTS

The wide trail strategy (WTS), famously used to design the AES, is the most common design
strategy for block ciphers and permutations. Thus, we provide a quick comparison of these two
approaches.
Bound Derivation. For the WTS, the diffusion must ensure a high number of active S-boxes in
differential and linear trails. The bound on the corresponding primitive is derived using 𝑝𝑎 where
𝑝 is the relevant probability at the S-box level and 𝑎 is the number of active S-boxes. The aim
is then to increase 𝑎. In contrast, in the LTS, the bound is derived by looping over all possible
truncated trails, decomposing each into its long trails and computing the bound accordingly.
Confusion. In algorithms built using the WTS, the non-linearity is provided by S-boxes, small
functions operating on typically 4 or 8 bits. In contrast, in the LTS, the non-linearity is provided
by multiple rounds of a more complex function operating on a much larger state (32 bits in the
case of Sparx, 64 bits for Sparkle).
Diffusion. The diffusion layer in the WTS must ensure a high number of active S-boxes. In the
LTS, it is more subtle: if a difference does not propagate, it might prevent the interruption of
a long trail which could counter intuitively lead to a lower probability than if the difference did
propagate. Nevertheless, in order for the cipher to resist other attacks, the diffusion layer must
provide some diffusion. We have found that Feistel-based linear layers provided a good compromise
between these two requirements.
Two-Staged Security Analysis. At the heart of both design strategies lies the idea of separating
the analysis of the cipher into two stages. First, we study the non-linear part (be it its small S-box
or its wide ARX-box) and then, using properties of the linear layer, we deduce the properties of
the cipher. This two stage approach simplifies the task of the cryptanalyst as it allows the use of
computer assisted method to investigate the properties of the non-linear part (which operate on a
small enough block size that it is possible, i.e. at most 64 bits for an ARX-box). Hence, ciphers
designed with either the WTS or the LTS are easier to study than more classical ARX designs.

3.2.3

Applying the LTS to Absorption

In a sponge function, the state is divided into two parts: the outer part is 𝑟-bit long and the
inner part is 𝑐-bit long. The quantities 𝑟 and 𝑐 are respectively called the rate and the capacity.
Regardless of the use of the sponge, 𝑟-bit plaintext blocks are XORed into the outer part of the
sponge.

31

3.2.3.1

Hermetic versus Not-Hermetic Approach

When building a block cipher, designers ensure that their algorithm is safe from differential and
linear attacks. The methods to prove resilience against these attacks are well known and they help
provide a good estimate of the number of rounds needed to ensure security against these attacks.
For sponge-based hash functions and authenticated ciphers, the best current approach for
provable security consists in building a permutation such that no distinguisher exist for it. This
security will then naturally carry over to the hash function. However, this approach provides
protection against an unrealistic adversary: in a sponge function, the adversary can only control
the outer part of the internal state. Therefore, we can expect that preventing all such distinguishers
is over-engineering, especially in a lightweight setting. Unfortunately, it is difficult to estimate the
number of rounds needed in the permutation to prevent attacks from more realistic adversaries,
i.e. ones which can only modify the content of the outer part.
Like for block ciphers, we turn to the prevention of differential and linear attacks to make
this estimation. Differential attacks pose a serious threat to hash functions as evidenced by the
practical attack against SHA-1 [SBK+ 17]; and linear biases in the keystream generated by several
authenticated ciphers have been identified as well, for instance in MORUS [AEL+ 18]. In Sections 3.2.3.2 and 3.2.3.3 respectively, we show that dangerous respectively differential and linear
distinguishers can be proven to have a negligible probability when the algorithm considered is a
sponge with a permutation built using the LTS.
3.2.3.2

Preventing Differential Attacks in Sponges

Differential trails that could be useful for an adversary trying to attack a sponge are prevented in
two stages.
First, for hashing, we use a permutation call between the absorption phase and the squeezing
phase that does not yield any differential with probability higher than 2−𝑠 , where 𝑠 is the security
parameter. More formally, we want the permutation which is called between absorption and
squeezing to have the following property.
Property 3.2.1 (Absorption/Squeezing Separation). Let 𝑃 : F𝑟2 × F𝑐2 → F𝑟2 × F𝑐2 be a permutation.
It separates the two phases with a security level of 𝑠 bits if:
∀𝛿 ∈ F𝑟2 × F𝑐2 , 𝛿 ̸= 0 =⇒ ∀Δ ∈ F𝑟2 × F𝑐2 , Pr[𝑃 (𝑥 ⊕ 𝛿) ⊕ 𝑃 (𝑥) = Δ] ≤ 2−𝑠 ,

where the probability is taken over all 𝑥 ∈ F𝑟2 × F𝑐2 .

This property is essentially what we would expect of a random permutation except that the
bound on the probability is 2−𝑠 rather than 2−𝑐−𝑟 . The point in this case is to destroy any pattern
that could exist in the internal state of the sponge before squeezing, even if this pattern is only in
the inner part. In other words, Property 3.2.1 ensures that no non-trivial differential pattern can
be exploited once the squeezing phase has been reached.
We then need to ensure that no differential trail ending with an all-zero difference (a collision)
exists with a probability higher than 2−𝑠 . If we can show this absence then we expect that the
probability of existence of a valid pair with specific predefined input values is upper-bounded by
2𝑟−𝑠 .
Property 3.2.2 (Unfeasibility of Vanishing Differences). Let 𝑃 : F𝑟2 × F𝑐2 → F𝑟2 × F𝑐2 be a permutation and let 𝑃𝑚 be the permutation of F𝑟2 × F𝑐2 parameterized by 𝑚 ∈ F𝑟2 defined by
𝑃 [𝑚] : (𝑥, 𝑦) ↦→ 𝑃 (𝑥 ⊕ 𝑚, 𝑦) .

Furthermore, for any integer 𝑎 > 0 and fixed differences 𝛿0 , . . . , 𝛿𝑎−1 ∈ F𝑟2 , let Pvanish (𝑎) be the
probability that
(︀
)︀
(︀
)︀
𝑃 [𝑥𝑎−1 ⊕ 𝛿𝑎−1 ] ∘ · · · ∘ 𝑃 [𝑥0 ⊕ 𝛿0 ] (𝑦) ⊕ 𝑃 [𝑥𝑎−1 ] ∘ · · · ∘ 𝑃 [𝑥0 ] (𝑦) = (0, 0)

where the probability is taken over all (𝑥0 , ..., 𝑥𝑎−1 ) ∈ (F𝑟2 )𝑎 and all 𝑦 ∈ F𝑟2 × F𝑐2 .
We say that 𝑃 makes vanishing differences unfeasible for a security parameter 𝑠 if, for all
numbers of absorbed message blocks 𝑎, we have
∀(𝛿0 , ..., 𝛿𝑎−1 ) ∈ (F𝑟2 )𝑎 , 𝛿0 ̸= 0 =⇒ Pvanish (𝑎) ≤ 2−𝑠 .
32

This property is different from the absorption/squeezing separation. Indeed, we are not looking
at any differential trail but specifically at those that correspond to the absorption of 𝑟-bit blocks.
Similarly, we only worry about differences that end up only in the outer part of the sponge as
these are the differences that can be cancelled via the absorption of a message. For hashing,
we are aiming for a security parameter of 𝑟 + 2𝑐 . As already explained in the documentation of
cryptographic sponges [BDPVA11, Section 8.4.1.1], if the probability of an outer part to outer
𝑐
part differential trail can be upper-bounded by 2−𝑟− 2 , the expected number of pairs following the
𝑐
trail is upper-bounded by 2 2 . Thus, the probability that there exist a valid pair with a fixed and
𝑐
predefined input value is ≤ 2− 2 .
Hypothesis 3.2.1. If a permutation of F𝑟2 × F𝑐2 satisfies both the absorption/squeezing separation
and the unfeasability of vanishing differences with security parameter 𝑟 + 𝑐/2 then it can be used
to construct a sponge for which a differential collision search cannot be more efficient than a basic
collision search.
The aim of such a differential attack would be to find a pair of messages 𝑥, 𝑦 such that either
of the following two happens:
1. after absorbing 𝑥 and 𝑦, the states of the sponges are identical (collision of the full state)
2. there is a difference between the two states but, after squeezing, this difference is not over a
part of the state that matters.
𝑐

If the first case has a probability higher than 2−𝑟− 2 then the unfeasibility of vanishing differences
is violated. If the second one is, then the separation of squeezing and absorption is violated. Hence,
satisfying both prevents such attacks.
Because of the uniqueness of the nonce, attacks on the decryption oracle (e.g., differential
forgeries) in AEAD are the most dangerous kind of attack that exploit differential cryptanalysis.
For AEAD, we therefore aim for a security level of 𝑐 when considering outer part to outer part
trails.
In practice, designers usually cannot prove that those properties are satisfied without any
simplifying assumptions. Still, we can assume that the probability of differential trails is a good
approximation for the probability of the differentials and then we can prove, using a variant of the
long trail argument, that no differential trail can falsify either property. The conclusion is then
that the sponge is safe from a differential collision search.
We have observed that those two requirements require different number of steps in the iterated
permutation. It makes sense as the attacker has full control over the difference in the absorption/squeezing separation case while it can only inject some specific differences in the vanishing
differences case. The hermetic sponge strategy [BDPVA11, Section 8.1.1] then consists of the case
where 𝑠 = 𝑟 + 𝑐. While the hermetic sponge strategy certainly yields secure sponges, our finer
approach allows us to use fewer steps. In particular, our approach can be expected to yield different
number of steps during absorption and between absorption and squeezing.
In order to bound the probability of differential trails that are relevant for Property 3.2.1, we can
simply consider the permutation like a block cipher and use the probability bounding techniques
that are relevant given its design strategy. In our case, we simply reuse the long trail argument
that was introduced in SPARX, i.e. we loop over all truncated trails, divide them into long trails
and deduce a probability bound for each. This method can be efficiently implemented using a
variant of Matsui’s search, as explained in Section 4.2.2.1.
For Property 3.2.2, using an LTS-based permutation simplifies the search greatly. Usually,
the search space corresponding to the search for the trails considered in Property 3.2.2 is too
large. Indeed, in this case, the differences are injected in the outer part of the sponge during each
absorption. We therefore multiply the set of possible input differences by 2𝑟 each time we consider
an absorption. It means that Property 3.2.2 is a priori impossible to verify unless we simply ensure
that Property 3.2.1 holds for the same number of steps.
However, for the Sparkle permutation family, this finer search is possible.
As we bound the differential probabilities using the LTS, we first enumerate all possible truncated differential trails and then bound the probabilities for each individual truncated trail. As
the branches are wide (64-bit in our case), each message injections lead to the addition of 𝑟/64
33

bits of information in terms of truncated trails. It is thus possible to enumerate all truncated trails
covering a certain amount of message absorption where the difference is injected only in the outer
part. The details of the algorithm we used in the case of SPARX are given in Section 4.3.1.
3.2.3.3

Preventing Linear Attacks in Sponges

Mirroring differentials, we can define linear approximations that are of particular interest for
cryptanalysts and whose absolute correlation we must strive to lower. The main such correlations
corresponds to the following property.
Property 3.2.3 (Undetectability of Keystream Bias). Let 𝑃 : F𝑟2 ×F𝑐2 → F𝑟2 ×F𝑐2 be a permutation.
We say it has undetectable keystream biases with security parameter 𝑠 if the absolute correlation
of each linear approximation of 𝑃 𝑖 involving only bits in the outer part is lower than 2−𝑠/2 , for all
numbers of iterations 𝑖 where 𝑖 is smaller than the order of the permutation.
Hypothesis 3.2.2. Let 𝑃 : F𝑟2 × F𝑐2 → F𝑟2 × F𝑐2 be a permutation that has undetectable keystream
biases with security parameter 𝑠. If it is used to construct a sponge-based stream cipher then it is
impossible to distinguish its output from a random stream using linear biases.
Detection of biases is a dangerous attack on AEAD schemes. We aim for a security parameter
of 𝑠 = 𝑑, where 𝑑 equals the binary logarithm of the number of blocks allowed by the data limit.
As for the differential case, we do not know how to prove that all linear approximation have
such a low absolute correlation. However, we can approximate the absolute correlations of linear
approximations by those of the linear trails yielding them, and then upperbound the absolute
correlations of said trails.

3.3

The ARX-box Alzette

In this section, we present both the design process and the main properties of Alzette as published
in [BBCdS+ 20a]. A summary of those properties is provided in Section 3.3.11.

3.3.1

Round Structure and Number of Rounds

We decided to build Alzette out of the operations XOR of rotation and ADD of rotation, i.e.,
𝑥 ⊕ (𝑦 ≫ 𝑠) and 𝑥 + (𝑦 ≫ 𝑟), because they can be executed in a single clock cycle on ARM
processors and thus provide extremely good diffusion per cycle. As the Alzette instances will be
implemented with their rounds unrolled, we allowed the use of different rotations in every round.
We observed that one can obtain much better resistance against differential and linear attacks in
this case compared to having identical rounds.
In particular, we aimed for designing an ARX-box of the form depicted in Figure 3.3, where
each word is of size 32 bits and which iterates 𝑡 rounds. The 𝑖-th round is defined by the rotation
32
amounts (𝑟𝑖 , 𝑠𝑖 ) ∈ Z32 × Z32 and the round constant (𝛾𝑖𝐿 , 𝛾𝑖𝑅 ) ∈ F32
2 × F2 .
In our final design of Sparkle, we decided to use 𝑡 = 4 rounds. The reason is that, for 𝑟-round
ARX-boxes, usable LTS bounds can be obtained from the 2𝑟-round bounds of the ARX structure
by concatenating two ARX-boxes (see Section 3.2.2.1). The complexity of deriving upper bounds
on the differential trail probability or absolute linear trail correlation depends on the number of
rounds considered. For 8 rounds, i.e., 2 times a 4-round ARX-box, it is feasible to compute strong
bounds in reasonable time (i.e., several days up to few weeks on a single CPU). For 3-round ARXboxes, the 6-round bounds of the best ARX-boxes we found seem not strong enough to build a
secure cipher with a small number of steps. Since we cannot arbitrarily reduce the number of steps
in Sparkle because of structural attacks, using ARX-boxes with more than four rounds would lead
to worse efficiency overall. In other words, we think that four-round ARX-boxes provide the best
balance between the number of steps and rounds per step in order to build a secure permutation.

3.3.2

Criteria for Choosing the Rotation Amounts

We aimed for choosing the rotations (𝑟𝑖 , 𝑠𝑖 ) in Alzette in a way that maximizes security and
efficiency. For efficiency reasons, we want to minimize the cost of the rotations, where we use the
34

y

x
≫ r0
≫ s0

γ0L

γ0R
≫ r1
≫ s1

γ1L

γ1R

..
.

..
.

≫ rt−1
≫ st−1
L
γt−1

R
γt−1

u

v

Figure 3.3: The general structure of Alzette.
cost metric as given in Table 3.1. While each rotation has the same cost in 32-bit ARM processors,
we further aimed for minimizing the cost with regard to 8-bit and 16-bit architectures. Therefore,
we restricted ourselves to rotations from the set {0, 1, 7, 8, 9, 15, 16, 17, 23, 24, 25, 31}, as those are
the most efficient when implemented on 8 and 16-bit microcontrollers. We define the cost of a
collection of rotation amounts (that is needed to define all the rounds of an ARX-box) as the sum
of the costs of its contained rotations.
Table 3.1: For each rotation in {0, 1, 7, 8, 9, 15, 16, 17, 23, 24, 25, 31}, the table shows an estimation
of the number of clock cycles needed to implement the rotation on top of XOR, resp. ADD. We
associate the mean of those values for the three platforms to be the cost of a rotation.
rot (mod 32)

8-bit AVR

16-bit MSP

32-bit ARM

cost

0
±1
±7
8
±9
±15
16

0
5
5
0
5
5
0

0
3
9
6
9
3
0

0
0
0
0
0
0
0

0.00
2.66
4.66
2.00
4.66
2.66
0.00

For security reasons, we aim to minimize the provable upper bound on the expected differential
trail probability (resp. expected absolute linear trail correlation) of a differential (resp. linear)
trail. More precisely, our target was to obtain strong bounds, preferably at least as good as those
of the round structure of the 64-bit block cipher Speck, i.e., an 8-round differential bound of 2−29
and an 8-round linear bound of 2−17 . If possible, we aimed for improving upon those bounds.
Note that for 𝑟 > 4, the term 𝑟-round bound refers to the differential (resp. linear) bound for 𝑟
rounds of an iterated ARX-box. As explained above, at the same time we aimed for choosing an
ARX-box with a low cost. In order to reduce the search space, we relied on the following criteria
as a heuristic for selecting the final choice for Alzette:
35

∙ The candidate ARX-box must fulfill the differential bounds (− log2 ) of 0, 1, 2, 6, and 10 for
1, 2, 3, 4 and 5 rounds respectively, for all four possible offsets. We conjecture that those
bounds are optimal for up to 5 rounds.
∙ The candidate must fulfill a differential bound of at least 16 for 6 rounds, also for all offsets.
∙ The 8-round linear bound (− log2 ) of the candidate ARX-box should be at least 17.
By the term offset we refer to the round index of the starting round of a differential trail. Note
that we are considering all offsets for the differential criteria because the bounds are computed
using Matsui’s branch and bound algorithm, which needs to use the 𝑟 − 1-round bound of the
differential trail with starting round index 2 in order to compute the 𝑟-round bound of the trail.
We tested all rotation sets with a cost below 12 for the above conditions. None of those fulfilled
the above criteria. For a cost below 15, we found the ARX-box with the rotations as presented in
Table 3.2. The first two lines correspond to the choice for Alzette.
Table 3.2: Differential and linear bounds for our choice of rotation parameters with all four offsets.
For each offset, the first line shows − log2 𝑝, where 𝑝 is the maximum expected differential trail
probability for the differential case and the second line shows − log2 𝑐, where 𝑐 is the maximum
expected absolute linear trail correlation for the linear case. The value set in parenthesis corresponds to the maximum absolute correlation of the linear hull taking clustering into account,
derived by the experimental verification. The bounds [BVC16, FWG+ 16, LWR16, Liu17, LLJW21]
for SPECK are given at the bottom of the table for comparison.
(𝑟0 , 𝑟1 , 𝑟2 , 𝑟3 , 𝑠0 , 𝑠1 , 𝑠2 , 𝑠3 )

1

2

3

4

5

6

7

8

9

10

11

12

(31, 17, 0, 24, 24, 17, 31, 16)

0
0
0
0
0
0
0
0

1
0
1
0
1
0
1
0

2
1
2
1
2
1
2
1

6
2
6
2
6
2
6
2

10
5
10
5
10
6
10
5

18
8
17
9
18
8
17
9

26
13 (11.64)
25
13
25
13
25
12

≥ 32
17 (15.79)
31
16
≥ 32
15
≥ 31
16

≥ 36
–
≥ 37
–
≥ 36
–
≥ 37
–

≥ 42
–
≥ 41
–
≥ 42
–
–
–

≥ 46
–
≥ 47
–
–
–
–
–

≥ 52
–
–
–
–
–
–
–

0
0

1
0

3
1

6
3

10
6

15
9

21
13

29
17

34
19

38
21

42
24

46
27

(17, 0, 24, 31, 17, 31, 16, 24)
(0, 24, 31, 17, 31, 16, 24, 17)
(24, 31, 17, 0, 16, 24, 17, 31)
Speck64

3.3.3

On the Differential Properties of Alzette

We used Algorithm 1 of [BVC16], adapted to our round structure, to compute the bounds on the
maximum expected differential trail probabilities of the ARX-boxes. This algorithm is basically
a refined variant of Matsui’s well-known branch and bound algorithm [Mat95]. While the latter
has been originally proposed for ciphers that have S-boxes (in particular – DES), the former is
targeted at ARX-based designs that use modular addition, rather than an S-box, as a source of
non-linearity.
Algorithm 1 [BVC16] exploits the differential properties of modular addition to efficiently search
for characteristics in a bitwise manner. Upon termination, it outputs a trail (characteristic) with
the maximum expected differential trail probability (MEDCP). For Alzette, using search as in
[Liu17, LLJW21] we could obtain such trails for up to seven rounds, where the 7-round bound is
2−26 . We further collected all trails corresponding to the maximum expected differential probability
for 4 and 5 rounds and experimentally checked the actual probabilities of the differentials, see
Section 3.3.10.1.
Note that for 8 rounds, we could not get tight bounds due to the high complexity of the
search. In other words, the algorithm didn’t terminate in reasonable time. However, the algorithm
exhaustively searched the range up to − log2 (𝑝) = 31 for 8 rounds, which proves that there are no
valid differential trails with an expected differential trail probability greater than 2−32 .

36

3.3.4

On the Linear Properties of Alzette

We used the Mixed-Integer Linear Programming approach described in [FWG+ 16] and the Boolean
satisfiability problem (SAT) approach in [LWR16] in order to get bounds on the maximum expected
absolute linear trail correlation. It was feasible to get tight bounds even for 8 rounds, where the
8-round bound for Alzette is 2−17 . We were able to collect all linear trails that correspond to the
maximum expected absolute linear trail correlation for 4 up to to 8 rounds and experimentally
checked the actual correlations of the corresponding linear approximations, see Section 3.3.10.2.

3.3.5

Diffusion in Alzette

Alzette provides very fast diffusion. In particular, all outputs bits depend on all the input bits
after 4 rounds, though this dependency can be very weak. After 8 rounds however, we have that
all output bits strongly depend on all the input bits. This strong diffusion ensures that three steps
of the Sparkle permutations already fulfill the strict avalanche criterion, see Section 4.2.1.

3.3.6

Invariant Subspaces

Invariant subspace attacks were considered in [LAAZ11]. Using a similar to the ”to and fro”
method from [PGC98, BDBP03], we searched for an affine subspace that is mapped by an ARXbox 𝐴𝑐𝑖 to a (possibly different) affine subspace of the same dimension. We could not find any
such subspace of nontrivial dimension.
Note that the search is randomized so it does not result in a proof. As an evidence of the
correctness of the algorithm, we found many such subspace trails for all 2-round reduced ARXboxes, with dimensions from 56 up to 63. For example, let 𝐴 denote the first two rounds of 𝐴𝑐0 .
′ ′
Then for all 𝑙, 𝑟, 𝑙′ , 𝑟′ ∈ F32
2 such that 𝐴(𝑙, 𝑟) = (𝑙 , 𝑟 ),
(𝑙29 + 𝑟21 + 𝑟30 )(𝑙30 + 𝑟31 )(𝑙31 + 𝑟0 )(𝑟22 )(𝑟23 ) =
′
′
′
′
′
′
′
′
′
′
(𝑙4′ + 𝑟21
)(𝑙5′ + 𝑟22
)(𝑙6′ + 𝑟23
)(𝑙28
+ 𝑙30
+ 𝑙31
+ 𝑟13
+ 1)(𝑙29
+ 𝑙31
+ 𝑟14
).

This equation defines a subspace trail of constant dimension 59.

3.3.7

Nonlinear Invariants for Alzette

Nonlinear invariant attacks were considered recently in [TLS16]. Using linear algebra, we experimentally verified that for any Alzette instance 𝐴𝑐𝑖 and any non-constant Boolean function 𝑓 of
degree at most 2, the compositions 𝑓 ∘ 𝐴𝑐𝑖 and 𝑓 ∘ 𝐴−1
𝑐𝑖 have degree at least 10:
−1
∀𝑓 : F64
2 → F2 , 1 ≤ deg(𝑓 ) ≤ 2 deg(𝑓 ∘ 𝐴𝑐𝑖 ) ≥ 10, deg(𝑓 ∘ 𝐴𝑐𝑖 ) ≥ 10,

and for functions 𝑓 of degree at most 3, the compositions have degree at least 4:
−1
∀𝑓 : F64
2 → F2 , 1 ≤ deg(𝑓 ) ≤ 3 deg(𝑓 ∘ 𝐴𝑐𝑖 ) ≥ 4, deg(𝑓 ∘ 𝐴𝑐𝑖 ) ≥ 4.

In particular, any 𝐴𝑐𝑖 has no cubic invariants. Indeed, a cubic invariant 𝑓 would imply that
𝑓 ∘ 𝐴𝑐𝑖 + 𝜀 = 𝑓 is cubic (for a constant 𝜀 ∈ F2 ). The same holds for the inverse of any Alzette
instance 𝐴𝑐𝑖 .
By using the same method, we also verified that there are no quadratic equations relating
inputs and outputs of any 𝐴𝑐𝑖 . However, there are quadratic equations relating inputs and outputs
of 3-round reduced versions of each 𝐴𝑐𝑖 .

3.3.8

Linearization of Alzette instances

In recent attack against Keccak instances [QSLG17, SLG17] the S-box linearization technique is
used. The idea is to find a subset of inputs (often an affine subspace), such that the S-box acts
linearly on this set. We attempted to linearize Alzette instances by finding all inputs for which
all four modular additions inflict no carry bits and thus are equivalent to XOR. For the addition
of two random independent 32-bit words, the probability of having all carry bits equal to zero is
37

equal to (3/4)31 . Indeed, for each bit position, if no carry comes in, then the outgoing carry will
occur only if both input bits are equal to 1. Furthermore, the carry bit from the most significant
bits is ignored. Assuming independence of the additions in Alzette, 264 /(3/4)124 ≈ 212.5 inputs are
expected to satisfy the linearization.
In order to find all inputs, we have to solve a system of quadratic equations. Indeed, for the
first round, the condition is (𝑥 & (𝑦 ≫ 31)) ≪ 1 = 0 (left shift by one omits the most significant
bit), which provides 31 quadratic bit equations. Since this condition ensures that the output of
the first round is linear, we get similar quadratic equations for the second round, except that 𝑥
and 𝑦 are replaced with corresponding linear functions. In total we obtain 124 quadratic equations
of the form 𝑙(𝑥, 𝑦) · 𝑟(𝑥, 𝑦) = 0, where 𝑙, 𝑟 : F64
2 → F2 are affine. We solved this system by a guessand-determine method with a few optimizations, for all Alzette constants that we use. The results
are given in Table 3.3.
constant

hexadecimal

# inputs

example

𝑐0
𝑐1
𝑐2
𝑐3
𝑐4
𝑐5
𝑐6
𝑐7
0
232 − 1

b7e15162
bf715880
38b4da56
324e7738
bb1185eb
4f7c7b57
cfbfa1c8
c2b3293d
00000000
ffffffff

13
11
18
3
10
340
105
76
8
≥ 222

(05600000, 70000225)
(2a001990, 00188000)
(1000c000, 144a0528)
(1000e620, 04270080)
(001c8181, 10808201)
(08301013, 28265722)
(801d8000, 2fd10085)
(00220110, 20001804)
(00000000, 40200080)
(0b11cc51, 72770942)

Table 3.3: The number of inputs for ARX-boxes inflicting no carries in all four rounds, for different
round constants.
The first interesting observation is that the number of solutions is much smaller than 212.5 ≈
5900 predicted under the round independence assumption. For 5 out of 8 used constants, the
number of solutions is less than 20, and the maximum number of solutions is 340. The second
observation is that, for the zero constant, the number of solutions is also extremely low. We find it
rather counter-intuitive, since in absence of constants many low-weight vectors can be expected to
pass through Alzette without inflicting any carries. On the other hand, it turns out that the all-one
constant leads to a larger than expected number of solutions. We observed a similar behaviour
and verified the correctness of our algorithm on 8-bit words, where we performed an exhaustive
search over all Alzette inputs.
We suggest that main reason behind the small numbers of solutions is the strong ARX-box
structure itself, in particular the rotation amounts we used. Note however that other linearization
methods are possible, for example by fixing particular non-zero carry patterns.

3.3.9

On the Round Constants

The purpose of round constant additions, i.e., the XORs with 𝛾𝑖𝐿 , 𝛾𝑖𝑅 in the general ARX-box
structure, is to ensure some independence between the rounds. Furthermore, and in fact much more
importantly, they should ensure that the Alzette instances called on each branch are independent:
If we use the same round constants in all the branches then the permutation is very weak because
of existing symmetries. The fact that such weak constant choice exist is not a bad thing in and on
itself, it simply means that we must use round constants that are different enough in each branch.
For efficiency reasons, we decided to use the same round constant in every round of the ARXbox, i.e., ∀𝑖 : 𝛾𝑖𝐿 = 𝑐. Moreover, we chose all 𝛾𝑖𝑅 = 0. It is important to note that the experimental
verification of the differential probabilities and absolute linear correlations we conducted did not
lead to significant differences when changing to a more complex round constant schedule. In other
words, even for random choices of all 𝛾𝑖𝐿 and 𝛾𝑖𝑅 , we did not observe significantly different results
that would justify the use of a more complex constant schedule (which would of course lead to
worse efficiency in the implementation).
38

In order to be transparent in the way we selected the constants, we derived the eight different
32-bit constants 𝑐0 , . . . , 𝑐7 for the eight Alzette instances from the fractional digits of 𝑒 = 2.71 . . . .
In particular, we converted the number into its base-16 representation and choose 𝑐0 to be the first
block of eight fractional digits, 𝑐1 as the third block, 𝑐2 as the 6th, 𝑐3 as the 9th, 𝑐4 as the 14th,
𝑐5 as the 15th, 𝑐6 as the 26th and 𝑐7 as the 29th block. We excluded several blocks in order to
leverage some observed linear hull effects in our experimental verification for 5 and 6 rounds to
our favor. We give more details on that in Section 3.3.10 below.

3.3.10

Experimental Verifications

3.3.10.1

Experiments on the Fixed-Key Differential Probabilities

As in virtually all block cipher designs, the security arguments against differential attacks are only
average results when averaging over all keys of the primitive. When leveraging such arguments for
a cryptographic permutation, i.e., a block cipher with a fixed key, it might be possible in theory
that the actual fixed-key maximum differential probability is higher than the expected maximum
differential probability. In particular, the variance of the distribution of the maximum fixed-key
differential probabilities might be high.
For all of the 8 Alzette instances used in Sparkle (depending on the constant 𝑐𝑖 ), we conducted
experiments in order to see if the expected maximum differential trail probabilities derived by
Matsui’s search are close to the actual differential probabilities of the fixed instances. Our results
are as follows.
By Matsui’s search we found 7 differential trails for the four-round ARX-box5 that correspond
to the maximum expected differential trail probability of 2−6 , see Table 3.4. For any Alzette
instance 𝐴𝑐𝑖 and any such trails with input difference 𝛼 and output difference 𝛽, we experimentally
computed the actual differential probability of the differential 𝛼 → 𝛽 by
|{𝑥 ∈ 𝑆|𝐴𝑐𝑖 (𝑥) ⊕ 𝐴𝑐𝑖 (𝑥 ⊕ 𝛼) = 𝛽}|
,
|𝑆|
where 𝑆 is a set of 224 inputs sampled uniformly at random. Our results show that the expected
differential trail probabilities approximate the actual differential probabilities very well, i.e., all of
the probabilities computed experimentally are in the range [2−6 − 10−4 , 2−6 + 10−4 ] for a sample
size of 224 .
For 5 rounds, i.e., one iteration of Alzette and one additional first round of Alzette, there is
only one trail with maximum expected differential trail probability 𝑝 = 2−10 . For all combinations
of round constants that can occur in 5 rounds (one iteration of Alzette plus one round) that do not
go into the addition of a step counter, i.e., corresponding to the twelve ARX-box compositions
𝐴𝑐2 ∘ 𝐴𝑐0
𝐴𝑐 5 ∘ 𝐴𝑐 1

𝐴𝑐3 ∘ 𝐴𝑐1
𝐴𝑐6 ∘ 𝐴𝑐2

𝐴𝑐3 ∘ 𝐴𝑐0
𝐴𝑐7 ∘ 𝐴𝑐3

𝐴𝑐4 ∘ 𝐴𝑐1
𝐴𝑐2 ∘ 𝐴𝑐3

𝐴𝑐 5 ∘ 𝐴𝑐 2
𝐴𝑐 3 ∘ 𝐴𝑐 4

𝐴𝑐 4 ∘ 𝐴𝑐 0
𝐴𝑐2 ∘ 𝐴𝑐7 ,

we checked whether the actual differential probabilities are close to the maximum expected differential trail probability. We found that all of the so computed probabilities are in the range
[2−10 − 10−5 , 2−10 + 10−5 ] for a sample size of 228 .
3.3.10.2

Experiments on the Fixed-Key Linear Correlations

Similarly as for the case of differentials, for all of the 8 Alzette instances used in Sparkle, we
conducted experiments in order to see whether the maximum expected absolute linear trail correlations derived by MILP and presented in Table 3.2 are close to the actual absolute correlations
of the linear approximations over the fixed instances. Our results are as follows, and presented in
Table B.1 in Appendix B.
For four rounds, there are 4 trails with a maximum expected absolute trail correlation of 2−2 .
For all of the eight Alzette instances, the actual absolute correlations are very close to the theoretical
5 Note that those are independent of the actual round constants as the probability corresponds to the average
probability over all keys when analyzing Alzette as a block cipher where independent subkeys are used instead of
round constants.

39

Table 3.4: The input and output differences 𝛼, 𝛽 (in hex) of all differential trails over Alzette
corresponding to maximum expected differential trail probability 𝑝 = 2−6 and 𝑝 = 2−10 for four
and five rounds, respectively.
− log2 (𝑝)

rounds

𝛼

𝛽

4

8000010000000080
8000010000000080
0080400180400000
0080400180400000
a0008140000040a0
8002010000010080
8002010000010080

8040410041004041
80c04100410040c1
8000018081808001
8000008080808001
8000010001008001
0101000000030101
0301000000030301

6
6
6
6
6
6
6

5

a0008140000040a0

8201010200018283

10

values and we did not observe any clustering. For more than four rounds, we again checked all
combinations of Alzette instances that do not get a step counter. For five rounds, there are 16 trails
with a maximum expected absolute trail correlation of 2−5 . In our experiments, we can observe
a slight clustering. The observed absolute correlations based on 224 samples can also be found in
Table B.1. The minimum and maximum refers to the minimum, resp., maximum observed absolute
correlations over all the combinations of Alzette instances that do not get a step counter, similar
as tested for differentials. We chose the initial round constants 𝑐𝑖 such that, for all combinations
of ARX-boxes that occur over the linear layer, the linear hull effect is to our favor, i.e., the actual
absolute correlation tends to be lower than the theoretical value. For the excluded blocks of the
fractional digits of 𝑒, the actual absolute correlations are slightly higher (but all smaller than 2−8 ).
This tendency also holds for the correlations over six rounds. There are 48 trails with a
maximum expected absolute linear trail correlation of 2−8 . The results of our experiments for 228
random samples are shown in Table B.2 in Appendix B.
For seven rounds, there are 2992 trails with a maximum expected absolute linear trail correlation
of 2−13 . Over all the twelve combinations that don’t add a step counter and all of the 2992
approximations, the maximum absolute correlation we observed was 2−11.64 using a sample size of
232 plaintexts chosen uniformly at random.
For eight rounds, there are 3892 trails with a maximum expected absolute linear trail correlation
of 2−17 . Over all the twelve combinations that don’t add a step counter and all of the 3892
approximations, the maximum absolute correlation we observed was 2−15.79 using a sample size of
240 plaintexts chosen uniformly at random.
3.3.10.3

Experimental Algebraic Degree Lower Bound

The modular addition is the only non-linear operation in Alzette. Its algebraic degree is 31 and
thus, in each 4-round ARX-box, there must exist some output bits of algebraic degree at least 32.
We experimentally checked that, for each 𝐴𝑐𝑖 , the algebraic degree of each output bit is at least
32. In particular, for each output bit we found
monomial of degree 32 that occurs in its ANF.
∏︀a𝑚−1
Note that for checking whether the monomial 𝑖=0 𝑥𝑖𝑚 occurs in the ANF of a Boolean function
𝑓 one has to evaluate 𝑓 on 2𝑚 inputs.
3.3.10.4

Division Property of the ARX-box Structure

Division property is a technique introduced by Todo [Tod15] to find integral characteristics. Originally, it was applied to substitution-permutation networks and Feistel networks. Later, bit-based
division property was proposed by Todo and Morii [TM16] and applied to the Simon block cipher
with 32-bit blocks. Due to the high computation complexity of the search algorithm, it is infeasible
to apply the technique to ciphers with larger block sizes. However, Xiang et al. [XZBL16] discovered that the bit-based division property propagation can be efficiently encoded as an mixed-integer
linear programming instance (MILP), and, surprisingly, can be solved on practice using modern
optimization software (Gurobi Optimizer [GO18]) for practically all known block ciphers. Sun et
40

Table 3.5: Look-up table of 𝑓 .

Table 3.6: Division property propagation table of 𝑓 .

input output input output

input outputs

000
001
010
011

000
001
010
011

00
01
01
10

100
101
110
111

01
10
10
11

{00}
{01, 10}
{01, 10}
{10}

input outputs
100
101
110
111

{01, 10}
{10}
{10}
{11}

al. [SWW17] described a way to encode the modular addition operation using MILP inequalities,
extending the framework to ARX-based primitives.
For further information on division property propagation and its encoding using MILP inequalities, we refer to [XZBL16]. However, we describe briefly a new technique for encoding division
property propagation through the modular addition. Our technique is simpler and more compact
than the one proposed by Sun et al. [SWW17].
Addition modulo 232 . The method by Sun et al. is based on expressing the modular addition
as a Boolean circuit and applying the standard known encoding for xorand andoperations. As a
result, for each bit of a word at least 12 bit operations are produced. We propose a new simple
method which requires only 2 inequalities per bit.
Our key idea is to compute the carry bits and the output bits in pairs using a 3 × 2 bit look-up
table. The division property propagation through this look-up table can be encoded using only 2
inequalities.
Consider an addition of two 𝑛-bit words 𝑎, 𝑏 ∈ F𝑛2 and let 𝑦 = 𝑎  𝑏 mod 2𝑛 (recall that 𝑎0
denotes the most significant bit of 𝑎, 𝑎𝑛−1 denotes the least significant bit of 𝑎, etc.). Define carry
bits 𝑐𝑖 , −1 ≤ 𝑖 < 𝑛 as follows: 𝑐𝑛−1 = 0 and 𝑐𝑖 = Maj(𝑎𝑖+1 , 𝑏𝑖+1 , 𝑐𝑖+1 ) for −1 ≤ 𝑖 < 𝑛 − 1, where
Maj is the 3-bit majority function. Then it is easy to verify that 𝑦𝑖 = 𝑎𝑖 ⊕ 𝑏𝑖 ⊕ 𝑐𝑖 for all 0 ≤ 𝑖 < 𝑛.
Full modular addition can be computed sequentially from 𝑖 = 𝑛 − 1 to 𝑖 = 0. Let 𝑓 : F32 → F22 be
such that 𝑓 (𝑎, 𝑏, 𝑐) = (Maj(𝑎, 𝑏, 𝑐), 𝑎 ⊕ 𝑏 ⊕ 𝑐), then we can write
(𝑐𝑖−1 , 𝑦𝑖 ) = 𝑓 (𝑎𝑖 , 𝑏𝑖 , 𝑐𝑖 ),
for all 0 ≤ 𝑖 < 𝑛. The lookup table of 𝑓 is given in Table 3.5. Note that no bits are copied in the
sequential computation process. It follows that the division property propagation can be encoded
directly by encoding 𝑛 sequential applications of 𝑓 (using the S-Box encoding methods by Xiang et
al. [XZBL16]). Finally, an additional constraint is needed to ensure that the resulting division
property is not active in the bit 𝑐−1 .
The division property propagation table is given in Chapter 3.6. This table can be characterized
by the two following integer inequalities:
{︃
−𝑎 − 𝑏 − 𝑐 + 2𝑐′ + 𝑦 ≥ 0,
𝑎 + 𝑏 + 𝑐 − 2𝑐′ − 2𝑦 ≥ −1,
where 𝑎, 𝑏, 𝑐 ∈ Z2 correspond to the values of the input division property and 𝑐′ , 𝑦 ∈ Z2 correspond
to the values of the output division property. In our experiments, these two inequalities applied for
each bit position generate precisely the correct division property propagation table of the addition
modulo 2𝑛 for 𝑛 up to 7. There are a few redundant transitions, but they do not affect the result.
An alternative to MILP-solvers that is used for division property analysis are SMT-solvers.
To facilitate this alternative method, we characterize the division property propagation table of
𝑓 by four Boolean propositions (obtained by enumerating all possible outputs and constraining
respective inputs):
⎧ ′
𝑐 ∧𝑦
⇒ 𝑎 ∧ 𝑏 ∧ 𝑐,
◁𝑎=𝑏=𝑐=1
⎪
⎪
⎨
¬𝑐′ ∧ ¬𝑦
⇒ ¬𝑎 ∧ ¬𝑏 ∧ ¬𝑐,
◁𝑎=𝑏=𝑐=0
¬𝑐′ ∧ 𝑦
⇒ (𝑎 ⊕ 𝑏 ⊕ 𝑐) ∧ (¬𝑎 ∨ ¬𝑏),
◁ 𝑎+𝑏+𝑐=1
⎪
⎪
⎩ ′
𝑐 ∧ ¬𝑦
⇒ (𝑎 ∨ 𝑏 ∨ 𝑐) ∧ (¬𝑎 ∨ ¬𝑏 ∨ ¬𝑐).
◁ 1≤𝑎+𝑏+𝑐≤2
We used this representation together with the Boolector SMT-solver [NPB15] (version 3.1.0) to
verify our results.
41

For completeness, we also provide a pure SAT encoding (CNF - a conjunction normal form) of
the propagation through 𝑓 (11 clauses):
(𝑎 ∨ 𝑏 ∨ 𝑐 ∨ ¬𝑦) ∧ (𝑎 ∨ 𝑏 ∨ 𝑐 ∨ ¬𝑐′ ) ∧ (𝑎 ∨ ¬𝑐′ ∨ ¬𝑦) ∧ (𝑏 ∨ ¬𝑐′ ∨ ¬𝑦)
∧ (¬𝑐 ∨ 𝑐′ ∨ 𝑦) ∧ (¬𝑏 ∨ 𝑐′ ∨ 𝑦) ∧ (¬𝑏 ∨ ¬𝑐 ∨ 𝑐′ ) ∧ (¬𝑎 ∨ 𝑐′ ∨ 𝑦)
∧ (¬𝑎 ∨ ¬𝑐 ∨ 𝑐′ ) ∧ (¬𝑎 ∨ ¬𝑏 ∨ 𝑐 ∨ ¬𝑦) ∧ (¬𝑎 ∨ ¬𝑏 ∨ ¬𝑐 ∨ 𝑦).

Finally, we note that subtraction modulo 2𝑛 , used in the inverse of Alzette, is equivalent to the
addition with respect to the division property propagation in our method. Indeed, let 𝑓 ′ : F32 → F22 ,
𝑓 ′ (𝑎, 𝑏, 𝑐) = (𝑐′ , 𝑦) = ([𝑎 − 𝑏 − 𝑐 < 0], 𝑎 ⊕ 𝑏 ⊕ 𝑐),
where the first coordinate of 𝑓 ′ computes the subtraction carry bit. It is in fact equivalent to the
first coordinate of 𝑓 (the majority function) up to xorwith constants:
[𝑎 − 𝑏 − 𝑐 < 0] = [𝑎 + (1 − 𝑏) + (1 − 𝑐) < 2]

= 1 − [𝑎 + (1 − 𝑏) + (1 − 𝑐) ≥ 2] = 1 ⊕ 𝑓0 (𝑎, 1 ⊕ 𝑏, 1 ⊕ 𝑐).

We conclude that 𝑓 ′ has the same division property propagation table as 𝑓 and thus division
property propagation using our method is the same for modular addition and subtraction.
Division property propagation in Alzette. First, we evaluated the general algebraic degree of
the ARX-box structure based on the division property. The 5𝑡ℎ and 6𝑡ℎ rounds rotation constants
were chosen as the 1𝑠𝑡 and 2𝑛𝑑 rounds rotation constants respectively, as this will happen when two
Alzette instances will be chained. The inverse ARX-box structure starts with 4𝑡ℎ round rotation
constants, then 3𝑟𝑑 , 2𝑛𝑑 , 1𝑠𝑡 , 4𝑡ℎ , etc. The minimum and maximum degree among coordinates of
the ARX-box structure and its inverse are given in Table 3.7. Even though these are just upper
Table 3.7: The upper bounds on the minimum and maximum degree of the coordinates of Alzette
and its inverse.
ARX-box
rounds

1

2

3

4

ARX-box
inverse
rounds

1

2

3

4

min
max

1
32

10
62

42
63

63
63

min
max

1
32

2
62

32
63

46
63

bounds, we expect that they are close to the actual values, as the division property was shown to
be rather precise [TM16]. Thus, the ARX-box structure may have full degree in all its coordinates,
but the inverse of the ARX-box has a coordinate of degree 46.
The block-size level division property of Alzette is such that, for any 1 ≤ 𝑘 ≤ 62, 𝒟𝑘64 maps to
64
64
maps to 𝒟264 after two rounds and to 𝒟164 after three rounds. The
𝒟1 after two rounds, and 𝒟63
same holds for the inverse structure of Alzette.
The longest integral characteristic found with bit-based division property is for 6-round ARXbox, where the input has 63 active bits and the inactive bit is at the index 44 (i.e., there are 44
active bits from the left and 19 active bits from the right), and in the output 16 bits are balanced:
input active bits:
11111111111111111111111111111111,11111111111101111111111111111111,
balanced bits after 6-round ARX-box:
????????????????????????BBBBBBBB,?????????BBBBBBBB???????????????.
The inactive bit can be moved to indexes 45, 46, 47, 48 as well, the balanced property after 6 round
stays the same. For the 7-round ARX-box we did not find any integral distinguishers.

42

For the inverse ARX-box, the longest integral characteristic is for 5 rounds:
input active bits:
11111111111111111111111111101111,11111111111111111111111111111111,
balanced bits after 5-round ARX-box inverse:
???????????????????????????????B,???????BBBBBBBBB????????????????.
For the ARX-box inverse with 6-rounds we did not find any integral characteristic.
As a conclusion, even though a single Alzette iteration has integral characteristics, for two
chained Alzette instances there are no integral characteristics that can be found using the state-ofthe-art division property method.

3.3.11

Summary of the Properties of Alzette

Our experimental results validate our theoretical analysis of the properties of Alzette: in practice,
the differential and linear trail probabilities (resp., absolute correlations) are as predicted. In the
case of differential probabilities, the clustering is minimal. While it is not quite negligible in the
linear case, it does not pose a threat to Sparkle in practice (see Section 4.2.3).
The diffusion is fast: all output bits depend on all input bits after a single call of Alzette–
though the dependency may be sometimes weak. After a double Alzette call, diffusion is of course
complete. Furthermore, as evidenced by our analysis of the division property of our component,
no integral distinguisher exist in this case.
While the two components have utterly different structures, our ARX-box Alzette has similar
properties to one round of AES and the double ARX-box to its super-S-box (see Table 3.8). The
bounds for the (double) iteration of Alzette come from Table 3.2. For the AES, the bounds for a
single rounds are derived from the properties of its S-box, so its maximum differential probability
is 4/256 = 2−6 and its maximum absolute linear correlation is 2−3 . For two rounds, the differential
trail bound is 2−30 and the linear one is 2−15 : as the branching number of the MixColumn operation
is 5, we raise the quantities of the S-box to the power 5.
Table 3.8: A comparison of the properties of Alzette with those of the AES with a fixed key.
MEDCP denotes the maximum expected differential trail probability and MELCC denotes the
maximum expected absolute linear trail correlation.
MEDCP

MELCC

Alzette
AES S-box layer

2−6
2−6

2−2
2−3

Double Alzette
AES super S-box layer

≤ 2−32
2−30

2−17
2−15

We emphasize that our experimental verifications were enabled by our use of a key-less structure.
For a block cipher, we would need to look at all possible keys to reach the same level of confidence.

3.4

The Linear Layer

3.4.1

Overall Structure

The Alzette layer ensures that no pattern exists at the branch level that a cryptanalyst could leverage to mount an attack. However, we need to provide diffusion between the branches. Furthermore,
as the Alzette layer needs two steps (i.e., 8 rounds) to obtain good differential and linear bounds,
we have to follow the long trail approach and ensure that long trails exist in all differential and
linear trails. Hence, our linear layer has to provide two apparently opposite properties: diffusion
between the branches and little diffusion to help fostering long trails.

43

To solve this problem, we copy the technique that we initially introduced when designing
SPARX and use a linear layer with a Feistel structure. Intuitively, it leaves one half of the state
unchanged and thus ensures the existence of long trails. At the same time, the Feistel function
itself provides excellent diffusion, meaning that we can quickly ensure that all branches in the state
depend on all the branches in the input.

3.4.2

The Linear Feistel Function

In what follows, we establish several lemmas and theorems that describe the behaviour of the linear
Feistel functions ℳ𝑤 that are used in Sparkle instances.
Lemma 3.4.1. Let 𝑤 > 2 be an integer. If 𝑤 is even then the inverse of ℳ𝑤 is computed as
𝑡𝑦 ←

𝑤−1
⨁︁
𝑖=0

𝑣𝑖 , 𝑡 𝑥 ←

𝑤−1
⨁︁

𝑢𝑖 ,

𝑖=0

𝑥𝑖 ← 𝑢𝑖 ⊕ ℓ(𝑡𝑦 ), ∀𝑖 ∈ {0, ..., 𝑤 − 1} ,
𝑦𝑖 ← 𝑣𝑖 ⊕ ℓ(𝑡𝑥 ), ∀𝑖 ∈ {0, ..., 𝑤 − 1} ,

i.e., it is ℳ𝑤 itself. On the other hand, if 𝑤 is odd, it is computed as
𝑡𝑣 ←

𝑤−1
⨁︁
𝑖=0

𝑣𝑖 , 𝑡 𝑢 ←

𝑤−1
⨁︁

𝑢𝑖 ,

𝑖=0

𝑥𝑖 ← 𝑢𝑖 ⊕ 𝑡𝑣 ⊕ ℓ(𝑡𝑢 ), ∀𝑖 ∈ {0, ..., 𝑤 − 1} ,
𝑦𝑖 ← 𝑣𝑖 ⊕ 𝑡𝑢 ⊕ ℓ(𝑡𝑣 ), ∀𝑖 ∈ {0, ..., 𝑤 − 1} .

⨁︀𝑤−1
⨁︀𝑤−1
Proof. The proof in the even case is very straight-forward because
𝑖=0 𝑥𝑖 =
𝑖=0 𝑢𝑖 and
⨁︀𝑤−1
⨁︀𝑤−1
𝑖=0 𝑦𝑖 =
𝑖=0 𝑣𝑖 . Let us therefore consider the case where 𝑤 is odd.
In order to obtain (𝑥𝑖 , 𝑦𝑖 ) from (𝑢𝑖 , 𝑣𝑖 ), we need to obtain the values of ℓ(𝑡𝑥 ) and ℓ(𝑡𝑦 ) from the
(𝑢𝑖 , 𝑣𝑖 ). We remark that
𝑡𝑢 =

𝑤−1
⨁︁
𝑖=0

𝑡𝑣 =

𝑤−1
⨁︁
𝑖=0

(𝑥𝑖 ⊕ ℓ(𝑡𝑦 )) = 𝑡𝑥 ⊕ ℓ(𝑡𝑦 ),
(𝑦𝑖 ⊕ ℓ(𝑡𝑥 )) = 𝑡𝑦 ⊕ ℓ(𝑡𝑥 ).

As a consequence, we need to invert the matrix corresponding to the linear application mapping
(𝑡𝑥 , 𝑡𝑦 ) to (𝑡𝑢 , 𝑡𝑣 ) in the expressions above. The solution is easily verified to be
𝑡𝑥 = ℓ−1 (𝑡𝑢 ) ⊕ 𝑡𝑣 ,

𝑡𝑦 = 𝑡𝑢 ⊕ ℓ−1 (𝑡𝑣 ) .

We deduce that if 𝑢𝑖 = 𝑥𝑖 ⊕ ℓ(𝑡𝑦 ) and 𝑣𝑖 = 𝑦𝑖 ⊕ ℓ(𝑡𝑥 ), then
(︀
)︀
𝑥𝑖 = 𝑢𝑖 ⊕ ℓ 𝑡𝑢 ⊕ ℓ−1 (𝑡𝑣 ) = 𝑢𝑖 ⊕ 𝑡𝑣 ⊕ ℓ(𝑡𝑢 ),
(︀
)︀
𝑦𝑖 = 𝑣𝑖 ⊕ ℓ ℓ−1 (𝑡𝑢 ) ⊕ 𝑡𝑣 = 𝑢𝑖 ⊕ ℓ(𝑡𝑣 ) ⊕ 𝑡𝑢 .
We also remark that ℓ𝑇𝑤 = ℓ𝑤 . To see it, we simply write it as a 2 × 2 matrix operating on
16-bit words using ℐ to denote the 16 × 16 identity matrix and 0 to denote the 16 × 16 zero matrix,
and we obtain that
[︂
]︂
0 ℐ
ℓ=
,
ℐ ℐ

44

which is symmetric. For completeness, we provide detailed matrices of the linear Feistel functions
ℳ2 , ℳ3 , ℳ4 used respectively in Sparkle256𝑛𝑠 , Sparkle384𝑛𝑠 , Sparkle512𝑛𝑠 . In the following
equation note that, despite the simple structure of ℳℎ𝑏 , the matrices are rather dense.
⎡ℐ
ℐ
⎢0
⎢
⎢0
⎢
⎢ℐ
ℳ2 = ⎢
⎢0
⎢0
⎢
⎣0
ℐ
⎡

0
ℐ
ℐ
ℐ
0
0
ℐ
ℐ

0
ℐ
ℐ
0
0
ℐ
0
0

ℐ
ℐ
0
ℐ
ℐ
ℐ
0
0

0
0
0
ℐ
ℐ
0
0
ℐ

0
0
ℐ
ℐ
0
ℐ
ℐ
ℐ

0
ℐ
0
0
0
ℐ
ℐ
0

⎡ℐ

0
ℐ
ℐ
ℐ
0
0
ℐ
ℐ
0
0
ℐ
ℐ
0
0
ℐ
ℐ

0
ℐ
ℐ
0
0
ℐ
0
0
0
ℐ
0
0
0
ℐ
0
0

ℐ
ℐ
0
ℐ
ℐ
ℐ
0
0
ℐ
ℐ
0
0
ℐ
ℐ
0
0

⎢0
⎢0
⎢
⎢ℐ
⎢
⎢0
⎢
⎢0
⎢
⎢0
⎢
⎢ℐ
ℳ4 = ⎢
⎢0
⎢
⎢0
⎢
⎢0
⎢
⎢ℐ
⎢
⎢0
⎢
⎢0
⎣
0
ℐ

⎢0
⎤
⎢0
ℐ
⎢
⎢ℐ
ℐ⎥
⎢
⎥
⎢0
0⎥
⎢
⎥
⎢0
0⎥
⎥ , ℳ3 = ⎢
⎢0
ℐ⎥
⎢
⎥
⎢ℐ
ℐ⎥
⎢
⎦
⎢0
0
⎢
⎢0
ℐ
⎣
0
ℐ

0
ℐ
ℐ
ℐ
0
0
ℐ
ℐ
0
0
ℐ
ℐ

0
ℐ
ℐ
0
0
ℐ
0
0
0
ℐ
0
0

ℐ
ℐ
0
ℐ
ℐ
ℐ
0
0
ℐ
ℐ
0
0

0
0
0
ℐ
ℐ
0
0
ℐ
0
0
0
ℐ

0
0
ℐ
ℐ
0
ℐ
ℐ
ℐ
0
0
ℐ
ℐ

0
ℐ
0
0
0
ℐ
ℐ
0
0
ℐ
0
0

ℐ
ℐ
0
0
ℐ
ℐ
0
ℐ
ℐ
ℐ
0
0

0
0
0
ℐ
0
0
0
ℐ
ℐ
0
0
ℐ

ℐ
ℐ
0
0
ℐ
ℐ
0
ℐ
ℐ
ℐ
0
0
ℐ
ℐ
0
0

0
0
0
ℐ
0
0
0
ℐ
ℐ
0
0
ℐ
0
0
0
ℐ

0
0
ℐ
ℐ
0
0
ℐ
ℐ
0
ℐ
ℐ
ℐ
0
0
ℐ
ℐ

0
ℐ
0
0
0
ℐ
0
0
0
ℐ
ℐ
0
0
ℐ
0
0

ℐ
ℐ
0
0
ℐ
ℐ
0
0
ℐ
ℐ
0
ℐ
ℐ
ℐ
0
0

0
0
0
ℐ
0
0
0
ℐ
0
0
0
ℐ
ℐ
0
0
ℐ

0
0
ℐ
ℐ
0
0
ℐ
ℐ
0
0
ℐ
ℐ
0
ℐ
ℐ
ℐ

0
ℐ
0
0
0
ℐ
0
0
0
ℐ
0
0
0
ℐ
ℐ
0

ℐ⎤
ℐ⎥
0⎥
⎥
0⎥
⎥
ℐ⎥
⎥
ℐ⎥
⎥
0⎥
⎥
0⎥
⎥.
ℐ⎥
⎥
ℐ⎥
⎥
0⎥
⎥
0⎥
⎥
ℐ⎥
⎥
ℐ⎥
⎦
0
ℐ

0
0
0
ℐ
ℐ
0
0
ℐ
0
0
0
ℐ
0
0
0
ℐ

0
0
ℐ
ℐ
0
ℐ
ℐ
ℐ
0
0
ℐ
ℐ
0
0
ℐ
ℐ

0
ℐ
0
0
0
ℐ
ℐ
0
0
ℐ
0
0
0
ℐ
0
0

0
0
ℐ
ℐ
0
0
ℐ
ℐ
0
ℐ
ℐ
ℐ

0
ℐ
0
0
0
ℐ
0
0
0
ℐ
ℐ
0

ℐ⎤
ℐ⎥
0⎥
⎥
0⎥
⎥
ℐ⎥
⎥
ℐ⎥
⎥,
0⎥
⎥
0⎥
⎥
ℐ⎥
⎥
ℐ⎥
⎦
0
ℐ

We deduce the following lemma.
Lemma 3.4.2. The matrix representation of the function ℳ𝑤 is symmetric.
The key properties of such linear permutations in terms of diffusion are given by the following
theorem.
Theorem 3.4.1. For all 𝑤 > 1, ℳ𝑤 is such that:
∙ a unique active branch in the input activates all output branches,
∙ a unique active branch in the output requires that all input branches are active,
∙ if 𝑤 > 2 and there are two active branches with indices 𝑗 and 𝑘 in the input, then one of the
following must occur:
– only the branches 𝑗 and 𝑘 are active in the output,
– all the output branches are active except for 𝑗,
– all the output branches are active except for 𝑘, or
– all the output branches are active.
Proof. We prove each point separately.
Case with 1 input. Without loss of generality, suppose that (𝑥0 , 𝑦0 ) ̸= (0, 0) and that (𝑥𝑖 , 𝑦𝑖 ) =
(0, 0) for all 𝑖 > 0. Then 𝑡𝑥 = 𝑥0 and 𝑡𝑦 = 𝑦0 , so that
𝑢𝑖 = 𝑥𝑖 ⊕ ℓ(𝑦0 ) and 𝑣𝑖 = 𝑦𝑖 ⊕ ℓ(𝑥0 ) .
If 𝑖 ̸= 0, then 𝑢𝑖 = ℓ(𝑦0 ) and 𝑣𝑖 = ℓ(𝑥0 ). Thus, we have
(︀
)︀
(𝑢𝑖 , 𝑣𝑖 ) = ℓ(𝑦0 ), ℓ(𝑥0 ) , if 𝑖 ̸= 0 ,
(︀
)︀
(𝑢0 , 𝑣0 ) = 𝑥0 ⊕ ℓ(𝑦0 ), 𝑦0 ⊕ ℓ(𝑥0 ) ,
so that each pair (𝑢𝑖 , 𝑣𝑖 ) is the output of a permutation with input (𝑥0 , 𝑦0 ) (recall that
𝑥 ↦→ 𝑥 ⊕ ℓ(𝑥) is a permutation). Since we assume (𝑥0 , 𝑦0 ) ̸= (0, 0), we deduce that all (𝑢𝑖 , 𝑣𝑖 )
are non-zero.

45

Case with 1 output. If 𝑤 is even, the inverse of ℳ𝑤 is ℳ𝑤 itself. We can therefore reuse the
same argument as above. Suppose now that 𝑤 is odd. Without loss of generality, we consider
that (𝑢0 , 𝑣0 ) ̸= (0, 0) and that (𝑢𝑖 , 𝑣𝑖 ) = (0, 0) for all 𝑖 > 0. In this case, we have 𝑡𝑢 = 𝑢0 and
𝑡𝑣 = 𝑣0 , so that
(︀
)︀
(𝑥0 , 𝑦0 ) = 𝑢0 ⊕ 𝑣0 ⊕ ℓ(𝑢0 ), 𝑣0 ⊕ 𝑢0 ⊕ ℓ(𝑣0 ) ,
(︀
)︀
(𝑥𝑖 , 𝑦𝑖 ) = 𝑣0 ⊕ ℓ(𝑢0 ), 𝑢0 ⊕ ℓ(𝑣0 ) , if 𝑖 ̸= 0 ,
We deduce that (𝑥𝑖 , 𝑦𝑖 ) is always a permutation of (𝑢0 , 𝑣0 ) for 𝑖(︀ ̸= 0 and thus cannot be)︀
zero. It is also the case for 𝑖 = 0. Indeed, we have (𝑥0 , 𝑦0 ) = (ℓ2 (𝑢0 ) ⊕ 𝑣0 , 𝑢0 ⊕ ℓ2 (𝑣0 )
because I + ℓ = ℓ2 = ℓ−1 , so that the function mapping (𝑢0 , 𝑣0 ) to (𝑥0 , 𝑦0 ) is the inverse of
(𝑥, 𝑦) ↦→ (𝑥 ⊕ ℓ(𝑦), 𝑦 ⊕ ℓ(𝑥)). In particular, it is a permutation as well.
We conclude that if a unique branch is active in the output then all branches are active in
the input.

Case with 2 inputs. Suppose now that 𝑤 > 2 and that (𝑥𝑗 , 𝑦𝑗 ) ̸= (0, 0), (𝑥𝑘 , 𝑦𝑘 ) ̸= (0, 0) and
(𝑥𝑖 , 𝑦𝑖 ) = (0, 0) otherwise. In this case, we have 𝑡𝑥 = 𝑥𝑗 ⊕ 𝑥𝑘 and 𝑡𝑦 = 𝑦𝑗 ⊕ 𝑦𝑘 so that
(︀
)︀
(𝑢𝑗 , 𝑣𝑗 ) = 𝑥𝑗 ⊕ ℓ(𝑦𝑗 ⊕ 𝑦𝑘 ), 𝑦𝑗 ⊕ ℓ(𝑥𝑗 ⊕ 𝑥𝑘 ) ,
(︀
)︀
(𝑢𝑘 , 𝑣𝑘 ) = 𝑥𝑘 ⊕ ℓ(𝑦𝑗 ⊕ 𝑦𝑘 ), 𝑦𝑘 ⊕ ℓ(𝑥𝑗 ⊕ 𝑥𝑘 ) ,
(︀
)︀
(𝑢𝑖 , 𝑣𝑖 ) = ℓ(𝑦𝑗 ⊕ 𝑦𝑘 ), ℓ(𝑥𝑗 ⊕ 𝑥𝑘 ) , if 𝑖 ̸∈ {𝑗, 𝑘} .
If (𝑢𝑖 , 𝑣𝑖 ) = (0, 0) for some 𝑖 ̸∈ {𝑗, 𝑘} then (𝑢𝑖 , 𝑣𝑖 ) = (0, 0) for all 𝑖 ̸∈ {𝑗, 𝑘} and we have both
𝑥𝑗 = 𝑥𝑘 and 𝑦𝑗 = 𝑦𝑘 . Hence, we have (𝑢𝑗 , 𝑣𝑗 ) = (𝑥𝑗 , 𝑦𝑗 ) ̸= (0, 0) and (𝑢𝑘 , 𝑣𝑘 ) = (𝑥𝑘 , 𝑦𝑘 ) ̸=
(0, 0), so that both branches 𝑗 and 𝑘 have to be active.
Finally, we suppose that (𝑢𝑖 , 𝑣𝑖 ) ̸= (0, 0) for some 𝑖 ̸∈ {𝑗, 𝑘}. In this case, we have (𝑢𝑖 , 𝑣𝑖 ) ̸=
(0, 0) for all 𝑖 ̸∈ {𝑗, 𝑘} and we cannot have both (𝑢𝑗 , 𝑣𝑗 ) = (0, 0) and (𝑢𝑘 , 𝑣𝑘 ) = (0, 0). Indeed,
if it were the case then we would have
𝑥𝑗 = ℓ(𝑦𝑗 ⊕ 𝑦𝑘 ), 𝑦𝑗 = ℓ(𝑥𝑗 ⊕ 𝑥𝑘 )

𝑥𝑘 = ℓ(𝑦𝑗 ⊕ 𝑦𝑘 ), 𝑦𝑘 = ℓ(𝑥𝑗 ⊕ 𝑥𝑘 ) ,
which in turn implies 𝑥𝑗 = 𝑥𝑘 and 𝑦𝑗 = 𝑦𝑘 , leading to 𝑥𝑗 = 𝑥𝑘 = 𝑦𝑗 = 𝑦𝑘 = 0 and thus to a
contradiction.

Corollary 3.4.1. If 𝑤 > 2 then the differential branch number of ℳ𝑤 is 4. If 𝑤 = 2 then
the differential branch number of ℳ2 is 3. As a consequence, ℳ2 and ℳ3 (which are used in
Sparkle256 and Sparkle384 respectively) are MDS.
Proof. If 𝑤 > 2 then an input with one active branch will activate all 𝑤 ≥ 3 outputs. Thus, the
transition weights 1 → 1 and 1 → 2 are impossible. Conversely, using that a weight 1 output
pattern must yield an input with all 𝑤 ≥ 3 inputs active, we deduce that the weight transition
2 → 1 is impossible as well. The branching number is thus at least equal to 4. As transitions
2 → 2 are possible, this bound is tight.
If 𝑤 = 2 then the transitions with weight 1 → 1 are impossible as one active branch is always
mapped to 2 and, conversely, a unique active output branch implies 2 active ones in the input.
Hence, the branching number is 3 in this case.

3.5

On the Number of Steps

In this section, we outline the security margins depending on the number of steps of the Sparkle
instances used in the AEAD and hashing schemes. Each of our schemes employs a big and a slim
version of an underlying Sparkle permutation. For design simplicity, we decided to use the same
number of steps for the big permutations both in the AEAD and hashing schemes, as well as the
same number of steps for the slim permutations in both functionalities.
46

We emphasize that the security evaluation with regard to differential and linear attacks is based
on the bounds obtained by the LTS and therefore the above margins are derived under the worsecase assumption that differential and linear trails matching our bounds exist. In other words, we
did not find actual attacks on the (round-reduced) schemes that correspond to those bounds and
might actually be vastly overestimating the abilities of the adversary. Especially for the case where
we had to use the worse bounds corresponding to outer part to anything trails in order to be as
conservative as possible (see below), we expect a much higher margin in practice.

3.5.1

In the Big Versions

We are aiming for security of Sparkle in the sense that no distinguishers exist with both a time
𝑏
and data complexity lower than 2 2 , where 𝑏 is the block size of the permutation in bits. In
particular, this means that we need 6, 7, and 7 steps of Sparkle256, Sparkle384 and Sparkle512, respectively, in order to prevent differential and linear distinguishers based on the bounds of
the LTS (see Tables 4.3 and 4.4). All other attacks that we evaluated covered fewer steps. For the
final choice of the number of steps, we added four steps as a security margin for Sparkle256 and
Sparkle384 (three steps for full diffusion plus one additional step), and five steps as a security
margin for Sparkle512 (since it is intended for a higher security level), thus choosing 10, 11 and
12 steps for the big instances of Sparkle256, Sparkle384 and Sparkle512, respectively. The
reason for adding one, resp., two additional step after the three steps for full diffusion is that we can
easily afford it without impacting the actual performance of our schemes significantly, thus leading
to a more conservative design. As the big versions of the permutations are used for initializing the
state with a secret key in the AEAD schemes, a more conservative approach seems reasonable. It
total, this gives us a security margin of 66%, 57% and 71%, respectively.

3.5.2

In the Slim Versions

The slim version of the Sparkle permutations are designed to offer security against distinguishers
in which the adversary can only control the outer part of the state when the permutation is
employed in a sponge. There are different security bounds to consider depending on whether
the permutation is employed in Schwaemm or Esch. For the AEAD schemes Schwaemm, the
domain separation constant that is XORed in the last block is in the inner part. Therefore,
the adversary could have the ability to inject a difference in the inner part of the last padded
block. In order to prevent attacks based on this possibility, we consider the bounds in Table 4.7
corresponding to the ”outer part to anything” trails, i.e., where the input difference is constrained
to be in the outer part only, but the output difference can be on the whole state. Note that
we are using a big permutation for separating the associated data processing from the message
encryption part because the adversary might be able to inject an input difference into the inner
part of the last (padded) block through the domain separation constant. For Esch, we consider
the bounds corresponding to the outer part to outer part trails (where the rate is always 2𝑏 because
of the indirect injection). With regard to linear attacks, we use the bounds of the outer part to
outer part trails given in Table 4.8 for Esch. For Schwaemm, we have to use the bounds for the
permutation (i.e., Table 4.4) because of the rate-whitening layer that introduces linear masks in
the inner part.
Note that in Esch, the security level to achieve with regard to differential attacks is 2𝑐 + 𝑟. The
security level with regard to linear attacks in Schwaemm is determined by the data limit.
Sparkle256 is only employed in our AEAD schemes. To offer a security level of 128 bit, for
Sparkle256, we need five steps to prevent differential and linear attacks. For a differential attack,
5 steps are sufficient to prevent outer part to anything differential trails with a probability under
2−128 (see Table 4.7). For linear attacks, this bound is obtained already after four steps assuming
a data limit of 264 blocks. Recall that the estimated data complexity for a linear attack is at least
1/𝑝2 , where 𝑝 denotes the absolute correlation of the linear approximation used. Hence, we need
only to ensure an upperbound of 2−32 on the absolute correlation of linear trails, see Table 4.4.
The best distinguishers we found with regard to other attacks in this sponge settings cover fewer
steps (see Section 4.3).

47

Sparkle384 is employed in three of our schemes. For Schwaemm256-128, we need a security
level of 128 bit for the underlying permutation, restricting the user to encrypt at most 264 blocks
with one key. The rate of the sponge is 𝑟 = 256 and four steps are sufficient to prevent linear and
differential distinguishers according to the LTS bounds. Also, the longest of the other distinguishers
we found covers no more than four steps. In Schwaemm192-192, we need a security level of 192
bit for the underlying permutation, restricting the user to encrypt at most 264 blocks with one key.
The rate of the sponge is 𝑟 = 192 and also four steps are sufficient to prevent linear distinguishers
according to the LTS bounds. To prevent differential distinguishers, six steps are sufficient for
outer part to anything trails, and five steps for outer part to outer part trails. In Esch256, we
need a security level of 256 bit for the underlying permutation with regard to differential attacks
and 128 bit with regard to linear attacks (but without the restriction of processing only 264 blocks
of data). The rate of the sponge is 𝑟 = 192 (because of indirect injection) and five steps are
sufficient to prevent differential attacks (using the bounds for outer part to outer part trails), and
four steps to prevent linear distinguishers according to the LTS bounds.
Finally, Sparkle512 is employed in two of our schemes. For Schwaemm256-256, we need a
security level of 256 bit for the underlying permutation, restricting the user to encrypt at most 2128
blocks with one key. The rate of the sponge is 𝑟 = 256 and seven steps are sufficient to prevent
differential distinguishers according to the outer part to anything bounds. Note that five steps
are sufficient if the output difference is in the outer part only. With regard to linear attacks, five
steps are sufficient. Also, the longest of the other distinguishers we found covers no more than
four steps. In Esch384, we need a security level of 320 bit for the underlying permutation with
regard to differential attacks and 192 bit with regard to linear attacks (but without the restriction
of processing only 2128 blocks of data). The rate of the sponge is 𝑟 = 256 (because of indirect
injection) and we need six steps to prevent differential distinguishers and five to prevent linear
distinguishers, respectively, according to the LTS bounds.

3.5.3

On the Differential and Linear Bounds

Our arguments rely on the bounds on the differential probability and the absolute linear correlation
obtained by applying a long-trail argument using the properties of our ARX-box Alzette. These
are conservative bounds: while our algorithms show that there cannot exist any trail with higher
a probability/correlation, it may very well be that the bounds they find are not tight. In other
words, while we cannot overestimate the security our permutations provide against single trail
differential and linear attacks, we may actually underestimate it.
In fact, we think it is an interesting open problem to try and tighten our bounds as it could
only increase the trust in our algorithms. This tightening could happen at two levels: first, we
could try and obtain tighter bounds for the differential and linear properties of Alzette alone and,
second, we could look for actual trails for the Sparkle permutations. Indeed, our bounds for
Sparkle assume that there exists a trail where all transitions have optimal probability that fits in
every truncated trail. Again, this is a conservative estimate. We may be overestimating the power
the actual trails give to the adversary.
In both the differential and the linear case, we made some experiments at the ARX-box level
to try and estimate if there was any significant clustering of trails that might lead the differential
probability (respectively absolute correlation) to be significantly higher than the differential trail
probability (resp. trail absolute correlation). These are described in Section 3.3.10.1 and 3.3.10.2
respectively. In the differential case, this effect is minimal. In the linear case, it is small but
observable. However, in double iterations of Alzette, it is not sufficient that the input and output
patterns are known, we also need to constrain the values in the middle (i.e. in between the two
Alzette instances). As a consequence, we use the linear trail correlation bound and not a bound
that would take the double ARX-box level clustering into account.

48

4 Security Analysis
4.1

Security Claims

Our proposed algorithms are secure to the best of our knowledge. We have done our best not to
introduce any flaw in their design. In particular, we did not purposefully put any backdoor or
other security flaw in our algorithms.

4.1.1

For Esch

We claim that Esch256 and Esch384 offer a security level of 2𝑐 bits, where 𝑐 is both the capacity and
digest size, with regard to collision resistance, preimage resistance and second preimage resistance.
𝑐
Our claim covers the security against length-extension attacks. We impose the data limit of 2 2
processed blocks (as collisions are likely to occur for more data). In other words, a cryptanalytic
result that qualifies as an attack violating the above security claim should have a time complexity
𝑐
of at most 2 2 executions of the underlying permutation or its inverse.
For the XOFs, the security level is min{ 2𝑐 , 2𝑡 } bits for collision resistance and min{ 2𝑐 , 𝑡} bits for
(second) preimage resistance. The maximal allowed output length 𝑡 is the same as the data limit.

4.1.2

For Schwaemm

The Beetle mode of operation offers a security level (in bits) of min (𝑟, (𝑟 + 𝑐)/2, 𝑐 − log2 (𝑟)) both
for confidentiality (under adaptive chosen-plaintext attacks) and integrity (under adaptive forgery
attempts), where 𝑟 denotes the rate, and 𝑐 denotes the capacity. Note that we claim security in
the nonce-respecting setting, i.e., in which the adversary cannot encrypt data using the same nonce
twice.
Following the security bound of the Beetle mode and the choice of parameter in our AEAD
schemes, we claim a security level of 120 bits for Schwaemm256-128, where the adversary is allowed
to process at most 268 bytes of data (in total) under a single key. In other words, a cryptanalytic
result that qualifies as an attack violating this security claim has a time complexity of at most 2120
executions of the underlying permutation or its inverse and requires at most 268 blocks of data.
Analogously, we claim a security level of 184 bits for Schwaemm192-192, where the adversary
is allowed to process at most 268 byte of data under a single key. For Schwaemm128-128 we claim
a security level of 120 bits,1 where the adversary is allowed to process at most 268 byte of data
under a single key. Finally, for Schwaemm256-256 we claim a security level of 248 bits, where the
adversary is allowed to process at most 2133 byte of data under a single key.2
Nonce Misuse Setting. The above security claims are void in cases where nonces are resused.
As noted in [VV17], authenticated ciphers based on duplexed sponge constructions are vulnerable
to CPA decryption attacks and semi-universal forgery attacks in the nonce-misuse setting. For
instance, an encryption of 𝑀 = 0𝑟 under (𝐾, 𝑁, 𝐴) leaks the outer part of the internal state for
processing the first message block as the ciphertext. This information can be used to decrypt
another ciphertext obtained under the same tuple (𝐾, 𝑁, 𝐴).
However, because we employ a strong permutation in the initialization and a permutation in
the absorption that is strong when the adversary can only control the outer part, we believe that
a full state recovery attack is hard to mount in practice even in the nonce-misuse setting. We
therefore expect some reasonable security against key recovery attacks even under reuse of nonces.
Moreover, we expect the security with regard to privacy and integrity to still hold under misuse
1 While Beetle allows us to claim 121 bits, we claim only 120 in order to have a security level consistent with
Schwaemm256-128.
2 We first set the data limit as 264 blocks for all instances except for Schwaemm256-256 but then decided to
replace 269 bytes by 268 to have more consistency between the algorithms.

49

of nonces if it is guaranteed that the associated data is unique for each encryption. In that way,
the associated data itself would serve as a nonce before invoking the encryption process of the
secret messages. We emphasize that this statement about nonce misuse robustness is not part of
our formal security claim and therefore, we strongly recommend to only use the algorithm under
unique nonces.
Known-key Attacks. In the secret-key setting, Beetle guarantees security level close to the capacity size. However, in the known-key setting, the security drops to half of the capacity size.
Indeed, a classical meet-in-the-middle attack in the sponge becomes possible. It allows an attacker
to find collisions and preimages (in the case where the tag is squeezed in one step) with birthday
complexity. We stress that such attacks are possible in all sponge-based modes.
We are not aware of usage scenarios of authenticated encryption which require known-key
security. Therefore, we do not claim any known-key security of the Schwaemm family.

4.1.3

For Sparkle

For Sparkle25610 , we claim that there are no distinguishers with both a time and data complexity
lower than 2128 . For Sparkle38411 , we claim that there are no distinguishers with both a time
and data complexity lower than 2192 . For Sparkle51212 , we claim that there are no distinguishers
with both a time and data complexity lower than 2256 .
A Remark on the Slim Versions. The slim version of the Sparkle permutations are designed
to offer security against distinguishers in which the adversary can only control part of the state, in
particular the part corresponding to the rate 𝑟 when the permutation is employed in a sponge. We
emphasize that those slim versions should not be used on their own or in other constructions that
are not the sponge-based ones presented in this paper unless a proper security analysis is done.

4.1.4

Targets for Cryptanalysis

We encourage cryptanalysts to study variants of Esch and Schwaemm with fewer steps or a decreased capacity. Particularly, for hashing, we define the targets (𝑠,𝑏)-Esch256 and (𝑠,𝑏)-Esch384,
which instantiate a version of Esch256, resp., Esch384 using 𝑠 steps in the slim and 𝑏 steps in
the big permutation.
Similarly, for authenticated encryption, we define the members (𝑠,𝑏)-Schwaemm𝑟-𝑐, which
instantiates a version of Schwaemm𝑟-𝑐 using 𝑠 steps in the slim and 𝑏 steps in the big permutation.
Note that those additional members are not part of our submission, but just define possible targets
for cryptanalysis.
We also encourage the study of variants of our ARX-box Alzette with different round constants.

4.2

Attacks and Tests Against the Permutation

We evaluated the security of the Sparkle permutation family against several attack vectors, listed
in Table 4.1, with regard to our security claim stated above. Note that in the attacks considered
here the adversary can control the whole permutation state, not only the part corresponding to
the rate when the permutation is used in a sponge.
Besides the attacks listed in Table 4.1, we conducted several statistical tests on the Sparkle
permutations. In particular, we tested for diffusion properties (Section 4.2.1), the distribution of
low-weight monomials in the algebraic normal form (Section 4.2.8.1) and the resistance against
slide attacks (Section 4.2.9).

4.2.1

Diffusion Test (SAC)

The strict avalanche criterion (SAC) was introduced in [WT86] as a measure for the diffusion in
cryptographic functions. The SAC states that, for each input bit 𝑖 and output bit 𝑗, whenever the
𝑖-th input bit is flipped, the 𝑗-th output bit should flip with probability 12 . As proposed in [WT86],
we took several random samples and computed the 𝑛 × 𝑛 dependence matrix D, where 𝑛 denotes
50

Table 4.1: This table lists upper bounds on the number of steps for which we found an attack, or
for which the differential and linear bounds are too low to guarentee security, breaking a security
level of 2𝑏 bits, where 𝑏 denotes the block size, with regard to several attack vectors. The numbers
for differential and linear attacks correspond to the bounds given in Table 4.3 and Table 4.4.
Sparkle256

Sparkle384

Sparkle512

[BS91]
[Mat94]
[Wag99]
[Knu95]
[BBD+ 99]
[Knu98, BBS99]
[BR14]
[DKR97, KW02, Tod15]

4
5
3
2
4
4
4
4

5
6
4
2
4
4
4
4

6
6
5
3
4
4
4
4

# steps slim
# steps big

7
10

7
11

8
12

Attack

Ref.

Differential cryptanalysis
Linear cryptanalysis
Boomerang attacks
Truncated differentials
Yoyo games
Impossible differentials
Zero-correlation
Integral and Division property

the block size of the cryptographic permutation in bits. Let 𝑆 denote the set of 𝑛-bit random
samples and 𝐹 the permutation to test. Then, the entries of the dependence matrix are defined
as D𝑖,𝑗 = |{𝑥 ∈ 𝑆 | 𝐹 (𝑥)𝑗 ̸= 𝐹 (𝑥 ⊕ 2𝑖 )𝑗 }|. For a secure cryptographic permutation, we expect that
each D𝑖,𝑗 is a binomial distributed random variable following 𝐵(|𝑆|, 21 ).
We evaluated the dependence matrix of Sparkle for all block sizes 𝑛 and for several numbers of
steps 𝑛𝑠 . Results for 107 random samples are given in Table 4.2. Figure 4.1 depicts the distribution
of the occurrences of certain values in D𝑖,𝑗 for Sparkle3843 and 106 random samples, compared
to what one would expect from a binomial distribution. Note that, for all Sparkle variants, full
diffusion is reached after three steps. Our results indicate that three steps are also enough to fulfill
the SAC.
150

100

50

4.98

4.99

5

5.01

5.02
·105

Figure 4.1: Number of times (𝑦 axis) for which a specific entry (𝑥 axis) occurs in the dependency matrix after three steps of Sparkle384 for 106 samples (red) and the theoretical number of
occurrences corresponding to a 𝐵(106 , 12 ) distribution (black).

51

Table 4.2: Properties of the dependency matrix D for Sparkle with block size 𝑛 and number of
steps 𝑛𝑠 .
𝜇 = 𝑛12

∑︀𝑛−1 ∑︀𝑛−1

1
𝑛2

∑︀𝑛−1 ∑︀𝑛−1

(𝑛, 𝑛𝑠 )

min𝑖,𝑗 {D𝑖,𝑗 }

max𝑖,𝑗 {D𝑖,𝑗 }

(256, 3)
(256, 4)
(256, 5)
(256, 6)
(256, 7)

4,993,280
4,992,587
4,993,249
4,993,593
4,992,626

5,007,481
5,006,115
5,007,111
5,007,685
5,006,872

4,999,991
5,000,000
4,999,994
4,999,997
4,999,999

2,520,767
2,483,369
2,509,529
2,499,786
2,485,584

(384, 3)
(384, 4)
(384, 5)
(384, 6)
(384, 7)

4,993,170
4,993,344
4,992,917
4,993,238
4,992,030

5,007,839
5,007,802
5,007,030
5,006,775
5,006,687

5,000,000
5,000,003
4,999,995
5,000,003
4,999,999

2,496,373
2,510,058
2,504,939
2,506,934
2,514,274

(512, 3)
(512, 4)
(512, 5)
(512, 6)
(512, 7)
(512, 8)

4,993,031
4,992,929
4,992,762
4,992,860
4,992,525
4,992,790

5,006,999
5,007,068
5,007,492
5,007,736
5,006,852
5,007,753

4,999,998
4,999,999
4,999,999
5,000,000
5,000,003
5,000,000

2,504,774
2,501,413
2,497,702
2,506,286
2,503,587
2,492,782

4.2.2

Differential Attacks

4.2.2.1

Bounding the MEDCP

𝑗=0 D𝑖,𝑗

𝑖=0

𝑖=0

𝑗=0 (D𝑖,𝑗 − 𝜇)

2

In order to bound the MEDCP for the whole permutation, we use a long trail argument. First, we
enumerate all the truncated trails defined at the branch level (i.e., a branch is active or inactive)
that are compatible with the linear layer. For each such truncated trail, we partition it into long
trails and then deduce a bound on the probability of all the trails that fit into this truncated using
the probability that were established for Alzette (see Section 3.3.3).
In practice, a truncated trail is a sequence of binary vectors 𝑑𝑖 of length 𝑛𝑏 where, in our case,
𝑛𝑏 ∈ {4, 6, 8}. Furthermore, the structure of the linear layer significantly constrains the value of
𝑑𝑖+1 knowing 𝑑𝑖 . Indeed, half of the bits have to be identical (corresponding to those that do not
receive a XOR), and the output of the Feistel function itself is constrained by Theorem 3.4.1. As
a consequence, we can implement the exploration of all truncated trails as a tree search with the
knowledge that each new step will multiply the number of branches at most by 2𝑛𝑏 /2 ∈ {8, 16, 32}.
We can simplify the search further using tricks borrowed from Matsui’s algorithm 1. We can for
example fix a threshold for the probability of the differential trail we are interested in, thus allowing
us to cut branches as soon as the probability of the trails they contain is no longer bounded by the
given threshold. If this threshold is higher than the actual bound, the search will return a correct
result and it will do so faster.
We have implemented the long trail argument in this way to bound the differential probability
in a permutation with the structure used in the Sparkle family. The bounds for the permutations
we have obtained using the bounds for our 4-round Alzette instances are given in Table 4.3.
Table 4.3: The quantity − log2 (𝑝) where 𝑝 is the differential bound for several steps of Sparkle
for different block sizes. For 1 and 2 steps, we always have that − log2 (𝑝) is equal to 6 and 32
respectively.
𝑛 ∖ steps
256
384
512

3

4

5

6

7

8

9

10

11

12

13

64
70
76

88
100
112

140
178
210

168
200
232

192
230
268

216
260
276

≥ 256
326
295

≥ 256
356
424

≥ 256
≥ 384
433

≥ 256
≥ 384
496

≥ 256
≥ 384
≥ 512

52

4.2.2.2

Truncated Differential Trails

We performed an exhaustive search of all truncated trails on the branch level, i.e., each branch can
2 (𝑝)
be either active or inactive. We define the weight of a truncated differential trail as − log
, where
64
𝑝 denotes its probability. The truncated differential is said to be effective if its weight is strictly
smaller than the number of inactive words in the output. Our approach consists of two stages.
The first stage is to generate the matrix of probabilities of all truncated transitions through the
linear layer. We propose a new generic and precise method for this step. The second stage is a
simple iterative search, where for each round and for each truncated pattern at this round we keep
the best truncated trail leading tho this pattern.
Generating the Truncated Trail Matrix of a Linear Layer. Recently, a MILP approach for
searching for truncated differential trails was proposed in [MA20]. The method uses the matrix of
probabilities of truncated transitions through a linear layer, called the branching property table.
However, the precise method to compute this table was not described there.
We describe a generic method to generate the matrix of probabilities of truncated transitions
from the binary matrix of the analyzed linear layer.
𝑡
𝑚 𝑡
Let 𝐿 : (F𝑚
2 ) → (F2 ) be a linear bijective mapping. An exact truncated transition over 𝐿 is
a pair of vectors from {0, *}𝑡 . A loose truncated transition over 𝐿 is a pair of vectors from {0, ◇}𝑡 .
𝐿
A truncated transition 𝛼, 𝛽 over 𝐿 is denoted 𝛼 −
→ 𝛽.
For 𝛾𝑖 ∈ {0, ◇, *} let 𝑝(𝛾𝑖 ) be defined as
⎧
⎪
if 𝛾𝑖 = 0,
⎨{0},
𝑝(𝛾𝑖 ) = F𝑚
,
if 𝛾𝑖 = ◇, .
2
⎪
⎩ 𝑚
F2 ∖ {0}, if 𝛾𝑖 = *,
For a vector 𝛾 ∈ {0, ◇, *}𝑡 let 𝑝(𝛾) denote the set 𝑝(𝛾0 ) × . . . × 𝑝(𝛾𝑡−1 ).
𝐿
The cardinality of a truncated transition 𝛼 −
→ 𝛽 is defined as
𝐿

|𝛼 −
→ 𝛽| = |{𝑥 ∈ 𝑝(𝛼) | 𝐿(𝑥) ∈ 𝑝(𝛽)}| = |𝐿(𝑝(𝛼)) ∩ 𝑝(𝛽)| .
𝐿

The probability of a truncated transition 𝛼 −
→ 𝛽 is defined as
𝐿

𝐿

Pr[𝛼 −
→ 𝛽] =

Pr [𝐿(𝑥) ∈ 𝑝(𝛽)] =

𝑥∈𝑝(𝛼)

|𝛼 −
→ 𝛽|
.
𝑝(𝛼)

Since 𝑝 is easy to compute, we focus on computing the cardinality of an exact truncated transition.
The first step is to compute the cardinalities of all possible loose truncated transitions over 𝐿.
𝐿
𝑡
Let 𝛼 −
→ 𝛽 be a loose transition over 𝐿. Observe that 𝑝(𝑎), 𝑝(𝑏) are linear subspaces of (F𝑚
2 ) . The
𝐿
cardinality |𝛼 −
→ 𝛽| = 𝐿(𝑝(𝛼)) ∩ 𝑝(𝛽) can be computed using basic linear algebra as follows. First,
we choose a basis of 𝑝(𝛼) and map it through 𝐿 to obtain a basis of 𝐿(𝑝(𝛼)), which we denote 𝐵.
A vector 𝑏 belongs to 𝑝(𝛽) if and only if 𝑏𝑖 = 0 when 𝛽𝑖 = 0. Let 𝜋𝛽 (𝑏) be the part of the vector
𝑏 consisting of all elements 𝑏𝑖 for which 𝛽𝑖 = 0. We compute 𝑟 = Rank(𝜋𝛽 (𝐵)) and conclude that
𝐿

precisely 2dim 𝑝(𝛼)−𝑟 elements of 𝐿(𝑝(𝛼)) belong to 𝑝(𝛽), i.e. |𝛼 −
→ 𝛽| = 2dim 𝑝(𝛼)−𝑟 .
The second step is to compute the probabilities of all exact truncated transitions over 𝐿. Indeed,
a loose truncated truncated trail can be seen as a union of precise truncated trails. For example,
𝐿

(◇, 0) −
→ (0, ◇)
is equivalent to a union of disjoint transitions
𝐿

{(0, 0) −
→ (0, 0),

𝐿

𝐿

(0, 0) −
→ (0, *),

(*, 0) −
→ (0, 0),

𝐿

(*, 0) −
→ (0, *)},

i.e. the cardinalities are summed.
Formally, for any 𝛾, 𝛿 ∈ {0, ◇, *}𝑡 let 𝛾 ⪯ 𝛿 if and only if 𝛿𝑖 ⪯ 𝛾𝑖 for all 0 ≤ 𝑖 < 𝑡, where 𝛿𝑖 ⪯ 𝛾𝑖
if and only if 𝛿𝑖 = 0 or 𝛾𝑖 ̸= 0.
53

𝐿

𝐿

Let 𝛼* −
→ 𝛽* be an exact truncated transition and let 𝛼◇ −
→ 𝛽◇ be the same transition, with
𝐿
𝐿
* replaced by ◇, i.e. the loose variant of 𝛼* −
→ 𝛽* . Clearly, the loose transition 𝛼◇ −
→ 𝛽◇ can be
partitioned into disjoint exact transitions. Let
{︁
}︁
𝐿
𝑆 = 𝛼′ −
→ 𝛽 ′ | 𝛼′ ∈ {0, *}𝑡 , 𝛼′ ⪯ 𝛼* , 𝛽 ′ ∈ {0, *}𝑡 , 𝛽 ′ ⪯ 𝛽* .
Then

𝐿

|𝛼◇ −
→ 𝛽◇ | =
It follows that

𝐿

𝐿

→𝛽 ′ ∈𝑆
𝛼′ −

𝐿

|𝛼* −
→ 𝛽* | = |𝛼◇ −
→ 𝛽◇ | −

𝐿

∑︁

|𝛼′ −
→ 𝛽 ′ |.

∑︁
𝐿

𝛼′ −
→𝛽 ′ ∈𝑆,(𝛼′ ,𝛽 ′ )̸=(𝛼* ,𝛽* )

𝐿

|𝛼′ −
→ 𝛽 ′ |.

(4.1)

𝐿

Note that |𝛼* −
→ 𝛽* | can be also expressed in terms of cardinalities of loose “subtransitions”
𝐿
of 𝛼◇ −
→ 𝛽◇ , which were computed in the first step, by using the inclusion-exclusion principle.
However, since we need to compute all cardinalities of all exact transitions, we can simply use the
partition into exact “subtransitions” given by Equation 4.1. Indeed, by computing the cardinalities
in the lexicographic order of transitions, we can ensure that all sub-transitions are processed before
processing the current transition.
Given the cardinalities of exact transitions, it is easy to compute the probabilities of exact
transitions and compute the truncated trail matrix.
The time complexity of the naive implementation is O(4𝑡 · ((𝑡𝑚)3 + 4𝑡 )). The sum over “subtransitions” can be done in one extra pass in time O(𝑡 · 4𝑡 ) using dynamic programming. Then the
complexity becomes fully dominated by the linear algebra: O(4𝑡 · (𝑡𝑚)3 ).
𝑛𝑏
Truncated Trails in Sparkle. We consider the linear layer of Sparkle as a mapping of (F64
2 )
to itself, and search for all truncated differentials on the high level. The truncated differential is
said to be effective if its weight is strictly smaller than the number of inactive words in the output.
For Sparkle256, the longest effective truncated differential trail covers two steps and has weight
0. It can be described as follows, where * indicates an active branch and 0 indicates an inactive
branch:
input : 0 0 0 *
step 1 : * 0 0 0 .
step 2 : * * * 0

Another similar one can be obtained using the input 00*0. When restricting the input difference
to be only in the left branches (i.e., for the setting in Schwaemm128-128), the longest effective
truncated differential trail covers only one step and has weight 0:
input : *
step 1 : *

0 0
* *

0
.
0

For Sparkle384, the longest effective truncated differential trail also covers two steps and has
weight 0. It is also valid for the setting in Schwaemm256-128:
input : 0 0 0
step 1 : 0 0 *
step 2 : * * *

*
0
0

0 0
0 0 .
0 *

Two similar ones can be obtained using inputs 0000 * 0 and 00000*.
For Sparkle512, the longest effective truncated differential trail covers three steps and has
weight 1. It cannot be used in the setting of Schwaemm256-256:
input : 0 0 0 0 0 * 0 *
step 1 : * 0 * 0 0 0 0 0
,
step 2 : 0 * 0 * * 0 * 0
step 3 : * * * * 0 * 0 *
54

where we associate a probability of 2−64 for the transition between step 1 and step 2.
Such truncated trails where two branches are active and activate only two outputs of the
Feistel functions exist for all number of branches strictly greater than 4 and, in particular, for both
Sparkle384 and Sparkle512.The purpose of the rotation of the branches after the addition of the
Feistel function in the linear layer is to prevent the iteration of such truncated trails. While they
would pose no threat as such, they could serve as the template for high probability “not-truncated”
differential trails.
Overall, truncated trails do not threaten the security of any version of Sparkle.

4.2.3

Linear Attacks

For linear attacks, we can use essentially the same analysis as for differential attacks. The only
difference is that we need to replace the linear layer of Sparkle by the transpose of its inverse.
The linear layer can be written as ℒ𝑛𝑏 = ℱ × ℛ × 𝒮 where ℱ corresponds to the Feistel function,
ℛ to the rotation applied to the branches on the right side and 𝒮 to the swap of the branches
on the left and right sides. For example, for Sparkle384, they correspond to the following block
matrices:
⎤
⎡
⎤
⎡
ℐ
ℐ
⎥
⎢
⎥
⎢
ℐ
ℐ
⎥
⎢
⎥
⎢
⎥
⎢
⎥
⎢
ℐ
ℐ ⎥
⎥
⎢
,
ℛ
=
𝒮=⎢
⎥
⎢
⎥
⎢ ℐ
ℐ
⎥
⎢
⎥
⎢
⎣
⎦
⎣
ℐ ⎦
ℐ
ℐ
ℐ
and

⎡

⎢
⎢
⎢
ℱ =⎢
⎢ ℐ + ℓ′
⎢
⎣ ℓ′
ℓ′
′

⎤

ℐ

ℐ

ℐ
ℓ′
ℓ′
ℐ + ℓ′

ℓ′
ℐ + ℓ′
ℓ′

ℐ

ℐ

⎥
⎥
⎥
⎥ ,
⎥
⎥
⎦
ℐ

We thus have that (ℒ𝑇𝑛𝑏 )−1 = (ℱ 𝑇 )−1 × (ℛ𝑇 )−1 × (𝒮 𝑇 )−1 .

where ℓ (𝑥, 𝑦) = ℓ(𝑦), ℓ(𝑥).
simplify this expression using that:

We can

∙ ℱ is an involution, so that (ℱ 𝑇 )−1 = ℱ 𝑇 ,
∙ ℛ is orthogonal, so that (ℛ𝑇 )−1 = ℛ, and
∙ 𝒮 = 𝒮 −1 = 𝒮 𝑇 , so that (𝒮 𝑇 )−1 = 𝒮.
We deduce that (ℒ𝑇𝑛𝑏 )−1 = (ℱ 𝑇 ) × ℛ × 𝒮. The permutation ℱ 𝑇 has the following representation
⎡
⎤
ℐ
ℐ + ℓ′𝑇
ℓ′𝑇
ℓ′𝑇
⎢
⎥
ℐ
ℓ′𝑇
ℐ + ℓ′𝑇
ℓ′𝑇
⎢
⎥
′𝑇
′𝑇
′𝑇 ⎥
⎢
ℐ
ℓ
ℓ
ℐ +ℓ ⎥
ℱ𝑇 = ⎢
⎢
⎥ ,
ℐ
⎢
⎥
⎣
⎦
ℐ
ℐ
i.e. it is a Feistel function going from the right to the left and where ℳ𝑤 is replaced with its
transpose. As we established in Lemma 3.4.2, this transpose is in fact ℳ𝑤 itself.
As a consequence, we can reuse the long trail argument that we introduced for the differential
case (see Section 4.2.2.1) and we can further reuse the corresponding algorithm. However, we
need to modify it so that the Feistel function goes in the other direction. The bound on the
maximum expected absolute linear trail correlation we obtained with this modified program is
given in Table 4.4.
As argued in Section 3.5.3, the slight clustering observed in the double iteration of Alzette does
not mean that the absolute correlation of trails is a bad approximation of the absolute correlations
55

in the permutation. Indeed, in each double iteration of Alzette, either the mask in the middle
enters the linear Feistel function or it is XORed with another mask. Hence, the clustering at the
double ARX-box level does not really matter (especially as it is low in our case), it is the one at
the single ARX-box level (which is negligible here).
Table 4.4: The quantity − log2 (𝑝) where 𝑝 is the linear bound for several steps of Sparkle for
different block sizes. For 1 and 2 steps, we always have that − log2 (𝑝) is equal to 2 and 17
respectively.
𝑛 ∖ steps
256
384
512

4.2.4

3

4

5

6

7

8

9

10

11

12

13

23
25
27

42
46
50

57
76
93

72
89
106

91
110
129

106
131
152

125
161
195

≥ 128
174
208

≥ 128
≥ 192
231

≥ 128
≥ 192
254

≥ 128
≥ 192
≥ 256

Boomerang Attacks

In Boomerang distinguishers [Wag99], the permutation 𝑃 under attack is split into two parts,
𝑃

𝑃

i.e., 𝑃 = 𝑃1 ∘ 𝑃0 and differentials 𝛼 →0 𝛽 for and 𝛾 →1 𝛿 with high probability are exploited. In
𝑃
𝑃
particular, if 𝛼 →0 𝛽 holds with probability 𝑝 and 𝛾 →1 𝛿 holds with probability 𝑞, a Boomerang
2 2
differential with probability 𝑝 𝑞 could be constructed. On ARX-box level, Boomerang attacks
look indeed dangerous. Suppose we have two differentials for one Alzette instance with probability
2−6 , one can construct a Boomerang differential over two iterations of Alzette with probability
2−4·6 = 2−24 , which is larger than the upper bound on the maximum expected differential trail
probability of 2−32 .
Fortunately, for the whole permutation, classical Boomerang attacks seem not to be a threat
(using the bounds given in Table 4.3). Furthermore and more importantly, it is not clear how the
existence of a boomerang distinguisher could be a problem in our sponge-based setting.

4.2.5

Yoyo Games

Yoyo distinguishers were first introduced in [BBD+ 99] where they were used to highlight the poor
diffusion in the block cipher Skipjack. We have also looked experimentally at yoyos. We found
several probability 1 truncated yoyos covering 4 steps of all Sparkle instances. However, none of
them covers more than 4 steps. Those that do all have the same structure, which we describe using
“plaintext” and “ciphertext” to denote the input and output of the permutation (even though there
is no key in the permutation):
1. a difference over one of the right branches is introduced in the “plaintext” to create a second
one,
2. the permutation is called on each to obtain two “ciphertexts”,
3. two new “ciphertexts” are created by swapping one of the left branch between the two
previously obtained “ciphertexts”. Then, finally,
4. we call the inverse permutation on these new “ciphertexts”.
The two new “plaintexts” have a difference equal to 0 on all but one branch, a property which
should not hold for a random permutation. Besides, as for boomerangs, it is not clear that yoyos
could be leveraged in our sponge-based setting if they were possible.

4.2.6

Impossible Differentials

Although the step structure is very close to a Feistel structure, the well known impossible differential for 3-round and 5-round Feistel networks does not hold for 3 steps, resp., 5 steps of Sparkle.

56

However, another family of impossible truncated differential exists that covers 3 steps and which
leverages the properties of ℳ𝑤 described in Theorem 3.4.1.
The longest truncated impossible differential we found using MILP covers four steps. We used
the approach described in [CCF+ 21, ST17] on the truncated level by considering Alzette as a black
box. For Sparkle256, one of the longest so-obtained impossible differential is as follows, where
𝛼 ̸= 0, 𝛽 ̸= 0 denote arbitrary 64-bit differences:
input : 0
step 1 : 𝛾
step 2 :
step 3 : 0
step 4 : 0

0
0

0
0

𝛼
0

↓
↓

0
𝛽

𝛿
0

0
0

↑
↑

.

Similarly, for Sparkle384, a four-step impossible differential is given by
input : 0 0 0
step 1 : 0 0 𝛾
step 2 :
step 3 : 0 0 0
step 4 : 0 0 𝛽

𝛼
0

0 0 ↓
0 0 ↓

𝛿
0

0 0 ↑
0 0 ↑

.

Also, for Sparkle512, a four-step impossible differential is given by
input : 0 0 0
step 1 : 0 0 𝛾
step 2 :
step 3 : 0 0 0
step 4 : 0 0 0

0
0

0
0

0
0

0 𝛼
0 0

↓
↓

0
𝛽

𝛿
0

0
0

0
0

↑
↑

0
0

.

Since the diffusion in Alzette is very good, we do not expect that taking its specifics into account
will yield significantly better results.3

4.2.7

Zero-Correlation Attacks

With the same approach as for impossible differentials, we evaluated the security against truncated
zero-correlation distinguishers by considering the transpose of the inverse of the linear layer. For
all Sparkle versions, the longest distinguisher we found in that way also covers four steps. One
of them can be given as follows, where 𝛼 ̸= 0, 𝛽 ̸= 0 denote arbitrary masks on the 64-bit word.
For Sparkle256:
input : 0 𝛼 0 0 ↓
step 1 : 0 0 0 𝛾 ↓
step 2 :
.
step 3 : 0 𝛿 0 0 ↑
step 4 : 0 0 0 𝛽 ↑
For Sparkle384:

For Sparkle512:

𝛼
0

0
0

0
0

0
𝛾

↓
↓

0
0

0
𝛽

0
0

0
0

↑
↑

input : 0 0 0 𝛼
step 1 : 0 0 0 0
step 2 :
step 3 : 0 0 0 𝛿
step 4 : 0 0 0 0

0
0

0
0

0
0

0
𝛾

↓
↓

0
0

0
0

0 0
0 𝛽

↑
↑

input : 0 0
step 1 : 0 0
step 2 :
step 3 : 𝛿 0
step 4 : 0 0

.

.

3 Note that those impossible differentials can be trivially extended for one more Alzette layer, but not for a whole

step.

57

4.2.8

Integral and Division Property (or Algebraic Degree)

4.2.8.1

Distribution of Low-Weight Monomials

As was done for Keccak, we conducted experiments on the distribution of low-degree monomials
for (round-reduced versions of) the Sparkle permutations. For a random permutation on 𝑛 bit, we
would expect that, for each output bit, the number (︀of)︀monomials of fixed degree 𝑑 < 𝑛 in its ANF
can be approximated by a Binomial distribution 𝐵( 𝑛𝑑 , 12 ). In Table 4.5, for each Sparkle variant
up to three steps, we denote the maximum 𝑑 ∈ {0, . . . , 16} such that the following experiment
passes for all 𝑑′ ≤ 𝑑:
We choose 𝑁 monomials of degree 𝑑 uniformly at random and compute for each output bit
𝑦𝑖 how many of those monomials occur in its ANF. Let us denote this number by 𝑁𝑦𝑖 . The
experiment passes if, for all 𝑦𝑖 , 𝑁𝑦𝑖 ∈ [ 𝑁2 − 𝑎, 𝑁2 + 𝑎], where 𝑎 is the minimum number such that
the probability of 𝑁𝑦𝑖 being in [ 𝑁2 − 𝑎, 𝑁2 + 𝑎] is ≥ 1 − 0.00001 assuming the Binomial distribution.
For example, when choosing 𝑁 = 10000 samples, the test passes if and only if, for all 𝑦𝑖 , we observe
4779 ≤ 𝑁𝑦𝑖 ≤ 5221.4
For all Sparkle variants, the monomial test passes for all 𝑑 ≤ 16 already after three steps.
Table 4.5: For each of the Sparkle versions, the table contains the maximum degree 𝑑 such that
the monomial test passes for all 𝑑′ ≤ 𝑑. We tested up to 𝑑 = 16.

4.2.8.2

steps

Sparkle256

Sparkle384

Sparkle512

1
2
3

0
0
≥ 16

0
0
≥ 16

0
0
≥ 16

Division Property of the Sparkle Permutations

We performed MILP-aided bit-based division property analysis [Tod15, SWW20] on the Sparkle
permutation family.
For the MILP encoding of the linear layer we used the original method from [SWW20]. Note
that in [ZR19] it was shown that this method is imprecise and may result in extra trails and
weaker distinguisher. The linear layer of Sparkle can be viewed as 16 independent linear layers
of dimensions from 16 × 16 in Sparkle256 to 32 × 32 in Sparkle512. For these dimensions it
may be possible to apply the precise encoding method from [ZR19]. However, due to the large
state size, we found it to be still infeasible.
We performed bit-based division property evaluation of the reduced-round Sparkle permutations. We set 𝑏 − 1 active bits with the inactive bit at index 44 or 44 + 𝑏/2, as offset 44 results
in the best bit-based integral characteristic for the ARX-box structure. Furthermore, the branch
choice for the inactive bit does not affect the result, due to the rotational branch symmetry (inside
each half of the state). The best integral characteristic we found is for 4 steps and an extra Alzette
layer, for all three Sparkle versions. It operates as follows. First, we encrypt the half of the
codebook such that one bit in the left half of the input is constant and all other bits are taking all
possible values. Then, after 4 steps and the Alzette layer from the 5-th step, the right half of the
state sums to zero. We state and prove this characteristic using the structural division property
and show that, in fact, fewer active input bits are required. Namely, 64 · 𝑛𝑏 + 65 active bits instead
of 2 · 64 · 𝑛𝑏 .
Proposition 4.2.1. Consider a Sparkle-like permutation of F2ℎ
2 , with arbitrary bijective ARXBoxes permuting F𝑚
2 , arbitrary linear Feistel function and at least 4 branches, i.e. 𝑛𝑏 = 2ℎ/𝑚 ≥ 4.
Then, the following division property transition is satisfied over 4 steps and an extra ARX-box
layer:
(𝑚,...,𝑚),(𝑚,...,𝑚)

𝐴∘(𝐿∘𝐴)4

(ℎ),(ℎ)

(ℎ),(ℎ)

𝒟(0,...,0,1,𝑚),(𝑚,...,𝑚) −−−−−−−→ 𝒟(1),(0) ∪ 𝒟(0),(2) ,
4 For 𝑑 ≤ 2, we test the occurrence of all monomials, for 3 ≤ 𝑑 ≤ 12 we choose 𝑁 = 10000 and for 12 ≤ 𝑑 ≤ 16,
we choose 𝑁 = 1000.

58

where 𝐴 denotes the ARX-box layer and 𝐿 denotes the linear layer. In other words, the right half
of the output sums to zero.
Proof. Without loss of generality, we assume that there is no rotation of branches. Indeed, any
permutation of branches inside a half is equivalent to reordering ARX-boxes inside halves and to
modifying the Feistel linear layer, which is not constrained in this proposition.
𝑚
Step 1. The properties 𝒟1𝑚 and 𝒟𝑚
are retained through the ARX-boxes. The right half is fully
active, therefore the linear layer does not have mixing effect yet. The following division trail
is unique:
𝐴

(𝑚,...,𝑚),(𝑚,...,𝑚)

(𝑚,...,𝑚),(𝑚,...,𝑚)

𝐿

(𝑚,...,𝑚),(𝑚,...,𝑚)

𝒟(0,...,0,1,𝑚),(𝑚,...,𝑚) −→ 𝒟(0,...,0,1,𝑚),(𝑚,...,𝑚) −→ 𝒟(𝑚,...,𝑚),(0,...,0,1,𝑚) .
Step 2. The ARX-box layer does not change anything again. The linear layer allows multiple division
trails. Note that at most (𝑛𝑏 − 1)𝑚 − 1 active bits can be transferred through the Feistel
linear function until the right half is saturated to fully active. Therefore, at least 𝑚 + 1
bits remain active in the left half. In particular, at least two branches remain active. As we
will show, this is the only requirement to show the proposed balanced property. We reduce
active bits to these two in order to cover all possible trails and simplify the proof. Up to
permutation of branches inside the state halves,
𝐴

(𝑚,...,𝑚),(𝑚,...,𝑚)

𝐿

(𝑚,...,𝑚),(𝑚,...,𝑚)

(𝑚,...,𝑚),(𝑚,...,𝑚)

𝒟(𝑚,...,𝑚),(0,...,0,1,𝑚) −→ 𝒟(𝑚,...,𝑚),(0,...,0,1,𝑚) −→ 𝒟(0,...,0),(1,1,0,...,0) .
Step 3. The two active branches remain active through the third step, since there is no mixing
between them:
(𝑚,...,𝑚),(𝑚,...,𝑚)

𝐴

(𝑚,...,𝑚),(𝑚,...,𝑚)

𝐿

(𝑚,...,𝑚),(𝑚,...,𝑚)

𝒟(0,...,0),(1,1,0,...,0) −→ 𝒟(0,...,0),(1,1,0,...,0) −→ 𝒟(1,1,0,...,0),(0,...,0) .
Step 4 + 𝐴 Similarly, the two active branches stay active after the ARX-box layer of the fourth step:
(𝑚,...,𝑚),(𝑚,...,𝑚)

𝐴

(𝑚,...,𝑚),(𝑚,...,𝑚)

𝒟(1,1,0...,0),(0,...,0) −→ 𝒟(1,1,0...,0),(0,...,0) .
In the linear layer, there are several possibilities. The two active bits from the left half can
(ℎ),(ℎ)
be transferred to a single branch in the right half by the Feistel function. Then 𝒟(2),(0) is
(ℎ),(ℎ)

obtained that is mapped through the final ARX-box layer to 𝒟(1),(0) , i.e., the left half is
(ℎ),(ℎ)

possibly not balanced. If one of the active bits is transferred by the linear layer, then 𝒟(1),(1)
is obtained, which is covered by the previous case. Otherwise, two active branches remain
after the linear layer and after the final ARX-box layer. The output division property in this
(ℎ),(ℎ)
case is 𝒟(0),(2) . The following trails cover all possible trails up to branch permutations in
each half:
(𝑚,...,𝑚),(𝑚,...,𝑚)

𝐿

(𝑚,...,𝑚),(𝑚,...,𝑚)

𝐴

(𝑚,...,𝑚),(𝑚,...,𝑚)

(ℎ),(ℎ)

(𝑚,...,𝑚),(𝑚,...,𝑚)

𝐿

(𝑚,...,𝑚),(𝑚,...,𝑚)

𝐴

(𝑚,...,𝑚),(𝑚,...,𝑚)

(ℎ),(ℎ)

𝒟(1,1,0...,0),(0,...,0) −→ 𝒟(2,0,...,0),(0,0,...,0) , −→ 𝒟(1,0,...,0),(0,0,...,0) =⇒ 𝒟(1),(0) ,
𝒟(1,1,0,...,0),(0,...,0) −→ 𝒟(0,...,0),(1,1,0,...,0) , −→ 𝒟(0,...,0),(1,1,0,...,0) =⇒ 𝒟(0),(2) .
It follows that the following division trail is impossible:
𝐴∘(𝐿∘𝐴)4

(𝑚,...,𝑚),(𝑚,...,𝑚)

(ℎ),(ℎ)

𝒟(0,...,0,1,𝑚),(𝑚,...,𝑚) −−−−−−−→ 𝒟(0),(1)
Therefore, the right output half is balanced.

Note that in the proof, a lot of active bits were omitted for simplicity, namely in order to cover
all possible trails with a single one. However, as the bit-based division property analysis suggests,
a more careful analysis does not yield any longer integral characteristic.
We evaluated also the inverses of the Sparkle permutations. Similarly, the bit-based division
property with only one inactive bit (at offset 27 in the left or in the right half) suggested only a
general structural distinguisher, similar to the one from Proposition 4.2.1.
59

Proposition 4.2.2. Consider a Sparkle-like permutation as in Proposition 4.2.1. The following
division property transition is satisfied over 4 steps in the reverse direction:
(𝑚,...,𝑚),(𝑚,...,𝑚)

(𝐴−1 ∘𝐿−1 )4

(ℎ),(ℎ)

(ℎ),(ℎ)

𝒟(𝑚,...,𝑚),(0,...,0,1,𝑚) −−−−−−−−→ 𝒟(2),(0) ∪ 𝒟(0),(1) .
Proof. In a similar way to the Proposition 4.2.1, the following division trail covers all division
trails:
(𝑚,...,𝑚),(𝑚,...,𝑚)

𝐿−1

(𝑚,...,𝑚),(𝑚,...,𝑚)

𝐿−1

(𝑚,...,𝑚),(𝑚,...,𝑚)

𝐿−1

(𝑚,...,𝑚),(𝑚,...,𝑚)

𝐴−1

(𝑚,...,𝑚),(𝑚,...,𝑚)

𝒟(𝑚,...,𝑚),(0,...,0,1,𝑚) −−−→ 𝒟(0,...,0,1,𝑚),(𝑚,...,𝑚) −−−→ 𝒟(0,...,0,1,𝑚),(𝑚,...,𝑚)
𝐴−1

(𝑚,...,𝑚),(𝑚,...,𝑚)

−−−→ 𝒟(1,1,0,...,0),(0,...,0,1,𝑚) −−−→ 𝒟(1,1,0,...,0),(0,...,0,1,𝑚)
𝐴−1

(𝑚,...,𝑚),(𝑚,...,𝑚)

−−−→ 𝒟(0,...,0),(1,1,0...,0) −−−→ 𝒟(0,...,0),(1,1,0...,0) ,
And in the last step the same cases take place as in Proposition 4.2.1.
(𝑚,...,𝑚),(𝑚,...,𝑚)

𝐿−1

(𝑚,...,𝑚),(𝑚,...,𝑚)

𝐴−1

(𝑚,...,𝑚),(𝑚,...,𝑚)

(𝑚,...,𝑚),(𝑚,...,𝑚)

𝐿−1

(𝑚,...,𝑚),(𝑚,...,𝑚)

𝐴−1

=⇒ 𝒟(0),(1) ,

(𝑚,...,𝑚),(𝑚,...,𝑚)

(ℎ),(ℎ)

𝒟(0,...,0),(1,1,0...,0) −−−→ 𝒟(0,...,0),(2,0,...,0) , −−−→ 𝒟(0,...,0),(1,0,...,0)

(ℎ),(ℎ)

𝒟(0,...,0),(1,1,0...,0) −−−→ 𝒟(1,1,0,...,0),(0,...,0) , −−−→ 𝒟(1,1,0,...,0),(0,...,0) =⇒ 𝒟(2),(0) .
The following trail is impossible:
(𝑚,...,𝑚),(𝑚,...,𝑚)

(𝐴−1 ∘𝐿−1 )4

(ℎ),(ℎ)

𝒟(𝑚,...,𝑚),(0,...,0,1,𝑚) −−−−−−−−→ 𝒟(1),(0)
Therefore, the left output half is balanced.

4.2.9

Attacks Based on Symmetries

The usage of independent and dense round constants on the branches and the addition of different
constants before each step breaks symmetries within the permutation.
Slide Attacks [BW99]. The XOR of the step counter to the second branch before each step
assures that each step is different so that classical slide attacks cannot be applied. As a second
source of asymmetry, we XOR the round constant 𝑐𝑖 to the right word of the first branch before
step 𝑖. Similarly to what was done for Keccak, for each Sparkle𝑛 version, we further analyzed
the function
slide𝑛,𝑛𝑠 (𝑥) = Sparkle𝑛𝑛𝑠 (𝑥) ⊕ Sparkle𝑛𝑛𝑠 +1 (Sparkle𝑛−1
1 (𝑥))
with regard to the distribution of low-weight monomials with the same test as described in Section 4.2.8.1. The test passes already after three steps for all Sparkle variants and all 𝑑 ≤ 16 (see
Table 4.6).
Table 4.6: For each of the slide functions of the Sparkle versions, the table contains the maximum
degree 𝑑 such that the monomial test passes for all 𝑑′ ≤ 𝑑. We tested up to 𝑑 = 16.
𝑛𝑠

slide256,𝑛𝑠

slide384,𝑛𝑠

slide512,𝑛𝑠

1
2
3

0
0
≥ 16

0
0
≥ 16

0
0
≥ 16

Rotational Cryptanalysis. Due to the heavy use of dense round constants, we expect Sparkle to
be resistant against rotational cryptanalysis. Furthermore, the ℓ function used in the linear layer
of Sparkle breaks the rotational symmetry of 32-bit words as well.

60

4.2.10

Guess and Determine

It might be counter-intuitive because of the long trail approach we use but the diffusion in Sparkle
is very fast. At the end of one step, each left branch depends on all the left branches of the input
and one branch from the right. Furthermore, not only is the linear Feistel function ensuring this
high dependency, it also provides a branching number of 4 (for 𝑛𝑏 ≥ 6), meaning that we cannot
find equations linking fewer than 4 branches through the linear layer.

4.3

Attacks Against the Sponge

When absorbing message blocks, we prefer to inject them as branches on the left side of the integral
state. There are several reasons for this:
1. these branches are those that will go in the Feistel function the soonest, thus ensuring a quick
diffusion of the message blocks in the state,
2. these branches will undergo a double iteration of Alzette right away, meaning that it will be
harder for an attacker to control what happens to these branches, and
3. an attacker who wants for instance to find a collision needs to have some control over the
branches which receive the blocks injected in the state. By having those be on the left, we
ensure that these branches have just received a XOR from the linear Feistel function, and
thus that they depend on all the branches that are on the right side at the time of injection.
This property makes it harder for an attacker to propagate information backwards or to
ensure that some pattern holds right before block injection.
When the rate is higher than a half of the state, we first use all the branches on the left as the
inner part and then complete it with as many branches from the right as needed.

4.3.1

Differential Attacks

To study the security of a sponge against differential attacks, we estimate the security parameter
for which vanishing differences become unfeasible for an increasing number of steps in the sponge
permutation.
First, we observe that the probability Pvanish (𝑎) of a differential trail covering 𝑎 absorptions with
a sponge with 𝑟 steps is upper-bounded by 𝑈𝑟𝑎 , where 𝑈𝑟 is an upper bound on the probability of
all differentials for the 𝑟 step permutation, unless the difference cancels out at some absorptions.
For Sparkle, such bounds are provided in Table 4.3. Let 𝑠 be the security parameter we aim for.
If (𝑈𝑟 )2 < 2−𝑠 , then the only way for a vanishing absorbed trail to exist with probability higher
than 2−𝑠 is for it to correspond to two absorptions, i.e., that the second absorption cancels the
difference in the state of the sponge after the absorption of the first difference.
As a consequence, we can restrict our search for absorbed trails to those that have both an
input and an output that is fully contained in the outer part of the sponge. The program we used
to enumerate all truncated trails to implement a long trail argument is easily modified to only take
into account such trails. Then, we upper bound the probability of all the corresponding trail using
the same approach as before and we obtain Table 4.7.
Note that while the rate of both Esch256 and Esch384 is equal to 128 bits, it is necessary to
look at 𝑛 = 384, 𝑟 = 192 for Esch256 and 𝑛 = 512, 𝑟 = 256 for Esch384. Indeed, the indirect
injection means that the input and output difference must be over the leftmost 3 and 4 branches
respectively. Still, as we can see in Table 4.7, it makes little difference in terms of differential trail
probability. Furthermore, it would be necessary for an attacker to find trails that start and end in
a specific subspace of the left half of the state.

4.3.2

Linear Attacks

Using a reasoning identical to the one we used above in the differential case, we can restrict ourselves
to the case where the input and output masks are restricted to the outer part of the sponge. Doing
so, we can look at all the linear trails that would yield linear approximations connecting the outer
61

Table 4.7: The quantity − log2 (𝑝) where 𝑝 is an upper bound on the probability of a differential
trail over one call to Sparkle where both the input and the output differences are fully contained
in the outer part. The ∅ symbols means that such trails impossible. 𝑟 → 𝑟 denotes “outer part to
outer part” trails and 𝑟 → 𝑛 denotes trails where the input is in the outer part but the output is
not constrained.
𝑛

256

384

512

𝑟

𝑐 (security)

192

64

128

128

64

192

256

128

192

192

128

256

64

320

256

256

128

384

64

448

Type

3

4

5

6

7

8

𝑛→𝑛

64

88

140

168

192

216

𝑟→𝑟

76

108

140

168

204

232

𝑟→𝑛

64

108

140

168

192

232

𝑟→𝑟

96

128

192

192

224

𝑟→𝑛

96

116

140

172

212

≥ 256

𝑟→𝑟

128

192

192

𝑟→𝑛

∅

96

128

148

172

≥ 256

≥ 256

𝑛→𝑛

70

100

178

200

230

260

𝑟→𝑟

108

148

180

200

268

296

70

140

178

200

230

296

𝑟→𝑟

128

160

256

256

288

320

𝑟→𝑛

128

148

178

210

276

306

𝑟→𝑟

128

160

256

256

320

320

𝑟→𝑛

128

160

180

210

276

306

160

256

256

320

320

𝑟→𝑛

128

160

180

210

276

306

𝑛→𝑛

76

112

210

232

268

276

𝑟→𝑟
𝑟→𝑟

𝑟→𝑛

𝑟→𝑟

∅

212

244

≥ 256

160

192

256

320

352

416

𝑟→𝑛

134

172

212

248

332

372

192

256

320

352

384

𝑟→𝑛

∅

134

172

212

248

332

376

192

320

320

384

384

𝑟→𝑛

∅

160

192

212

248

340

376

𝑟→𝑟

parts of the internal state before and after a call to the Sparkle permutation. If this absolute
correlation is too high, it could lead for instance to observable biases in a keystream generated
using a Schwaemm instance. Table 4.8 bounds such probabilities.

4.3.3

Impossible Differentials

The 4-step impossible differential described above in Section 4.2.6 cannot be applied when the permutation is used in a sponge unless the rate is larger than the capacity (as it is in Schwaemm256128). Therefore, for Sparkle384, the four-step impossible differential given above, i.e.,
input : 0 0
step 1 : 0 0
step 2 :
step 3 : 0 0
step 4 : 0 0

0
𝛾

𝛼
0

0 0 ↓
0 0 ↓

0
𝛽

𝛿
0

0 0 ↑
0 0 ↑

62

,

Table 4.8: The quantity − log2 (𝑝) where 𝑝 is an upper bound on the absolute correlation of a linear
trail connecting the outer part of the input with the outer part of the output of various Sparkle
instances. The ∅ symbols means that the trails connecting the outer part to itself are impossible.
𝑛

256

384

512

𝑟

𝑐 (security)

3

4

5

6

7

192

64

23

42

57

76

91

128

128

23

55

74

76

91

64

192

59

55

89

89

123

256

128

25

46

76

97

110

192

192

25

72

93

97

110

128

256

42

72

108

110

142

64

320

∅

72

123

123

157

256

256

27

78

97

129

129

128

384

∅

89

110

142

161

is valid in the two settings of Schwaemm256-128. However, in the setting of Esch256 and
Schwaemm192-192, we only have a three-round impossible differential
input : 0 𝛼
step 1 : 0 0
step 2 :
step 3 : 0 𝛽

0
0

0
0

0
𝛾

0
0

↓
↓

0

0

0

0

↑

.

For Sparkle256 in our sponge settings, there is only a three-step impossible differential given
as

input : 0
step 1 : 0
step 2 :
step 3 : 0

𝛼
0

0 0
0 𝛾

↓
↓

𝛽

0

↑

0

.

Similarly, for Sparkle512 in our sponge setting, there is only a three-step impossible differential given by
input : 0 0 0 𝛼 0 0 0 0 ↓
step 1 : 0 0 0 0 0 0 0 𝛾 ↓
.
step 2 :
step 3 : 0 0 0 𝛽 0 0 0 0 ↑

4.3.4

Zero-correlation Attacks

The 4-step zero-correlation distinguisher described above cannot be applied when the permutation
is used in a sponge unless the rate is larger than the capacity (as it is in Schwaemm256-128).
Therefore, for Sparkle384, the four-step zero-correlation distinguisher given above, i.e.,
input : 0 0
step 1 : 0 0
step 2 :
step 3 : 0 0
step 4 : 0 0

𝛼
0

0
0

0 0
0 0

↓
↓

0
0

0
𝛽

0 0
0 0

↑
↑

63

,

is valid in the setting of Schwaemm256-128. However, in the two settings of Esch256 and
Schwaemm192-192, we only have a three-round zero-correlation distinguisher
input : 0 𝛼
step 1 : 0 0
step 2 :
step 3 : 0 𝛽

0
0

0
0

0 0 ↓
0 0 ↓

0

0

0

0

.

↑

For Sparkle256 in our sponge settings, there is only a three-step zero-correlation distinguisher
given as
input : 0 𝛼 0 0 ↓
step 1 : 0 0 0 0 ↓
.
step 2 :
step 3 : 0 𝛽 0 0 ↑
Similarly, for Sparkle512 in our sponge setting, there is only a three-step zero-correlation
distinguisher given by
input : 0 0 0 𝛼 0 0 0 0 ↓
step 1 : 0 0 0 0 0 0 0 0 ↓
.
step 2 :
step 3 : 0 0 0 𝛽 0 0 0 0 ↑

4.4

Guess and Determine

As argued in Section 4.2.10, diffusion is fast in Sparkle. This section shows several attacks on
round-reduced variants of Schwaemm. The attacks are summarized in Table 4.9.
Table 4.9: Guess and determine attacks on Schwaemm instances. 𝜖 is an arbitrary positive
parameter. 0.5 step denotes an extra Alzette layer.
Instance

4.4.1

Steps

Whitening

Method

Time

Data

64

Schwaemm128-128
Schwaemm192-192
Schwaemm256-256
Schwaemm256-256

3.5
3.5
3.5
3.5

no
no
no
no

data trade-off
data trade-off
data trade-off
guess and det.

2
2128
2192
2192

264
264
264
1

Schwaemm128-128
Schwaemm192-192
Schwaemm256-256

4.5
4.5
4.5

no
no
no

birthday diff.
birthday diff.
birthday diff.

296+𝜖
2128+𝜖
192
2 + 2160+𝜖

296−𝜖
2128−𝜖
2160−𝜖

Schwaemm256-256

3.5

yes

birthday diff.

2224+𝜖

2224−𝜖

Notation used in the Attacks

Consider an instance of Schwaemm. Let A𝑖𝑗 denote 𝑗-th instance of Alzette at the left half of the
state at step 𝑖 together with the step constant addition:
⎧
⎪
⎨𝐴𝑐0 (𝑥 ⊕ 𝑐𝑖 ), if 𝑗 = 0,
A𝑖𝑗 (𝑥) = 𝐴𝑐1 (𝑥 ⊕ 𝑖), if 𝑗 = 1,
⎪
⎩
𝐴𝑐𝑗 (𝑥),
if 2 ≤ 𝑗 < ℎ𝑏 .
Let B𝑖𝑗 denote the 𝑗-th instance of Alzette at the right half of the state at step 𝑖: B𝑖𝑗 = 𝐴𝑐ℎ𝑏 +𝑗 .
Let A𝑖 denote the parallel application of A𝑖0 , . . . , A𝑖ℎ𝑏 −1 ; B𝑖 denote the parallel application of
B𝑖0 , . . . , B𝑖ℎ𝑏 −1 .
Let X [𝑎] denote the map 𝑥 ↦→ (𝑥 ⊕ 𝑎). Let M denote the linear Feistel map ℳℎ𝑏 and let ℓ′
denote the linear feed-forward function used in M:
ℓ′ ((𝑥1 ||𝑥2 ), (𝑦1 ||𝑦2 )) = (𝑦2 ||𝑦1 ⊕ 𝑦2 ), (𝑥2 ||𝑥1 ⊕ 𝑥2 ),
64

where 𝑥1 , 𝑥2 , 𝑦1 , 𝑦2 ∈ F16
2 .

Let R denote the rotation of ℎ𝑏 branches to the left by one position:
R(𝑥0 , . . . , 𝑥ℎ𝑏 −1 ) = (𝑥1 , . . . , 𝑥ℎ𝑏 −1 , 𝑥0 ).
Consider a known-plaintext scenario. The outer part of the state becomes known before and
after a call to a (round-reduced) Sparkle permutation. Let 𝑚𝑖𝑛 be the initial outer part and 𝑚𝑜𝑢𝑡
be the final outer part. We call the Alzette layer a half-step. Note that in the considered scenario,
any attack on 𝑡 full steps can be trivially extended to 𝑡 + 1/2 steps, since the final calls to Alzette
in the outer part can be easily inverted.

4.4.2

Differential Assumptions on the Alzette Instances

A single isolated iteration of Alzette does not have a strong resistance against differential attacks.
Indeed, there is a differential trail with probability 2−6 . In our attacks, we assume that particular
problems about differential transitions involving random differences can be solved efficiently, even
though we do not propose concrete algorithms. For example, consider the problem of checking
whether a random differential transition over an ARX-box is possible. A naive approach would
require 264 evaluations. However, we can expect that with a meet-in-the-middle method it can be
done much more efficiently. Indeed, Alzette has only 4 rounds. We further assume that the difference distribution table (DDT) of an ARX-box is very sparse and such problems about differential
transitions have few solutions on average.
The problems we consider are about finding all solutions of the following differential transition
types:
𝐴

Problem 1. 𝑎 −
→ 𝑏, where 𝑎, 𝑏 ∈ F64
2 are known random differences, 𝐴 is an ARX-box or the
inverse of an ARX-box,
𝐴

𝐵

𝐴

𝐵

Problem 2. 𝑎 −
→ 𝛼, 𝑏 −
→ 𝛼, where 𝑎, 𝑏 ∈ F64
2 are known random differences, 𝐴, 𝐵 are ARX-boxes
or their inverses, 𝛼 ∈ F64
is
an
unknown
difference.
2
Problem 3. 𝛼 −
→ 𝛽, 𝛼 −
→ 𝛽+𝑎, where 𝑎 ∈ F64
2 is a known random difference, 𝐴, 𝐵 are ARX-boxes
or their inverses, 𝛼, 𝛽 ∈ F64
2 are unknown differences.
We denote the average ratio of solutions to a problem by 𝜈, and the average time to enumerate
all solutions by 𝜏𝑓 .

4.4.3

Birthday-Differential Attacks

Encryptions with unique nonces can be expected to be completely independent. Therefore, a
nonce-respecting adversary can not easily inject differences in the state in the encryption queries.
Indeed, the difference between two encryptions in any part of the state can be expected to be
random, and independent of the message due to the state randomization by the initialization with
unique nonces. However, any fixed difference in 𝑛-bit part of the state may be obtained randomly
among approximately 2𝑛/2 random states. Therefore, with 2𝑛/2 data, we can expect to have a pair
satisfying an 𝑛-bit differential constraint. However, the procedure of finding this pair in the pool
of encryptions has to be efficient.
The most useful differentials for this attack method are zero differences on full branches. They
propagate to zero difference through Alzette. It is also desirable that this differences imply the zero
difference of some function of observable parts of the state (i.e. 𝑚𝑖𝑛 , 𝑚𝑜𝑢𝑡 ). Then a hash table can
be used to filter pairs from the data pool efficiently.
Proposition 4.4.1. Assume that 64𝜂 bits in the encryption process are chosen such that for a
pair of encryptions having zero difference in those 64𝜂 bits,
1. 64𝜇 bits can be efficiently computed from 𝑚𝑖𝑛 , 𝑚𝑜𝑢𝑡 (denote the function by 𝜋), such that
they also have zero difference;
2. pairs of encryptions that satisfying the zero difference can be further filtered in time 𝜏𝑓 ,
keeping a fraction of most 𝜈 𝜂−𝜇 pairs (denote the function by filter
65

3. given such a pair, the full state can be recovered in time 𝜏𝑟 (denote the function by recover).
Then, the full state can be recovered using 264𝜂/2+1/2 data and 264(𝜂−𝜇) (𝜏𝑓 + 𝜈 𝜂−𝜇 𝜏𝑟 ) time. The
general attack procedure is given in Algorithm 4.1.
Proof. There are 264𝜂 pairs in the encryption pool and we can expect to have a pair having the
required zero difference with a high probability. The complexity of the initial filtering by 𝜋 can be
neglected. Therefore, we assume that all 264(𝜂−𝜇) pair candidates (on average) can be enumerated
efficiently. For each candidate, the verification and, in case of verification success, the state recovery
take time 𝜏𝑓 + 𝜈 𝑡 𝜏𝑟 .
Algorithm 4.1 Birthday-Differential attack procedure.
collect 264𝜂/2+1/2 known-plaintext encryptions
compute corresponding outer parts 𝑚𝑖𝑛 , 𝑚𝑜𝑢𝑡
store 𝜋(𝑚𝑖𝑛 , 𝑚𝑜𝑢𝑡 ) for each encryption in a hash table
for all (𝑚𝑖𝑛 , 𝑚𝑜𝑢𝑡 ), (𝑚′𝑖𝑛 , 𝑚′𝑜𝑢𝑡 ) such that 𝜋(𝑚𝑖𝑛 , 𝑚𝑜𝑢𝑡 ) = 𝜋(𝑚′𝑖𝑛 , 𝑚′𝑜𝑢𝑡 ) do
if filter((𝑚𝑖𝑛 , 𝑚𝑜𝑢𝑡 ), (𝑚′𝑖𝑛 , 𝑚′𝑜𝑢𝑡 )) then
𝑠 ← recover((𝑚𝑖𝑛 , 𝑚𝑜𝑢𝑡 ), (𝑚′𝑖𝑛 , 𝑚′𝑜𝑢𝑡 ))
return 𝑠
end if
end for

Attacks of this type typically have quite large data complexity, violating the data limit set in
the specification. However, it should be noted, that the actual key used does not matter as each
state is always expected to be random and independent. Therefore, re-keying does not prevent the
attack. If the required difference is achieved by a pair of encryptions under different keys, then
both states are recovered by the attack.
An adversary can further exploit this fact. The data complexity may be reduced by performing
a precomputation. The adversary encrypts 264𝑡 data (𝑡 may be fractional), and forms a pool in
the same way as in the normal attack. Then, 264(𝜂−𝑡) data is collected from encryptions under the
unknown secret key. Among the too pools, there are 264𝜂 pairs and at least one pair is expected to
satisfy the zero difference with a high probability. Note that the data reduction starts only with
𝑡 > 𝜂/2 and is costly in the time and memory complexity.
4.4.3.1

Attack on 3.5-step Schwaemm Instances without Rate Whitening

Consider an instance of Schwaemm with the rate equal to the capacity (i.e. one of Schwaemm128128, Schwaemm192-192, Schwaemm256-256), which uses the Sparkle permutation reduced to
3 steps and has no rate whitening.
Let 𝑦 denote the output of the linear Feistel function M in second step (as shown in Figure 4.2).
It lies on the following cyclic structure (marked with dashed red rectangle):
[︀
]︀
[︀
]︀
𝑦 = M ∘ (B2 )−1 ∘ X R−1 (𝑚𝑜𝑢𝑡 ) ∘ M ∘ A2 ∘ R ∘ X B1 (A0 (𝑚𝑖𝑛 )) ∘ (𝑦).
Let
𝑚′𝑖𝑛 = B1 (A0 (𝑚𝑖𝑛 )),
𝑚′𝑜𝑢𝑡 = M−1 (R−1 (𝑚𝑜𝑢𝑡 )).
Then

(︁
)︁ (︁
)︁
𝑦 = M ∘ (B2 )−1 ∘ M ∘ X [𝑚′𝑜𝑢𝑡 ] ∘ A2 ∘ R ∘ X [𝑚′𝑖𝑛 ] (𝑦), and

(4.2)

M−1 ∘ B2 ∘ M−1 (𝑦) = X [𝑚′𝑜𝑢𝑡 ] ∘ A2 ∘ R ∘ X [𝑚′𝑖𝑛 ] (𝑦).

(4.3)

Note that Equation 4.2 shows that the unknown part of the state 𝑦 is a fixed point of a
particular bijective structure using the constants 𝑚′𝑖𝑛 , 𝑚′𝑜𝑢𝑡 . This is an interesting formulation of
the constraint on the unknown part of the state.
66

Figure 4.2: Attack on 3.5-step Sparkle without whitening. The green dots show known values,
the purple crosses show zero differences in the birthday-differential attack. The red dashed area
highlights the part being attacked, the purple dashed area shows the part with the target differential
transition in the birthday-differential attack.
𝑚𝑖𝑛
A0

B0
M
R

B1
R

A1
𝑦

M

A2

B2
M
R
𝑚𝑜𝑢𝑡

Precomputation/Data Trade-off Attack. Note that the left part of Equation 4.3 is independent
of 𝑚′𝑖𝑛 , 𝑚′𝑜𝑢𝑡 . Moreover, the right part consists of independent ARX-boxes. Therefore, guessing
one 64-bit branch of 𝑦 leads to knowledge of an input and an output 64-bit branches of the function
from the left-hand side. A data trade-off attack follows. The trade-off parameterized by an integer
𝑟, 0 < 𝑟 ≤ 64.
We start by the precomputation phase. Let 𝑧 = M−1 ∘ B2 ∘ M−1 (𝑦). We iterate over all
𝑦1 ∈ F64−𝑟
and all 𝑦𝑖 ∈ F64
2 for 𝑖 ̸= 1, and generate the table mapping (𝑦1 , 𝑧0 ) to all values 𝑦
2
satisfying the constraint. On average, we expect 264ℎ𝑏 −𝑟 /264 = 264(ℎ𝑏 −1)−𝑟 candidates per each
(𝑦1 , 𝑧0 ) in the table. This step requires 264ℎ𝑏 −𝑟 time and memory blocks.
In the online phase, we collect 2𝑟 known plaintexts-ciphertext pairs and compute the correwe compute
sponding 𝑚′𝑖𝑛 , 𝑚′𝑜𝑢𝑡 for each pair. Then, for each 𝑦1 ∈ F64−𝑟
2
𝑧0 = (𝑚′𝑜𝑢𝑡 )0 ⊕ A20 ((𝑚′𝑖𝑛 )1 ⊕ 𝑦1 ).
For each preimage candidate of (𝑦1 , 𝑧0 ) in the precomputed table, we recover the full state in the
middle of the second step. We then check if the corresponding state correctly connects 𝑚𝑖𝑛 , 𝑚𝑜𝑢𝑡
and possibly recover the secret key by inverting the sponge operation.
If a considered plaintext-ciphertext pair is such that the leftmost 𝑟 bits of 𝑦1 are equal to zero,
then the attack succeeds. Indeed, then, for one of the guesses of 𝑦1 , the pair (𝑦1 , 𝑧0 ) corresponds
to the correct preimage. For each of 2𝑟 plaintext-ciphertext pairs we guess 264−𝑟 values of (𝑦1 , 𝑧0 ).
Correct 𝑦1 identifies a table mapping the 𝑧0 to all possible 𝑦. Therefore, on average, there will
be 264−𝑟 · 264(ℎ𝑏 −1)−𝑟 = 264ℎ𝑏 −2𝑟 total candidates. The time required to check a candidate and to
recover the secret key is negligible.
The online phase requires 2𝑟 different 2-block plaintext-ciphertext pairs, 264ℎ𝑏 −2𝑟 time and
negligible amount of extra memory.
The following attacks on Schwaemm instances follow:
1. Schwaemm128-128: with 𝑟 = 64, the full attack requires 264 time, memory and data; with
𝑟 = 32, the full attack requires 296 time and memory, and 232 data.
2. Schwaemm192-192: with 𝑟 = 64, the full attack requires 2128 time, memory and 264 data.
3. Schwaemm256-256: with 𝑟 = 64, the full attack requires 2192 time, memory and 264 data.

67

Low-data Variant of the Attack on Schwaemm256-256. Due to the high branching number
of M, it is hard to exploit the structure of the function M−1 ∘ B2 ∘ M−1 by guessing several
branches. However, for the largest instance Schwaemm256-256, a simple attack requiring one
known-plaintext and 2192 time is possible.
The key observation is that when ℓ′ (𝑥) is fixed, M(𝑥) splits into ℎ𝑏 independent xors with
′
ℓ (𝑥). In the attack, we simply guess the corresponding ℓ′ for the two calls to M. Precisely, let
ℓ′𝑦 = ℓ′ (M−1 (𝑦)) and ℓ′𝑧 = ℓ′ (M−1 ∘ B2 ∘ M−1 (𝑦)). The computations from Equation 4.2 then split
into one large cycle:
[︀ ]︀
𝑦0 = X ℓ′𝑦 ∘ (B20 )−1 ∘ X [ℓ′𝑧 ] ∘ X [(𝑚′𝑜𝑢𝑡 )0 ] ∘ A20 ∘ X [(𝑚′𝑖𝑛 )1 ] (𝑦1 ),
[︀ ]︀
𝑦1 = X ℓ′𝑦 ∘ (B21 )−1 ∘ X [ℓ′𝑧 ] ∘ X [(𝑚′𝑜𝑢𝑡 )1 ] ∘ A21 ∘ X [(𝑚′𝑖𝑛 )2 ] (𝑦2 ),
[︀ ]︀
𝑦2 = X ℓ′𝑦 ∘ (B22 )−1 ∘ X [ℓ′𝑧 ] ∘ X [(𝑚′𝑜𝑢𝑡 )2 ] ∘ A22 ∘ X [(𝑚′𝑖𝑛 )3 ] (𝑦3 ),
[︀ ]︀
𝑦3 = X ℓ′𝑦 ∘ (B23 )−1 ∘ X [ℓ′𝑧 ] ∘ X [(𝑚′𝑜𝑢𝑡 )3 ] ∘ A23 ∘ X [(𝑚′𝑖𝑛 )0 ] (𝑦0 ).
Let us guess 𝑦0 and compute the whole cycle. If the result matches guessed 𝑦0 , then we obtain
a candidate for the full 𝑦 = (𝑦0 , 𝑦1 , 𝑦2 , 𝑦3 ). On average, we can expect to find one false-positive
candidate.
The attack requires 1 known plaintext-ciphertext pair, negligible amount of memory, and 2192
time.
Birthday-Differential Attack. A birthday-differential attack can be mounted too. We are looking
for a pair having zero difference in 𝑦. Then the expression
X [𝑚′𝑜𝑢𝑡 ] ∘ A2 ∘ R ∘ X [𝑚′𝑖𝑛 ] (𝑦)

(4.4)

has zero difference in the input 𝑦 and zero difference in the output. Therefore, the difference in
𝑚′𝑖𝑛 is transformed into the difference in R(𝑚′𝑜𝑢𝑡 ) by an Alzette layer. This is the first problem we
noted in Section 4.4.2.
Note that the amount of pairs of encryptions in the pool has to be greater than 264ℎ𝑏 in order
for a pair with zero difference in 𝑦 to exist. Therefore, enumeration of all pairs and checking the
A2 ∘R

possibility of the differential transition 𝑚′𝑖𝑛 −−−−→ 𝑚′𝑜𝑢𝑡 results in an ineffective attack.
As described in the birthday-differential attack framework, we further strengthen the constraints in order to obtain an efficient initial filtering. We require that 𝑡 branches of 𝑚′𝑖𝑛 starting
from the second branch have zero difference too, 0 < 𝑡 < ℎ𝑏 . Then, 𝑚′𝑜𝑢𝑡 must have zero difference
in the first 𝑡 branches. This allows us to obtain initial filtering with 𝜇 = 2𝑡, i.e. with the probability
2−64·2𝑡 . In total we need zero difference in ℎ𝑏 + 𝑡 branches. Therefore, we need 264(ℎ𝑏 +𝑡)/2+1/2
data and we expect to keep 264(ℎ𝑏 +𝑡) · 2−64·2𝑡 = 264(ℎ𝑏 −𝑡) pairs on average after the initial filtering
procedure.
The second filtering step is based on filtering possible differential transitions. In the correct
pair, the differences Δ𝑚′𝑖𝑛 and Δ𝑚′𝑜𝑢𝑡 of the values 𝑚′𝑖𝑛 and 𝑚′𝑜𝑢𝑡 respectively are related by the
layer A2 of Alzette calls. More precisely, for all 𝑖, 0 ≤ 𝑖 < ℎ𝑏 , the following differential transition
holds:
A2

𝑖
(Δ𝑚′𝑖𝑛 )𝑖+1 −
−→
(Δ𝑚′𝑜𝑢𝑡 )𝑖 .

Verifying a pair requires checking whether a differential transition over an Alzette instance is
possible or not (see Problem 1 in Section 4.4.2). We assume that only a fraction 𝜈 of all differential
transitions over an Alzette instance is possible, and that for any differential transitions all solutions
can be found in time 𝜏𝑓 on average.
The branch values corresponding to zero difference transitions can be found exhaustively in
time 𝜏𝑟 ≤ 264𝑡 or more efficiently by exploiting the structure further.
We estimate the final complexity of the attack by 264(ℎ𝑏 +𝑡)/2+1/2 data and 264(ℎ𝑏 −𝑡) (𝜏𝑓 +𝜈 ℎ𝑏 −𝑡 𝜏𝑟 )
time. Assuming low values of 𝜈, 𝜏𝑓 and 𝜏𝑟 , we estimate the following attack complexities for different
instances of Schwaemm:
1. Schwaemm128-128: with 𝑡 = 1, the attack requires 296.5 data, and slightly more than 264
time. By the precomputation cost of 296+𝜖 time and memory, the data requirement can be
reduced to 296−𝜖 for any 𝜖 < 32.
68

Figure 4.3: Attack on 4.5-step Sparkle without whitening. The green dots show known values,
the purple crosses show zero differences. The red dashed area highlights the part being attacked,
the purple dashed area shows the part with the target differential transition.
𝑚𝑖𝑛
A0

B0
M
R

B1

A1
M

R
A2
𝑦

B2
M

𝛼
R

B3

A3
M

R
𝑚𝑜𝑢𝑡
2. Schwaemm192-192: with 𝑡 = 1, the attack requires 2128.5 data, and slightly more than 2128
time. By the precomputation cost of 2128+𝜖 time and memory, the data requirement can be
reduced to 2128−𝜖 for any 𝜖 < 64.
3. Schwaemm256-256: with 𝑡 = 1, the attack requires 2160.5 data, and slightly more than 2192
time. By the precomputation cost of 2160+𝜖 time and memory, the data requirement can be
reduced to 2160−𝜖 for any 𝜖 < 96.
4.4.3.2

Attack on 4.5-step Schwaemm without Rate Whitening

Consider an instance of Schwaemm with the rate equal to the capacity (i.e. one of Schwaemm128128, Schwaemm192-192, Schwaemm256-256), which uses the Sparkle permutation reduced to
4 steps and has no rate whitening.
Let 𝑦 be the input to the linear Feistel layer M in the third step (see Figure 4.3). We aim to
mount a birthday-differential attack with zero-difference in 𝑦. The parts of the structure with zero
difference are marked with purple crosses in the figure. It follows that differences of the observed
rate parts can be propagated and connected by independent branches. More formally, let
𝑚′𝑖𝑛 = M−1 (B1 (A0 (𝑚𝑖𝑛 ))),
𝑚′𝑜𝑢𝑡 = M−1 (R(𝑚𝑜𝑢𝑡 )).
Denote the difference in 𝑚′𝑖𝑛 by Δ𝑚′𝑖𝑛 , and the difference in 𝑚′𝑜𝑢𝑡 by Δ𝑚′𝑜𝑢𝑡 . It follows that the
difference Δ𝑚′𝑖𝑛 propagates through B2 into the same difference as the difference Δ𝑚′𝑜𝑢𝑡 propagates
through R−1 ∘ (A3 )−1 . Note that they are connected by ℎ𝑏 independent 64-bit branches:
B2

(A3𝑖−1 )−1

𝑖
(Δ𝑚′𝑖𝑛 )𝑖 −
−→
𝛼𝑖 ←−−−−−− (Δ𝑚′𝑜𝑢𝑡 )𝑖−1 ,

(4.5)

where 𝛼 is the unknown intermediate difference.
In order to make the birthday-differential attack, we further strengthen the zero-difference
constraint in order to perform an efficient initial filtering. We require that (Δ𝑚′𝑖𝑛 )𝑖 = 𝛼𝑖 =
69

Figure 4.4: Attack on 3.5-step Sparkle with whitening. The green dots show known values, the
purple crosses show zero differences. The purple dashed areas shows the parts with the target
differential transitions.
𝑚𝑖𝑛
𝛽
A

0

0

𝛼

M

𝛼

B

𝛼

R

𝛼
B1
𝛾

A1
𝑦

M
R
A2

B2
M
R
𝑚𝑜𝑢𝑡

(Δ𝑚′𝑜𝑢𝑡 )𝑖−1 = 0 for all 𝑖 < 𝑡 for an integer 𝑡, 0 < 𝑡 < ℎ𝑏 . This constraints allows us to filter the
pairs efficiently by the zero-difference parts of 𝑚′𝑖𝑛 and 𝑚′𝑜𝑢𝑡 .
The second filtering step is based on checking the possibility of the differential transitions from
Equation 4.5. This is Problem 2 mentioned in Section 4.4.2.
Similarly to the previous attack, the final complexity of the attack is estimated by 264(ℎ𝑏 +𝑡)/2+1/2
data and 264(ℎ𝑏 −𝑡) (𝜏𝑓 + 𝜈 ℎ𝑏 −𝑡 𝜏𝑟 ) time. Under the assumption of low values of 𝜈, 𝜏𝑓 and 𝜏𝑟 , the
following attacks are derived:
1. Schwaemm128-128: with 𝑡 = 1, the attack requires 296.5 data, and more than 264 time. By
the precomputation cost of 296+𝜖 time and memory, the data requirement can be reduced to
296−𝜖 for any 𝜖 < 32.
2. Schwaemm192-192: with 𝑡 = 1, the attack requires 2128.5 data, and more than 2128 time. By
the precomputation cost of 2128+𝜖 time and memory, the data requirement can be reduced
to 2128−𝜖 for any 𝜖 < 64.
3. Schwaemm256-256: with 𝑡 = 1, the attack requires 2160.5 data, and more than 2192 time. By
the precomputation cost of 2160+𝜖 time and memory, the data requirement can be reduced
to 2160−𝜖 for any 𝜖 < 96.
4.4.3.3

Attack on 3.5-step Schwaemm256-256

Consider Schwaemm256-256, which uses the Sparkle permutation reduced to 3 steps and has
the rate whitening.
Let 𝑦 be the input to the linear Feistel function M in the second step (see Figure 4.4). We
aim to find a pair of encryptions with zero difference in 𝑦. We further restrict the input and the
output difference of M in the first round to have form 𝛼 = (𝛼, 𝛼, 0, 0) for any 𝛼 ∈ F64
2 . Note that
this happens in the fraction 2−3·64 of all inputs to 𝑀 , because (𝛼, 𝛼, 0, 0) is always mapped to
(𝛼, 𝛼, 0, 0) by 𝑀 . In total, we require 7 independent branches to have zero difference.
4
First, observe that for some 𝛽 ∈ (F64
2 ) = (𝛽0 , 𝛽1 , 0, 0), the following differential transitions
hold (see the topmost purple area in Figure 4.4):
A0

𝛼 −−→ 𝛽 ⊕ Δ𝑚𝑖𝑛 ,
B0

𝛼 −−→ 𝛽,
70

where Δ𝑚𝑖𝑛 is the difference in 𝑚𝑖𝑛 . It follows that (Δ𝑚𝑖𝑛 )2 = (Δ𝑚𝑖𝑛 )3 = 0, because 𝛼2 = 𝛼3 =
0. For 𝑖 = 0 and 𝑖 = 1 we obtain an instance of Problem 3 from Section 4.4.2:
A0

𝑖
𝛼 −−→
𝛽𝑖 ⊕ (Δ𝑚𝑖𝑛 )𝑖 ,

B0

𝑖
𝛼 −−→
𝛽𝑖 .

Note that here the same unknown 𝛼 ∈ F64
2 appears in two instances of the problem, thus adding
more constraints on 𝛼. Consider the leftmost purple area in Figure 4.4. It describes another
differential transition:
B1
A2 ∘R
𝛼 −−→ 𝛾 −−−−→ Δ𝑚′𝑜𝑢𝑡 ,

4
′
′
−1
where 𝛾 ∈ (F64
(R−1 (𝑚𝑜𝑢𝑡 )). It
2 ) = (𝛾0 , 𝛾1 , 0, 0) and Δ𝑚𝑜𝑢𝑡 is the difference of 𝑚𝑜𝑢𝑡 = M
′
′
follows that (Δ𝑚𝑜𝑢𝑡 )1 = (Δ𝑚𝑜𝑢𝑡 )2 = 0 and for 𝑖 = 0 and 𝑖 = 1, the following differential transition
holds:
B1

A2𝑖−1

𝑖
𝛼 −−→
𝛾 𝑖 −−−→ (Δ𝑚′𝑜𝑢𝑡 )𝑖−1 .

In total, 𝜂 = 7 branches are constrained to have zero difference and 𝜇 = 4 branches with
zero differences can be observed from 𝑚𝑖𝑛 , 𝑚𝑜𝑢𝑡 , providing strong initial filter. Using 264𝜂/2+1/2
data, we expect to get 264(𝜂−𝜇) = 264·3 encryption pairs after the initial filtering. Furthermore, we
assume that the constraints on the unknown difference 𝛼 ∈ F64
2 are very strong and are enough to
significantly reduce the number of possible encryption pairs. We assume it can be done efficiently,
since a precomputation time of 264·3 is available. After values of branches involved in differential
transitions with 𝛼 are recovered, the rest of the state can be recovered in negligible time.
Therefore, we estimate the data complexity of the attack by 2224.5 and same time complexity
(the heavy filtering step has to filter 2192 pairs). By precomputations costing 2224+𝜖 time and
memory, the data complexity may be reduced to 2224−𝜖 , for any 𝜖 < 32.
This attack does not directly apply to Schwaemm128-128, Schwaemm192-192 since the constraint on the linear map M in the first step is too costly. For Schwaemm192-192 with 𝛼 = (𝛼, 𝛼, 0)
we would obtain 𝜂 = 5, 𝜇 = 2 leaving with 2192 pair candidates, which is too much to filter in time
2192 . Therefore, a stronger initial filter is required.

71

5 Implementation Aspects
5.1

Software Implementations

This section presents some characteristics of Sparkle, with focus on software implementations.

5.1.1

Alzette

The ARX-box Alzette is an important part of Sparkle, and as such, was designed to provide good
security bounds, but also efficient implementation. The rotation amounts have been carefully
chosen to be a multiple of eight bits or one bit from it. On 8 or 16 bit architectures these
rotations can be efficiently implemented using move, swap, and 1-bit rotate instructions. On ARM
processors, operations of the form z ← x <op> (y ≪ n) can be executed with a single instruction
in a single clock cycle, irrespective of the rotation distance.
Alzette itself operates over two 32-bit words of data, with an extra 32-bit constant value. This
allows the full computation to happen in-register in AVR, MSP and ARM architectures, whereby
the latter is able to hold at least 4 Alzette instances entirely in registers. This in turn reduces
load-store overheads and contributes to the performance of the permutation.
The consistency of operations across branches, which means that each branch executes the
same sequence of instructions, allows one to either focus on small code size (by implementing the
Alzette layer in a loop), or on architectures with more registers, execute two or more branches to
exploit instruction pipelining.
This consistency of operations also allows some degree of parallelism, namely by using Single
Instruction Multiple Data (SIMD) instructions. SIMD is a type of computational model that
executes the same operation on multiple operands. The branch structure of Sparkle makes it
possible to manipulate the state through SIMD instructions. In addition, the small size of the
state also allows it to fit in most popular SIMD engines, such as ARM’s NEON and Intel’s SSE or
AVX. Due to the layout of Alzette a SIMD implementation can be created by packing 𝑥0 . . . 𝑥𝑛𝑏 ,
𝑦0 . . . 𝑦𝑛𝑏 , and 𝑐0 . . . 𝑐𝑛𝑏 each in a vector register. That allows 128-bit SIMD architectures such as
NEON to execute four Alzette instances in parallel, or even eight instances when using x86 AVX2
instructions.

5.1.2

Linear Layer

It is, of course, possible to implement the branch permutation at the end of the linear layer like a
branch rotation in the right half followed by a swap of the left and right branches. However, the
combination of the two operation has a unique cycle meaning that it can be implemented simply
in one loop, as shown in Algorithm 5.1. It is the strategy we used in Appendix A. Note that it is
not necessary to reduce the indices modulo 𝑤 or 𝑤/2, which greatly simplifies this implementation
of the linear layer.
Algorithm 5.1 The permutation of 𝑤 branch used in ℒ𝑤
𝑤
Input/Output: (𝑍0 , ..., 𝑍𝑤−1 ) ∈ (F64
2 )
𝑍 ′ ← 𝑍0
for all 𝑖 ∈ {1, ..., 𝑤/2 − 1} do
𝑍𝑖−1 ← 𝑍𝑖+𝑤/2
𝑍𝑖+𝑤/2 ← 𝑍𝑖
end for
𝑍𝑤/2 = 𝑍 ′
return (𝑍0 , ..., 𝑍𝑤−1 )

72

On an optimized implementation, the linear layer’s branch permutations can be abstracted on
an unrolled implementation, at the cost of code size.

5.1.3

Parameterized implementations

Parameterized implementations, offering support to all instances of the algorithm, are easily done
and contribute to a small code size. It also facilitates the writing of macro-based code that
compiles binaries for a specific instance. An implementation of Sparkle can be parameterized by
the number of rounds and branches. Schwaemm implementations need only the rate, capacity,
and round numbers. Similarly, Esch needs only the number of branches and steps. Beyond that, a
single implementation of Sparkle is sufficient for all instances of Schwaemm and Esch, making
optimization, implementation, and testing easier.

5.2

Hardware Implementation

Both Esch and Schwaemm are based on the Sparkle permutations, where addition, rotation,
and XOR are the main components. There exist a number of different design approaches for a
32-bit adder as the largest component in hardware. The simplest variant is a conventional RippleCarry Adder (RCA) composed of 32 Full Adder (FA) cells. RCAs are very efficient in terms of area
requirements, but their delay increases linearly with the bit-length of the adder. Alternatively, if
an implementation requires a short critical path, the adder can also take the form of a CarryLookahead Adder (CLA), Carry-Skip Adder (CSA), or Kogge–Stone Adder (KSA), which have a
delay that grows logarithmically with the word size at the cost of higher area overhead. Rotations
are free in hardware as they are just a simple wiring, and the implementation of XOR operation
is pretty straightforward.
To achieve a high-throughput implementation, each round of a Sparkle permutation can be
implemented as a fully combinatorial circuit, performed by a single clock cycle. In this approach,
the ARX-box Alzette is instantiated multiple times depending on the number of branches, i.e., 𝑛𝑏
times in parallel followed by an instance of linear layer ℒ𝑛𝑏 to realize a round function of Sparkle
permutation. To reduce the area overhead, the ARX-box Alzette can be instantiated once and
re-used multiple times to perform the round function. Hence, each round can be performed in
𝑛𝑏 clock cycles, leading to higher latency but lower area overhead. Moreover, the design can be
optimized further for small size of silicon area. Since only four different amount of rotations namely 16, 17, 24, and 31 bits - are used, it can be simply implemented by 32 instances of a 4-to-1
multiplexer. Hence, a minimalist hardware designer can realize the ARX-box Alzette by a 32-bit
adder, a 32-bit XOR, a 32-bit wide 4-to-1 multiplexer, and a control unit. Following this approach,
each round of Sparkle permutation can be executed in 4𝑛𝑏 clock cycles provided that an instance
of linear layer ℒ𝑛𝑏 is implemented in the design.

5.3

Protection against Side-Channel Attacks

A straightforward implementation of a symmetric cryptographic algorithm such as Schwaemm is
normally vulnerable to side-channel attacks, in particular to Differential Power Anaylsis (DPA).
Timing attacks and conventional Simple Power Analysis (SPA) attacks are a lesser concern since the
specification of Schwaemm does not contain any conditional statement (e.g. if-then-else clauses)
that depend on secret data. A well-known and widely-used countermeasure against DPA attacks
is masking, which can be realized in both hardware and software. Masking aims to conceal every
key-dependent variable with a random value called mask (or a set of masks for high orders) to
decorrelate the sensitive data of the algorithm from the data that is actually processed on the
device. The basic principle is related to the idea of secret sharing because every sensitive variable
is split up into 𝑛 ≥ 2 “shares” so that any combination of up to 𝑑 = 𝑛 − 1 shares is statistically
independent of any secret value. These 𝑛 shares have to be processed separately during the
execution of the algorithm (to ensure their leakages are independent of each other) and then
recombined at the end to yield the correct result.
Depending on the actual operation to be protected against DPA, a masking scheme can be
Boolean (using logical XOR), arithmetic (using modular addition or modular subtraction) or mul73

tiplicative (using modular multiplication). Since Schwaemm is an ARX design and, consequently,
involves arithmetic and Boolean operations, the masks have to be converted from one form to the
other without introducing any kind of leakage. There exists an abundant literature on mask conversion techniques and it is nowadays well understood how one can convert efficiently from arithmetic
masks to Boolean masks and vice versa, see e.g. [CGV14]. An alternative approach is to compute
the arithmetic operations (i.e. modular addition) directly on Boolean shares as described in e.g.
[CGTV15, SMG15]. In summary, Schwaemm profits from the vast body of research on masking
schemes for ARX designs and can be effectively and efficiently protected against DPA attacks.

5.4

Implementation Results

Accompanying this submission are reference and optimized C implementations of different instances
of Schwaemm and Esch, as well as assembler implementations of the Sparkle permutation for
8-bit AVR ATmega and 32-bit ARM Cortex-M microcontrollers. The AVR assembler code for
Sparkle is parameterized by the number of branches and the number of steps, and complies with
the interface of the optimized C implementation. Therefore, the assembler implementation can
serve as a “plug-in” replacement for the optimized C code to further increase the performance on
AVR devices. Thanks to the parameterization, the assembler implementation of Sparkle provides
the full functionality needed by the different instances of Schwaemm and Esch.
In contrast to AVR, we developed separate assembler implementations for Sparkle256, Sparkle384, and Sparkle512 for ARM, which are “branch-unrolled” in the sense that the number of
branches is hard-coded and not passed as argument anymore. However, all three ARM assembler
implementations are still parameterized by the number of steps so that a unique assembler function
is capable to support both the slim and big number of steps specified in Table 2.1. The main reason why it makes sense to develop three branch-unrolled Assembler implementations of Sparkle
for ARM but not for AVR is the large register space of the former architecture, which is capable
to accommodate the full state of Sparkle256 and Sparkle384, thereby significantly reducing
the number of load/store operations. Unfortunately, this approach for optimizing the two smaller
Sparkle instances can not be applied in a single branch-parameterized assembler function. It
is nonetheless possible to have a “plug-in” assembler replacement for the fully-parameterized C
implementation of the Sparkle permutation by writing a wrapper over the three Sparkle functions that has the same interface as the C implementation (i.e. this wrapper is parameterized by
both the number of steps and the number of branches). The wrapper simple checks the number of
branches and then calls the corresponding variant of the assembler function, i.e. Sparkle256 when
the number of branches is 4, Sparkle384 when the number of branches is 6, and Sparkle512
when the number of branches is 8.
The execution times and throughputs of our assembler implementations of the Sparkle permutation for AVR and ARM are summarized in Table 5.1. On AVR, the assembler code is approximately four times faster than the optimized C code (compiled with avr-gcc 5.4.0), which is roughly
in line with the results observed in [CDG19]. The main reasons for the relatively bad performance
of the compiled code are a poor register allocation strategy (which causes many unnecessary memory accesses) and the non-optimal code generated for the rotations compared to hand-optimized
assembler code. Our AVR assembler implementation is also relatively small in terms of code size
(702 bytes) and occupies only 21 bytes on the stack (for callee-saved registers). All execution times
for AVR were determined with help of the cycle-accurate instruction set simulator of Atmel Studio
7 using the ATmega128 microcontroller as target device.
The performance gap between the compiled C code and the hand-written assembler code is a
bit smaller on ARM, namely by a factor of roughly 2.5 when executed on a Cortex-M3. However,
it has to be taken into account that the assembler functions are “branch-unrolled,” whereas the
C version is fully parameterized. The C implementation was compiled with Keil MicroVision
v5.24.2.0 using optimization level -O2. Obviously, the large register space and the “free” rotations
of the ARM architecture make it easier for a compiler to generate efficient code. The binary code
size of the assembler implementations of Sparkle for ARM ranges between 348 and 628 bytes
and they occupy at most 52 bytes on the stack, of which 36 bytes are due to callee-saved registers
(see Table 5.2). All execution times for ARM specified in Table 5.1 were obtained with the cycleaccurate instruction set simulator of Keil MicroVision using a generic Cortex-M3 model as target
74

Table 5.1: Performance of the Sparkle permutation on an 8-bit AVR ATmega128 and a 32-bit
ARM Cortex-M3 microcontroller. The results are given in cycles/byte, with the number inside
parentheses representing the total cycle count for an execution of the permutation.

Permutation

Sparkle256

Sparkle384

Sparkle512

Rounds

AVR

ARM

C

asm

C

asm

7 (slim)

697 (22305)

179 ( 5728)

46 (1487)

19 ( 605)

10 (big)

992 (31761)

254 ( 8146)

66 (2111)

26 ( 842)

7 (slim)

680 (32679)

173 ( 8318)

45 (2173)

19 ( 930)

11 (big)

1066 (51215)

271 (13022)

71 (3397)

30 (1430)

8 (slim)

768 (49169)

194 (12454)

51 (3263)

23 (1489)

12 (big)

1150 (73633)

291 (18638)

76 (4879)

35 (2209)

device.1 It should be noted that the results for ARM are based on assembler implementations that
were optimized to achieve a balance between (binary) code size and speed, which means we refrained
from certain optimization techniques like full loop unrolling (i.e. unrolling not only the branches
but also the steps). However, we also developed more aggressively speed-optimized versions of
the three permutations where we fully unrolled the step-loop, which reduces the execution time
by between 15% and 18% (e.g. 149 cycles in the case of Sparkle384 with the slim number of
steps). This performance gain is not only due to the elimination of the overhead of the step-loop.
Indeed, the execution time of the linear layer could be further reduced: concretely, the 1-branch
left-rotation of the right-side branches in the linear layer is done “implicitly”. The downside of
this full loop unrolling is a massive increase in code size (e.g. by a factor of almost 6 for the slim
version of Sparkle384).
Table 5.2: Code size and stack consumption of the Sparkle permutations on a 32-bit ARM CortexM3 microcontroller. The code size is given as the number of bytes the permutation occupies in the
text segment plus the 32 bytes for the round constants.
Permutation

Code Size (byte)

Stack Usage (byte)

Sparkle256

316+32

40

Sparkle384

452+32

48

Sparkle512

596+32

52

Besides Sparkle, a multitude of other permutation-based designs was submitted to the NIST
lightweight cryptography standardization process. Three of those designs, namely Ascon, Gimli,
and Xoodoo, come with optimized (i.e. fully unrolled) assembler implementations of the underlying permutation for the Cortex-M series of ARM microcontrollers. Table 5.3 compares the execution time and code size of the permutations of Ascon, Gimli and Xoodoo with a fully-unrolled
version of Sparkle384, which is the permutation used by the primary instance of Schwaemm
and Esch.2 As mentioned before, full loop unrolling reduces the execution time of Sparkle384
from 930 to 781 clock cycles, but this reduction by 149 cycles comes at the expense of an almost
1 As mentioned on http://www2.keil.com/mdk5/simulation, the Keil simulator assumes ideal conditions for
memory accesses and does not simulate wait states for data or code fetches. Therefore, the timings in Table 5.1
should be seen as lower bounds of the actual execution times one will get on a real Cortex-M3 device. The fact that
the Keil simulator does not take flash wait-states into account may also explain why our simulated execution time
for the Gimli permutation (1041 cycles) differs slightly from the 1047 cycles specified in Section 5.5 of [BKL+ 17a].
2 We took the ARM Assembler source code of Gimli from http://gimli.cr.yp.to/gimli-20170627.tar.gz and
converted it from the GNU syntax to the Keil syntax. The source code of Xoodoo contained in the eXtended Keccak
Code Package (XKCP) at http://github.com/XKCP/XKCP/tree/master/lib/low/Xoodoo was already in Keil syntax.

75

Table 5.3: Comparison of fully unrolled ARMv7-M Assembler implementations of the permutations
of Ascon, Sparkle384, Gimli and Xoodoo on a Cortex-M3 microcontroller.
Permutation

Code Size (byte)

Time (cycles)

Time/Rate (cycles/byte)

Ascon (8 rounds)

1810

499

31.19

Gimli (24 rounds)

3950

1041

65.06

Sparkle384 (7 steps)

2820

781

24.40

Xoodoo (12 rounds)

2376

657

27.38

6-fold increase of code size. Also given in Table 5.3 is the throughput (in cycles per byte) of the
permutations, which is simply the execution time of the permutation divided by the rate of the
main instance of the corresponding AEAD algorithm (16 bytes for Ascon and Gimli, 32 bytes
for Schwaemm256-128, and 24 bytes for Xoodyak). Sparkle384 achieves the highest throughput,
closely followed by Xoodoo and Ascon. Gimli reaches less than half of the throughput of the
other three permutations, but it has to be taken into account that the Gimli AEAD algorithm
aims for 256 bits of security.
Table 5.4: Benchmarking results for the different instances of Schwaemm and Esch on an AVR
ATmega128 microcontroller when processing 64 and 1536 bytes of data, respectively (in the case
of Schwaemm the benchmarked operation is encryption and the length of the associated data is
0). The results are given in cycles/byte, with the number inside parentheses representing the total
cycle count for processing the specified amount of data.

Instance

64 bytes of data

1536 bytes of data

Pure C

C + asm

Pure C

C + asm

Schwaemm128-128

2444 (156416)

712 (45583)

1421 (2182899)

387 (594898)

Schwaemm256-128

2105 (134748)

596 (38166)

1071 (1644606)

302 (464347)

Schwaemm192-192

2594 (165994)

727 (46526)

1399 (2148858)

395 (606716)

Schwaemm256-256

3014 (192918)

839 (53704)

1574 (2417064)

434 (666554)

Esch256

2714 (173678)

893 (57187)

1978 (3038834)

559 (860071)

Esch384

4732 (302837)

1308 (83725)

2992 (4595649)

830 (161717)

Table 5.4 shows the AVR execution times and throughputs of the different Schwaemm and
Esch instances when processing a small amount (64 bytes) and a large amount (1536 bytes) of
data, respectively. As before, all execution times were obtained with the cycle-accurate simulator of
Atmel Studio 7 using an ATmega128 as target device. The results in the “C + asm” columns refer
to a C implementation that uses the hand-written assembler code for the Sparkle permutation.
Table 5.5 summarizes the corresponding results for an ARM Cortex-M3 device.
In order to compare the performance of Esch256 (using the assembler implementation of
Sparkle as sub-function) with that of other (lightweight) hash functions, we simulated the time it
needs to hash a 500-byte message on an 8-bit AVR ATmega128 microcontroller. Indeed, determining the execution time required for hashing a 500-byte message on AVR is a well-established way to
generate benchmarks for a comparison of lightweight hash functions. According to our simulation
results, the mixed C and assembler implementation of Esch256 has an execution time of 289131
clock cycles, which translates to a hash rate of 578 cycles/byte. The binary code size of Esch256
is 1428 bytes. Table 5.6 summarizes the implementation results of Esch256, SHA-2, SHA-3,
some SHA-3 finalists, as well as Gimli [BKL+ 17a]. Our hash rate of 578 cycles/byte for Esch256
compares favorably with the results of the SHA-3 finalists and is beaten only by Blake-256 and
SHA-256. However, it must be taken into account that the results reported in [BEE+ 13] were
obtained with “pure” assembler implementations, whereas Esch256 contains hand-optimized as76

Table 5.5: Benchmarking results for the different instances of Schwaemm and Esch on an ARM
Cortex-M3 microcontroller when processing 64 and 1536 bytes of data, respectively (in the case
of Schwaemm the benchmarked operation is encryption and the length of the associated data is
0). The results are given in cycles/byte, with the number inside parentheses representing the total
cycle count for processing the specified amount of data.
64 bytes of data

Instance

1536 bytes of data

Pure C

C + asm

Pure C

C + asm

Schwaemm128-128

148 ( 9491)

69 (4384)

101 (155495)

46 (70440)

Schwaemm256-128

154 ( 9851)

74 (4715)

77 (118917)

37 (57109)

Schwaemm192-192

189 (12066)

89 (5698)

100 (153597)

47 (72077)

Schwaemm256-256

219 (14029)

111 (7072)

113 (173051)

56 (86284)

Esch256

198 (12654)

90 ( 5774)

114 (221678)

66 (101454)

Esch384

341 (21847)

165 (10561)

216 (332623)

105 (161717)

sembler code only for the Sparkle permutation. We expect that a fully-optimized implementation
of Esch256 with all its components written in assembler has the potential to be faster Blake-256
and get very close to (or even outperform) SHA-256.
Table 5.6: Comparison of Esch256 with other hash functions producing a 256-bit digest. The
number of cycles and the throughput were obtained by hashing a 500-byte message on an AVR
microcontroller. The implementation of Esch256 contains hand-optimized assembler code only
for the permutation, whereas the implementations of all other hash functions were written entirely
in assembler.
Hash function

Ref.

Throughput (c/b)

Code size (b)

Esch256

This paper

578

1428

Blake-256

[BEE+ 13]

562

1166

Gimli-Hash small

+

[BKL 17b]

1610

778*

Gimli-Hash fast

[BKL+ 17b]

Groestl-256
JH-256
Keccak

725

19218*

+

686

1400

+

5062

1020

+

1432

868

+

532

1090

[BEE 13]
[BEE 13]

†

SHA-256

[BEE 13]
[BEE 13]

*

The code size corresponds to the permutation alone.

†

The version of Keccak considered is Keccak[𝑟 = 1088, 𝑐 = 512].

A comparison of the performance of hash functions is easily possible because there exist a number of implementation results in the literature (e.g. [BEE+ 13]) that were obtained in a consistent
fashion, in particular by measuring the execution time required for hashing a 500-byte message on
AVR. Unfortunately, there seems to be no similarly established way of generating benchmarking
results for lightweight authenticated encryption algorithms since the results one can find in the
literature were obtained with completely different lengths of plaintexts/ciphertexts and associated
data.

77

Bibliography
[AC17]

Carlisle Adams and Jan Camenisch, editors. SAC 2017, volume 10719 of LNCS.
Springer, Heidelberg, August 2017.

[ADMA15]

Elena Andreeva, Joan Daemen, Bart Mennink, and Gilles Van Assche. Security
of keyed sponge constructions using a modular proof approach. In Gregor Leander, editor, FSE 2015, volume 9054 of LNCS, pages 364–384. Springer, Heidelberg,
March 2015.

[AEL+ 18]

Tomer Ashur, Maria Eichlseder, Martin M. Lauridsen, Gaëtan Leurent, Brice
Minaud, Yann Rotella, Yu Sasaki, and Beno^ıt Viguier. Cryptanalysis of MORUS. In
Thomas Peyrin and Steven Galbraith, editors, ASIACRYPT 2018, Part II, volume
11273 of LNCS, pages 35–64. Springer, Heidelberg, December 2018.

[AES01]

Advanced Encryption Standard (AES). National Institute of Standards and Technology (NIST), FIPS PUB 197, U.S. Department of Commerce, November 2001.

[AJN16]

Jean-Philippe Aumasson, Philipp Jovanovic, and Samuel Neves. Norx v3.0, 2016.
Submission to CAESAR, available via https://competitions.cr.yp.to/round3/
norxv30.pdf.

[AK18]

Ralph Ankele and Stefan Kölbl. Mind the gap - A closer look at the security of block
ciphers against differential cryptanalysis. In Carlos Cid and Michael J. Jacobson
Jr., editors, SAC 2018, volume 11349 of LNCS, pages 163–190. Springer, 2018.

[AL18]

Ralph Ankele and Eik List. Differential cryptanalysis of round-reduced sparx64/128. In Bart Preneel and Frederik Vercauteren, editors, ACNS 18, volume 10892
of LNCS, pages 459–475. Springer, Heidelberg, July 2018.

[ARH+ 17]

Riham AlTawy, Raghvendra Rohit, Morgan He, Kalikinkar Mandal, Gangqiang
Yang, and Guang Gong. sLiSCP: Simeck-based permutations for lightweight sponge
cryptographic primitives. In Adams and Camenisch [AC17], pages 129–150.

[ARH+ 18]

Riham Altawy, Raghvendra Rohit, Morgan He, Kalikinkar Mandal, Gangqiang
Yang, and Guang Gong. SLISCP-light: Towards hardware optimized sponge-specific
cryptographic permutations. ACM Trans. Embed. Comput. Syst., 17(4):81:1–81:26,
August 2018.

[ATY17]

Ahmed Abdelkhalek, Mohamed Tolba, and Amr M. Youssef. Impossible differential
attack on reduced round SPARX-64/128. In Marc Joye and Abderrahmane Nitaj, editors, AFRICACRYPT 17, volume 10239 of LNCS, pages 135–146. Springer,
Heidelberg, May 2017.

[BBCdS+ 20a] Christof Beierle, Alex Biryukov, Luan Cardoso dos Santos, Johann Großschädl, Léo
Perrin, Aleksei Udovenko, Vesselin Velichkov, and Qingju Wang. Alzette: A 64-bit
arx-box - (feat. CRAX and TRAX). In Daniele Micciancio and Thomas Ristenpart,
editors, CRYPTO 2020, volume 12172 of LNCS, pages 419–448. Springer, 2020.
[BBCdS+ 20b] Christof Beierle, Alex Biryukov, Luan Cardoso dos Santos, Johann Großschädl,
Léo Perrin, Aleksei Udovenko, Vesselin Velichkov, and Qingju Wang. Lightweight
aead and hashing using the Sparkle permutation family. IACR Transactions on
Symmetric Cryptology, 2020(S1):208–261, 2020.
[BBD+ 99]

Eli Biham, Alex Biryukov, Orr Dunkelman, Eran Richardson, and Adi Shamir.
Initial observations on Skipjack: Cryptanalysis of Skipjack-3XOR (invited talk). In
Stafford E. Tavares and Henk Meijer, editors, SAC 1998, volume 1556 of LNCS,
pages 362–376. Springer, Heidelberg, August 1999.
78

[BBS99]

Eli Biham, Alex Biryukov, and Adi Shamir. Cryptanalysis of Skipjack reduced to 31
rounds using impossible differentials. In Jacques Stern, editor, EUROCRYPT’99,
volume 1592 of LNCS, pages 12–23. Springer, Heidelberg, May 1999.

[BDBP03]

Alex Biryukov, Christophe De Canniére, An Braeken, and Bart Preneel. A toolbox
for cryptanalysis: Linear and affine equivalence algorithms. In Eli Biham, editor,
EUROCRYPT 2003, volume 2656 of LNCS, pages 33–50. Springer, Heidelberg, May
2003.

[BDG16]

Alex Biryukov, Daniel Dinu, and Johann Großschädl. Correlation power analysis of
lightweight block ciphers: From theory to practice. In International Conference on
Applied Cryptography and Network Security – ACNS 2016, volume 9696 of Lecture
Notes in Computer Science, pages 537–557. Springer, 2016.

[BDP+ 16a]

Guido Bertoni, Joan Daemen, Michaël Peeters, Gilles Van Assche, and Ronny Van
Keer. Caesar submission: Ketje v2, 2016. Submission to CAESAR, available via
https://competitions.cr.yp.to/round3/ketjev2.pdf.

[BDP+ 16b]

Guido Bertoni, Joan Daemen, Michaël Peeters, Gilles Van Assche, and Ronny Van
Keer. Caesar submission: Keyak v2, 2016. Submission to CAESAR, available via
https://competitions.cr.yp.to/round3/keyakv22.pdf.

[BDPA11]

Guido Bertoni, Joan Daemen, Michaël Peeters, and Gilles Van Assche. Duplexing
the sponge: Single-pass authenticated encryption and other applications. In Ali Miri
and Serge Vaudenay, editors, Selected Areas in Cryptography - 18th International
Workshop, SAC 2011, Toronto, ON, Canada, August 11-12, 2011, Revised Selected
Papers, volume 7118 of Lecture Notes in Computer Science, pages 320–337. Springer,
2011.

[BDPV08]

Guido Bertoni, Joan Daemen, Michael Peeters, and Gilles Van Assche. On the
indifferentiability of the sponge construction. In Nigel P. Smart, editor, EUROCRYPT 2008, volume 4965 of LNCS, pages 181–197. Springer, Heidelberg, April
2008.

[BDPVA07]

Guido Bertoni, Joan Daemen, Michaël Peeters, and Gilles Van Assche. Sponge
functions. In ECRYPT hash workshop, 2007.

[BDPVA11]

Guido Bertoni, Joan Daemen, Michaël Peeters, and Gilles Van Assche. Cryptographic sponge functions, 2011. Available at https://keccak.team/files/CSF-0.
1.pdf.

[BEE+ 13]

Josep Balasch, Baris Ege, Thomas Eisenbarth, Beno^ıt Gérard, Zheng Gong, Tim
Güneysu, Stefan Heyse, Stéphanie Kerckhof, François Koeune, Thomas Plos,
Thomas Pöppelmann, Francesco Regazzoni, François-Xavier Standaert, Gilles Van
Assche, Ronny Van Keer, Loı̈c van Oldeneel tot Oldenzeel, and Ingo von Maurich.
Compact implementation and performance evaluation of hash functions in ATtiny
devices. In Stefan Mangard, editor, Smart Card Research and Advanced Applications — CARDIS 2012, volume 7771 of Lecture Notes in Computer Science, pages
158–172. Springer Verlag, 2013.

[BKL+ 17a]

Daniel J. Bernstein, Stefan Kölbl, Stefan Lucks, Pedro Maat Costa Massolino, Florian Mendel, Kashif Nawaz, Tobias Schneider, Peter Schwabe, François-Xavier Standaert, Yosuke Todo, and Beno^ıt Viguier. Gimli : A cross-platform permutation.
In Wieland Fischer and Naofumi Homma, editors, Cryptographic Hardware and
Embedded Systems - CHES 2017 - 19th International Conference, Taipei, Taiwan,
September 25-28, 2017, Proceedings, volume 10529 of Lecture Notes in Computer
Science, pages 299–320. Springer, 2017.

79

[BKL+ 17b]

Daniel J. Bernstein, Stefan Kölbl, Stefan Lucks, Pedro Maat Costa Massolino, Florian Mendel, Kashif Nawaz, Tobias Schneider, Peter Schwabe, François-Xavier Standaert, Yosuke Todo, and Beno^ıt Viguier. Gimli : A cross-platform permutation. In
Wieland Fischer and Naofumi Homma, editors, CHES 2017, volume 10529 of LNCS,
pages 299–320. Springer, Heidelberg, September 2017.

[BR14]

Andrey Bogdanov and Vincent Rijmen. Linear hulls with correlation zero and
linear cryptanalysis of block ciphers. Designs, codes and cryptography, 70(3):369–
383, 2014.

[BS91]

Eli Biham and Adi Shamir. Differential cryptanalysis of DES-like cryptosystems.
In Alfred J. Menezes and Scott A. Vanstone, editors, CRYPTO’90, volume 537 of
LNCS, pages 2–21. Springer, Heidelberg, August 1991.

[BVC16]

Alex Biryukov, Vesselin Velichkov, and Yann Le Corre. Automatic search for the
best trails in ARX: Application to block cipher speck. In Peyrin [Pey16], pages
289–310.

[BW99]

Alex Biryukov and David Wagner. Slide attacks. In Knudsen [Knu99], pages 245–
259.

[CCF+ 21]

Tingting Cui, Shiyao Chen, Kai Fu, Meiqin Wang, and Keting Jia. New automatic
tool for finding impossible differentials and zero-correlation linear approximations.
Sci. China Inf. Sci., 64(2), 2021.

[CDG19]

Hao Cheng, Daniel Dinu, and Johann Großschädl. Efficient implementation of the
SHA-512 hash function for 8-bit AVR microcontrollers. In Jean-Louis Lanet and
Cristian Toma, editors, Innovative Security Solutions for Information Technology
and Communications - 11th International Conference, SecITC 2018, Bucharest,
Romania, November 8-9, 2018, Revised Selected Papers, volume 11359 of Lecture
Notes in Computer Science, pages 273–287. Springer Verlag, 2019.

[CDNY18]

Avik Chakraborti, Nilanjan Datta, Mridul Nandi, and Kan Yasuda. Beetle family of lightweight and secure authenticated encryption ciphers. IACR TCHES,
2018(2):218–241, 2018. https://tches.iacr.org/index.php/TCHES/article/
view/881.

[CGTV15]

Jean-Sébastien Coron, Johann Großschädl, Mehdi Tibouchi, and Praveen Kumar
Vadnala. Conversion from arithmetic to boolean masking with logarithmic complexity. In Gregor Leander, editor, Fast Software Encryption - 22nd International
Workshop, FSE 2015, Istanbul, Turkey, March 8-11, 2015, Revised Selected Papers,
volume 9054 of Lecture Notes in Computer Science, pages 130–149. Springer, 2015.

[CGV14]

Jean-Sébastien Coron, Johann Großschädl, and Praveen Kumar Vadnala. Secure
conversion between boolean and arithmetic masking of any order. In Lejla Batina
and Matthew Robshaw, editors, Cryptographic Hardware and Embedded Systems CHES 2014 - 16th International Workshop, Busan, South Korea, September 2326, 2014. Proceedings, volume 8731 of Lecture Notes in Computer Science, pages
188–205. Springer, 2014.

[CN17]

Jean-Sébastien Coron and Jesper Buus Nielsen, editors. EUROCRYPT 2017,
Part III, volume 10212 of LNCS. Springer, Heidelberg, April / May 2017.

[CT16]

Jung Hee Cheon and Tsuyoshi Takagi, editors. ASIACRYPT 2016, Part I, volume
10031 of LNCS. Springer, Heidelberg, December 2016.

[Dae95]

Joan Daemen. Cipher and hash function design strategies based on linear and differential cryptanalysis. PhD thesis, Doctoral Dissertation, March 1995, KU Leuven,
1995.

80

[DEMS16]

Christoph Dobraunig, Maria Eichlseder, Florian Mendel, and Martin Schläffer. Ascon v1.2, 2016. Submission to CAESAR, available via https://competitions.cr.
yp.to/round3/asconv12.pdf.

[DES77]

Data encryption standard. National Bureau of Standards, NBS FIPS PUB 46, U.S.
Department of Commerce, January 1977.

[DKR97]

Joan Daemen, Lars R. Knudsen, and Vincent Rijmen. The block cipher Square.
In Eli Biham, editor, FSE’97, volume 1267 of LNCS, pages 149–165. Springer,
Heidelberg, January 1997.

[DPU+ 16]

Daniel Dinu, Léo Perrin, Aleksei Udovenko, Vesselin Velichkov, Johann Großschädl,
and Alex Biryukov. Design strategies for ARX with provable bounds: Sparx and
LAX. In Cheon and Takagi [CT16], pages 484–513.

[DR02]

Joan Daemen and Vincent Rijmen. The Design of Rijndael: AES - The Advanced
Encryption Standard. Springer, 2002.

[Dwo15]

Morris J Dworkin. Sha-3 standard: Permutation-based hash and extendable-output
functions. Federal Inf. Process. Stds.(NIST FIPS)-202, 2015.

[FWG+ 16]

Kai Fu, Meiqin Wang, Yinghua Guo, Siwei Sun, and Lei Hu. MILP-based automatic
search algorithms for differential and linear trails for speck. In Peyrin [Pey16], pages
268–288.

[GO18]

LLC Gurobi Optimization. Gurobi optimizer reference manual, 2018.

[Hir16]

Shoichi Hirose. Sequential hashing with minimum padding. In NIST Workshop
on Lightweight Cryptography 2016. National Institute of Standards and Technology
(NIST), 2016.

[Hir18]

Shoichi Hirose. Sequential hashing with minimum padding. Cryptography, 2:11,
2018.

[JLM14]

Philipp Jovanovic, Atul Luykx, and Bart Mennink. Beyond 2𝑐/2 security in spongebased authenticated encryption modes. In Palash Sarkar and Tetsu Iwata, editors,
ASIACRYPT 2014, Part I, volume 8873 of LNCS, pages 85–104. Springer, Heidelberg, December 2014.

[JLM+ 18]

Philipp Jovanovic, Atul Luykx, Bart Mennink, Yu Sasaki, and Kan Yasuda. Beyond
conventional security in sponge-based authenticated encryption modes. Journal of
Cryptology, Jun 2018.

[Knu95]

Lars R. Knudsen. Truncated and higher order differentials. In Bart Preneel, editor,
FSE’94, volume 1008 of LNCS, pages 196–211. Springer, Heidelberg, December
1995.

[Knu98]

Lars Knudsen. Deal - a 128-bit block cipher. NIST AES Proposal, 1998.

[Knu99]

Lars R. Knudsen, editor. FSE’99, volume 1636 of LNCS. Springer, Heidelberg,
March 1999.

[KS07]

Liam Keliher and Jiayuan Sui. Exact maximum expected differential and linear
probability for 2-round Advanced Encryption Standard. IET Information Security,
1(2):53–57, 2007.

[Küç09]

Özgül Küçük. The hash function Hamsi. Submission to the NIST SHA-3
competition; available online at https://securewww.esat.kuleuven.be/cosic/
publications/article-1203.pdf., 2009.

[KW02]

Lars R. Knudsen and David Wagner. Integral cryptanalysis. In Joan Daemen and
Vincent Rijmen, editors, FSE 2002, volume 2365 of LNCS, pages 112–127. Springer,
Heidelberg, February 2002.
81

[LAAZ11]

Gregor Leander, Mohamed Ahmed Abdelraheem, Hoda AlKhzaimi, and Erik Zenner. A cryptanalysis of PRINTcipher: The invariant subspace attack. In Phillip
Rogaway, editor, CRYPTO 2011, volume 6841 of LNCS, pages 206–221. Springer,
Heidelberg, August 2011.

[Liu17]

Zhengbin Liu. Automatic Tools for Differential and Linear Cryptanalysis of ARX
Ciphers. PhD thesis, University of Chinese Academy of Science, 2017. In Chinese.

[LLJW21]

Zhengbin Liu, Yongqiang Li, Lin Jiao, and Mingsheng Wang. A new method for
searching optimal differential and linear trails in arx ciphers. IEEE Transactions
on Information Theory, 67(2):1054–1068, 2021.

[LMM91]

Xuejia Lai, James L. Massey, and Sean Murphy. Markov ciphers and differential
cryptanalysis. In Donald W. Davies, editor, EUROCRYPT’91, volume 547 of LNCS,
pages 17–38. Springer, Heidelberg, April 1991.

[LWR16]

Yunwen Liu, Qingju Wang, and Vincent Rijmen. Automatic search of linear trails
in ARX with applications to SPECK and chaskey. In Mark Manulis, Ahmad-Reza
Sadeghi, and Steve Schneider, editors, ACNS 16, volume 9696 of LNCS, pages 485–
499. Springer, Heidelberg, June 2016.

[MA20]

Amirhossein Ebrahimi Moghaddam and Zahra Ahmadian. New automatic search
method for truncated-differential characteristics application to Midori, SKINNY
and CRAFT. The Computer Journal, 63(12):1813–1825, 2020.

[Mat94]

Mitsuru Matsui. Linear cryptanalysis method for DES cipher. In Tor Helleseth, editor, EUROCRYPT’93, volume 765 of LNCS, pages 386–397. Springer, Heidelberg,
May 1994.

[Mat95]

Mitsuru Matsui. On correlation between the order of S-boxes and the strength of
DES. In Alfredo De Santis, editor, EUROCRYPT’94, volume 950 of LNCS, pages
366–375. Springer, Heidelberg, May 1995.

[NPB15]

Aina Niemetz, Mathias Preiner, and Armin Biere. Boolector 2.0 system description. Journal on Satisfiability, Boolean Modeling and Computation, 9:53–58, 2014
(published 2015).

[Pey16]

Thomas Peyrin, editor. FSE 2016, volume 9783 of LNCS. Springer, Heidelberg,
March 2016.

[PGC98]

Jacques Patarin, Louis Goubin, and Nicolas Courtois. Improved algorithms for
isomorphisms of polynomials. In Kaisa Nyberg, editor, EUROCRYPT’98, volume
1403 of LNCS, pages 184–200. Springer, Heidelberg, May / June 1998.

[QSLG17]

Kexin Qiao, Ling Song, Meicheng Liu, and Jian Guo. New collision attacks on
round-reduced keccak. In Coron and Nielsen [CN17], pages 216–243.

[SBK+ 17]

Marc Stevens, Elie Bursztein, Pierre Karpman, Ange Albertini, and Yarik Markov.
The first collision for full SHA-1. In Jonathan Katz and Hovav Shacham, editors,
CRYPTO 2017, Part I, volume 10401 of LNCS, pages 570–596. Springer, Heidelberg, August 2017.

[SLG17]

Ling Song, Guohong Liao, and Jian Guo. Non-full sbox linearization: Applications
to collision attacks on round-reduced keccak. In Jonathan Katz and Hovav Shacham,
editors, CRYPTO 2017, Part II, volume 10402 of LNCS, pages 428–451. Springer,
Heidelberg, August 2017.

[SMG15]

Tobias Schneider, Amir Moradi, and Tim Güneysu. Arithmetic addition over
boolean masking - towards first- and second-order resistance in hardware. In Tal
Malkin, Vladimir Kolesnikov, Allison Bishop Lewko, and Michalis Polychronakis,
editors, ACNS 2015, volume 9092 of LNCS, pages 559–578. Springer, 2015.
82

[ST17]

Yu Sasaki and Yosuke Todo. New impossible differential search tool from design
and cryptanalysis aspects - revealing structural properties of several ciphers. In
Coron and Nielsen [CN17], pages 185–215.

[SWW17]

Ling Sun, Wei Wang, and Meiqin Wang. Automatic search of bit-based division
property for ARX ciphers and word-based division property. In Tsuyoshi Takagi
and Thomas Peyrin, editors, ASIACRYPT 2017, Part I, volume 10624 of LNCS,
pages 128–157. Springer, Heidelberg, December 2017.

[SWW20]

Ling Sun, Wei Wang, and Meiqin Wang. Milp-aided bit-based division property
for primitives with non-bit-permutation linear layers. IET Information Security,
14(1):12–20, 2020.

[TAY17]

Mohamed Tolba, Ahmed Abdelkhalek, and Amr M. Youssef. Multidimensional
zero-correlation linear cryptanalysis of reduced round SPARX-128. In Adams and
Camenisch [AC17], pages 423–441.

[TLS16]

Yosuke Todo, Gregor Leander, and Yu Sasaki. Nonlinear invariant attack - practical attack on full SCREAM, iSCREAM, and Midori64. In Jung Hee Cheon and
Tsuyoshi Takagi, editors, ASIACRYPT 2016, Part II, volume 10032 of LNCS, pages
3–33. Springer, Heidelberg, December 2016.

[TM16]

Yosuke Todo and Masakatu Morii. Bit-based division property and application to
simon family. In Peyrin [Pey16], pages 357–377.

[Tod15]

Yosuke Todo. Structural evaluation by generalized integral property. In Elisabeth
Oswald and Marc Fischlin, editors, EUROCRYPT 2015, Part I, volume 9056 of
LNCS, pages 287–314. Springer, Heidelberg, April 2015.

[VBCG14]

S. Varrette, P. Bouvry, H. Cartiaux, and F. Georgatos. Management of an academic
hpc cluster: The ul experience. In Proc. of the 2014 Intl. Conf. on High Performance
Computing & Simulation (HPCS 2014), pages 959–967, Bologna, Italy, July 2014.
IEEE.

[VV17]

Serge Vaudenay and Damian Vizár. Under pressure: Security of caesar candidates beyond their guarantees. Cryptology ePrint Archive, Report 2017/1147, 2017.
https://eprint.iacr.org/2017/1147.

[Wag99]

David Wagner. The boomerang attack. In Knudsen [Knu99], pages 156–170.

[WT86]

A. F. Webster and Stafford E. Tavares. On the design of S-boxes (impromptu talk).
In Hugh C. Williams, editor, CRYPTO’85, volume 218 of LNCS, pages 523–534.
Springer, Heidelberg, August 1986.

[XZBL16]

Zejun Xiang, Wentao Zhang, Zhenzhen Bao, and Dongdai Lin. Applying MILP
method to searching integral distinguishers based on division property for 6
lightweight block ciphers. In Cheon and Takagi [CT16], pages 648–678.

[YZS+ 15]

Gangqiang Yang, Bo Zhu, Valentin Suder, Mark D. Aagaard, and Guang Gong. The
simeck family of lightweight block ciphers. In Tim Güneysu and Helena Handschuh,
editors, CHES 2015, volume 9293 of LNCS, pages 307–329. Springer, Heidelberg,
September 2015.

[ZR19]

Wenying Zhang and Vincent Rijmen. Division cryptanalysis of block ciphers with
a binary diffusion layer. IET Information Security, 13(2):87–95, 2019.

83

A C Implementation of Sparkle
All permutations in the Sparkle family are implemented by the following function, where nb is
the number of branches (4 for Sparkle256, 6 for Sparkle384 and 8 for Sparkle512) and where
ns is the number of steps.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56

# define MAX_BRANCHES 8
# define ROT (x , n ) ((( x ) >> ( n ) ) | (( x ) << (32 -( n ) ) ) )
# define ELL ( x ) ( ROT ((( x ) ^ (( x ) << 16) ) , 16) )
// Round constants
static const uint32_t RCON [ MAX_BRANCHES ] = {
\
0 xB7E15162 , 0 xBF715880 , 0 x38B4DA56 , 0 x324E7738 , \
0 xBB1185EB , 0 x4F7C7B57 , 0 xCFBFA1C8 , 0 xC2B3293D \
};
void sparkle ( uint32_t * state , int nb , int ns )
{
int i , j ; // Step and branch counter
uint32_t rc , tmpx , tmpy , x0 , y0 ;
for ( i = 0; i < ns ; i ++) {
// Counter addition
state [1] ^= RCON [ i % MAX_BRANCHES ];
state [3] ^= i ;
// ARXBox layer
for ( j = 0; j < 2* nb ; j += 2) {
rc = RCON [j > >1];
state [ j ] += ROT ( state [ j +1] , 31) ;
state [ j +1] ^= ROT ( state [ j ] , 24) ;
state [ j ] ^= rc ;
state [ j ] += ROT ( state [ j +1] , 17) ;
state [ j +1] ^= ROT ( state [ j ] , 17) ;
state [ j ] ^= rc ;
state [ j ] += state [ j +1];
state [ j +1] ^= ROT ( state [ j ] , 31) ;
state [ j ] ^= rc ;
state [ j ] += ROT ( state [ j +1] , 24) ;
state [ j +1] ^= ROT ( state [ j ] , 16) ;
state [ j ] ^= rc ;
}
// Linear layer
tmpx = x0 = state [0];
tmpy = y0 = state [1];
for ( j = 2; j < nb ; j += 2) {
tmpx ^= state [ j ];
tmpy ^= state [ j +1];
}
tmpx = ELL ( tmpx ) ;
tmpy = ELL ( tmpy ) ;
for ( j = 2; j < nb ; j += 2) {
state [j -2] = state [ j + nb ] ^ state [ j ] ^ tmpy ;
state [ j + nb ] = state [ j ];
state [j -1] = state [ j + nb +1] ^ state [ j +1] ^ tmpx ;
state [ j + nb +1] = state [ j +1];
}
state [ nb -2] = state [ nb ] ^ x0 ^ tmpy ;
state [ nb ] = x0 ;
state [ nb -1] = state [ nb +1] ^ y0 ^ tmpx ;
state [ nb +1] = y0 ;
}
}

84

B Linear Trails in Alzette
Table B.1: The input and output masks 𝛼, 𝛽 (in hex) of all linear trails over Alzette corresponding
to maximum expected absolute linear trail correlation 𝑐 = 2−2 and 𝑐 = 2−5 for four and five
rounds, respectively. The column max{− log2 (˜
𝑐)} represents the smallest observed correlations of
the approximations taken over all (combinations of) Alzette instances that can occur without a step
counter addition. Similarly, the column min{− log2 (˜
𝑐)} represents the largest observed correlations
of the approximations. In all of the experiments, the sample size was 224 .
− log2 (|𝑐|)

min{− log2 (|˜
𝑐|)}

c001018101800001
800101c101c00001
800101c101c00001
c001018101800001

2.00
2.00
2.00
2.00

max{− log2 (|˜
𝑐|)}

01c00181c1808081
01c081c1c180c081
01c081c1c180c081
41c00101c18080c1
41c00101c18080c1
41c08141c180c0c1
01e08141e180c0c1
41c08141c180c0c1
01e08141e180c0c1
01e00101e18080c1
41e00181e1808081
41e081c1e180c081
01e00101e18080c1
41e00181e1808081
41e081c1e180c081
01c00181c1808081

5.00
5.00
5.00
5.00
5.00
5.00
5.00
5.00
5.00
5.00
5.00
5.00
5.00
5.00
5.00
5.00

5.62
5.60
5.59
5.60
5.60
5.61
5.59
5.61
5.60
5.61
5.61
5.61
5.61
5.61
5.61
5.61

5.49
5.47
5.51
5.48
5.48
5.48
5.49
5.49
5.47
5.50
5.48
5.49
5.49
5.48
5.50
5.49

rounds

𝛼

𝛽

4

0000030180020100
0000030180020100
0000020180020180
0000020180020180

5

0000020180020180
0000030180020100
0000020180020180
0000030180020100
0000020180020180
0000020180020180
0000020180020180
0000030180020100
0000030180020100
0000020180020180
0000030180020100
0000020180020180
0000030180020100
0000020180020180
0000030180020100
0000030180020100

85

2.00
2.00
2.00
2.00

2.00
2.00
2.00
2.00

Table B.2: The input and output masks 𝛼, 𝛽 (in hex) of all linear trails over Alzette corresponding to maximum expected absolute linear trail correlation 𝑐 = 2−8 for six rounds. The column
max{− log2 (˜
𝑐)} represents the smallest observed correlations of the approximations taken over all
combinations of Alzette instances that can occur without a step counter addition. Similarly, the
column min{− log2 (˜
𝑐)} represents the largest observed correlations of the approximations. In all
of the experiments, the sample size was 228 .
− log2 (|𝑐|)

rounds

𝛼

𝛽

6

0000020180020180
0000030180020100
0000020180020180
0000020180020180
0000020180020180
0000030180020100
0000030180020100
0000030180020100
0000020180020180
0000020180020180
0000020180020180
0000020180020180
0000020180020180
0000030180020100
0000020180020180
0000030180020100
0000030180020100
0000030180020100
0000030180020100
0000030180020100
0000030180020100
0000020180020180
0000030180020100
0000020180020180
0000030180020100
0000030180020100
0000030180020100
0000020180020180
0000030180020100
0000030180020100
0000030180020100
0000030180020100
0000020180020180
0000020180020180
0000020180020180
0000020180020180
0000020180020180
0000030180020100
0000030180020100
0000030180020100
0000020180020180
0000030180020100
0000020180020180
0000020180020180
0000020180020180
0000020180020180
0000030180020100
0000020180020180

05638604c3828201
05638604c3828201
05c38604c3828241
04838604c3828281
06038604c3828381
05c38604c3828241
04838604c3828281
06038604c3828381
05638484c2828201
05c38484c2828241
04838484c2828281
06038484c2828381
05c3c404e2828241
07438604c3828301
07438604c3828301
05638484c2828201
05c38484c2828241
07e38484c2828301
07438484c2828341
04838484c2828281
07438484c2828301
07e38604c3828301
05c3c404e2828241
0563c404e2828201
05c38484c2828201
05c38604c3828201
06038484c2828381
05c3c684e3828241
0743c404e2828341
0563c404e2828201
05c3c684e3828241
07e38604c3828301
07438484c2828341
07438484c2828301
05c38604c3828201
0743c404e2828341
07e3c404e2828301
0743c684e3828341
0563c684e3828201
07e3c684e3828301
07e38484c2828301
07e3c404e2828301
0743c684e3828341
0563c684e3828201
07438604c3828341
05c38484c2828201
07438604c3828341
07e3c684e3828301

86

8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00
8.00

max{− log2 (|˜
𝑐|)}
9.61
9.69
8.69
9.20
9.09
8.71
9.08
9.14
9.69
8.69
9.17
9.10
9.65
9.12
9.10
9.59
8.74
9.69
8.71
9.08
9.11
9.56
9.74
8.70
9.05
9.12
9.18
9.67
9.63
8.73
9.70
9.70
8.69
9.12
9.09
9.67
8.72
9.54
8.76
8.72
9.60
8.68
9.61
8.74
8.74
9.06
8.65
8.75

min{− log2 (|˜
𝑐|)}
8.50
8.48
8.00
8.22
8.23
8.01
8.25
8.23
8.48
8.01
8.26
8.21
8.48
8.24
8.20
8.49
8.03
8.47
8.01
8.23
8.23
8.50
8.48
8.02
8.25
8.25
8.24
8.51
8.50
8.02
8.52
8.49
8.03
8.20
8.25
8.47
8.01
8.51
8.01
8.03
8.51
8.01
8.47
8.02
8.00
8.20
8.00
8.01

C Representations of the Primitives
The following pages, contain diagrams describing all our algorithms. Their purpose is to help
cryptanalysts in their task.
∙ Figure C.1 contains the absorption of Esch256.
∙ Figure C.2 contains the absorption of Esch384.
∙ Figure C.3 contains the encryption of Schwaemm256-128.
∙ Figure C.4 contains the encryption of Schwaemm192-192.
∙ Figure C.5 contains the encryption of Schwaemm128-128.
∙ Figure C.6 contains the encryption of Schwaemm256-256.
∙ Figure C.7 contains the high-level structure of Sparkle with the notation defined in 4.4.1.

87

Figure C.1: Esch256 (slim). 3+3 branches, 2 branches rate, 7 steps.
𝑃𝑖,0

𝑃𝑖,1

064

ℳ3

𝑐0
𝐴𝑐0

0
𝐴𝑐1

𝐴𝑐2

𝐴𝑐3

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐3

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐3

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐3

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐3

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐3

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐3

𝐴𝑐 4

𝐴𝑐5

′

ℓ

𝑐1
𝐴𝑐 0

1
𝐴𝑐1

𝐴𝑐2
′

ℓ

𝑐2
𝐴𝑐 0

2
𝐴𝑐1

𝐴𝑐2
ℓ′

𝑐3
𝐴𝑐 0

3
𝐴𝑐1

𝐴𝑐 2
′

ℓ

𝑐4
𝐴𝑐 0

4
𝐴𝑐1

𝐴𝑐 2
′

ℓ

𝑐5
𝐴𝑐 0

5
𝐴𝑐1

𝐴𝑐 2
ℓ′

𝑐6
𝐴𝑐 0

6
𝐴𝑐1

𝐴𝑐 2
′

ℓ

𝑃𝑖+1,0
𝑃𝑖+1,1

064

ℳ3
88

Figure C.2: Esch384 (slim). 4+4 branches, 2 branches rate, 8 steps.
𝑃𝑖,0

𝑃𝑖,1

064

064

ℳ4

𝑐0
𝐴𝑐 0

0
𝐴𝑐1

𝐴𝑐2

𝐴𝑐3

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐 6

𝐴𝑐7

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐 6

𝐴𝑐7

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐 6

𝐴𝑐7

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐 6

𝐴𝑐7

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐 6

𝐴𝑐7

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐6

𝐴𝑐7

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐6

𝐴𝑐7

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐6

𝐴𝑐7

′

ℓ

𝑐1
𝐴𝑐 0

1
𝐴𝑐1

𝐴𝑐2

𝐴𝑐 3
′

ℓ

𝑐2
𝐴𝑐0

2
𝐴𝑐1

𝐴𝑐2

𝐴𝑐 3
′

ℓ

𝑐3
𝐴𝑐0

3
𝐴𝑐1

𝐴𝑐2

𝐴𝑐 3
′

ℓ

𝑐4
𝐴𝑐0

4
𝐴𝑐 1

𝐴𝑐2

𝐴𝑐 3
′

ℓ

𝑐5
𝐴𝑐0

5
𝐴𝑐 1

𝐴𝑐2

𝐴𝑐 3
′

ℓ

𝑐6
𝐴𝑐0

6
𝐴𝑐 1

𝐴𝑐2

𝐴𝑐 3
′

ℓ

𝑐7
𝐴𝑐0

7
𝐴𝑐 1

𝐴𝑐2

𝐴𝑐 3
′

ℓ

𝑃𝑖+1,0
𝑃𝑖+1,1

064

064

ℳ4
89

Figure C.3: Schwaemm256-128 (slim). 3+3 branches, 4 branches rate, 7 steps.
𝑃𝑖,0

𝑃𝑖,1

𝑃𝑖,2

𝑃𝑖,3
𝜌

𝐶𝑖,0

𝐶𝑖,1

𝐶𝑖,2

𝐶𝑖,3
𝑐0
𝐴𝑐 0

0
𝐴𝑐1

𝐴𝑐 2

𝐴𝑐 3

𝐴𝑐4

𝐴𝑐5

𝐴𝑐3

𝐴𝑐4

𝐴𝑐5

𝐴𝑐3

𝐴𝑐4

𝐴𝑐5

𝐴𝑐3

𝐴𝑐4

𝐴𝑐5

𝐴𝑐3

𝐴𝑐4

𝐴𝑐5

𝐴𝑐3

𝐴𝑐4

𝐴𝑐5

𝐴𝑐3

𝐴𝑐4

𝐴𝑐5

′

ℓ

𝑐1
𝐴𝑐 0

1
𝐴𝑐1

𝐴𝑐 2
′

ℓ

𝑐2
𝐴𝑐 0

2
𝐴𝑐1

𝐴𝑐 2
ℓ′

𝑐3
𝐴𝑐 0

3
𝐴𝑐1

𝐴𝑐 2
′

ℓ

𝑐4
𝐴𝑐 0

4
𝐴𝑐1

𝐴𝑐 2
′

ℓ

𝑐5
𝐴𝑐 0

5
𝐴𝑐1

𝐴𝑐 2
ℓ′

𝑐6
𝐴𝑐 0

6
𝐴𝑐1

𝐴𝑐 2
′

ℓ

𝑃𝑖+1,0 𝑃𝑖+1,1 𝑃𝑖+1,2 𝑃𝑖+1,3
𝜌
𝐶𝑖+1,0 𝐶𝑖+1,1 𝐶𝑖+1,2 𝐶𝑖+1,3
90

Figure C.4: Schwaemm192-192 (slim). 3+3 branches, 3 branches rate, 7 steps.
𝑃𝑖,0

𝑃𝑖,1

𝑃𝑖,2
𝜌

𝐶𝑖,0

𝐶𝑖,1

𝐶𝑖,2
𝑐0
𝐴𝑐 0

0
𝐴𝑐1

𝐴𝑐 2

𝐴𝑐3

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐3

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐3

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐3

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐3

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐3

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐3

𝐴𝑐 4

𝐴𝑐5

ℓ′

𝑐1
𝐴𝑐 0

1
𝐴𝑐1

𝐴𝑐 2
′

ℓ

𝑐2
𝐴𝑐 0

2
𝐴𝑐1

𝐴𝑐 2
ℓ′

𝑐3
𝐴𝑐 0

3
𝐴𝑐1

𝐴𝑐 2
ℓ′

𝑐4
𝐴𝑐 0

4
𝐴𝑐1

𝐴𝑐 2
′

ℓ

𝑐5
𝐴𝑐 0

5
𝐴𝑐1

𝐴𝑐 2
ℓ′

𝑐6
𝐴𝑐 0

6
𝐴𝑐1

𝐴𝑐 2
ℓ′

𝑃𝑖+1,0 𝑃𝑖+1,1 𝑃𝑖+1,2
𝜌
𝐶𝑖+1,0 𝐶𝑖+1,1 𝐶𝑖+1,2
91

Figure C.5: Schwaemm128-128 (slim). 2+2 branches, 2 branches rate, 7 steps.
𝑃𝑖,0

𝑃𝑖,1
𝜌

𝐶𝑖,0

𝐶𝑖,1

𝑐0
𝐴𝑐 0

0
𝐴𝑐1

𝐴𝑐2

𝐴𝑐 3

𝐴𝑐2

𝐴𝑐 3

𝐴𝑐2

𝐴𝑐 3

𝐴𝑐2

𝐴𝑐 3

𝐴𝑐2

𝐴𝑐 3

𝐴𝑐2

𝐴𝑐 3

𝐴𝑐2

𝐴𝑐 3

′

ℓ

𝑐1
𝐴𝑐 0

1
𝐴𝑐1
ℓ′

𝑐2
𝐴𝑐 0

2
𝐴𝑐1
′

ℓ

𝑐3
𝐴𝑐 0

3
𝐴𝑐1
′

ℓ

𝑐4
𝐴𝑐 0

4
𝐴𝑐1
ℓ′

𝑐5
𝐴𝑐 0

5
𝐴𝑐1
′

ℓ

𝑐6
𝐴𝑐 0

6
𝐴𝑐1
ℓ′

𝑃𝑖+1,0 𝑃𝑖+1,1
𝜌
𝐶𝑖+1,0 𝐶𝑖+1,1
92

Figure C.6: Schwaemm256-256 (slim). 4+4 branches, 4 branches rate, 8 steps.
𝑃𝑖,0

𝑃𝑖,1

𝑃𝑖,2

𝑃𝑖,3
𝜌

𝐶𝑖,0

𝐶𝑖,1

𝐶𝑖,2

𝐶𝑖,3
𝑐0
𝐴𝑐0

0
𝐴𝑐 1

𝐴𝑐2

𝐴𝑐 3

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐6

𝐴𝑐7

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐6

𝐴𝑐7

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐6

𝐴𝑐7

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐6

𝐴𝑐7

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐6

𝐴𝑐7

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐6

𝐴𝑐7

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐6

𝐴𝑐7

𝐴𝑐 4

𝐴𝑐5

𝐴𝑐6

𝐴𝑐7

′

ℓ

𝑐1
𝐴𝑐0

1
𝐴𝑐 1

𝐴𝑐2

𝐴𝑐 3
′

ℓ

𝑐2
𝐴𝑐0

2
𝐴𝑐 1

𝐴𝑐2

𝐴𝑐 3
′

ℓ

𝑐3
𝐴𝑐0

3
𝐴𝑐 1

𝐴𝑐2

𝐴𝑐 3
′

ℓ

𝑐4
𝐴𝑐0

4
𝐴𝑐 1

𝐴𝑐2

𝐴𝑐 3
′

ℓ

𝑐5
𝐴𝑐0

5
𝐴𝑐 1

𝐴𝑐2

𝐴𝑐 3
′

ℓ

𝑐6
𝐴𝑐0

6
𝐴𝑐 1

𝐴𝑐2

𝐴𝑐 3
′

ℓ

𝑐7
𝐴𝑐0

7
𝐴𝑐 1

𝐴𝑐2

𝐴𝑐 3
′

ℓ

𝑃𝑖+1,0 𝑃𝑖+1,1 𝑃𝑖+1,2 𝑃𝑖+1,3
𝜌
𝐶𝑖+1,0 𝐶𝑖+1,1 𝐶𝑖+1,2 𝐶𝑖+1,3
93

Figure C.7: High-level structure of SPARKLE with 8 steps.

A0

B0
M
R

B1

A1
M

R
A2

B2
M
R

B3

A3
M

R
A4

B4
M
R

B5

A5
M

R
A6

B6
M
R

B7

A7
M

R

94

